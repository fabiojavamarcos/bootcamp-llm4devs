Network_x,Interpreter_x,i18n_x,Logic_x,Test_x,App_x,Author,prNumber,Network_y,Interpreter_y,i18n_y,Logic_y,Test_y,App_y,Title,Body,Comments
0,0,0,0,0,0,Peter Tackage, 4585,0,0,1,0,1,0, 2.x: Evaluate Schedule initialization via Callable, This implements the solution proposed in #4572 - to initialize the Schedulers via a Callable  rather than directly via a value.,
0,0,0,0,0,0,Vedran Prišćan, 5930,0,0,1,0,0,0, Add @NonNull annotations to create methods of Subjects and Processors, I am annotating *Subject s and *Processor s create methods with @NonNull annotations to remove compiler s nullability warnings when calling the methods from Kotlin language.,
0,0,1,0,1,1,Shixiong Zhu, 385 390 409 415 416 424 450 452 460 463 478 480 481 492 496 575 594 862 870 965 966 1056 1065 1088 1097 1099 1100 1111 1112 1134 1142 1160 1269 1367 1778 2642 2999 3000 3462 3468 3868 3977 4447 4619 4631,0,0,1,0,1,1, Implemented the  any  operator Implemented the  elementAt  and  elementAtOrDefault  operators. see #41 Implemented  Synchronize  with  lock Implemented the  Empty  operator with scheduler Implemented the  Throw  operator with scheduler Implemented the  IgnoreElements  operator Implemented the  TimeInterval  operator Implemented the scheduler version of the  Return  operator Implemented the  Amb  operator Added the rest overloads of Timeout operator Implemented the  Operator: Min and MinBy  and  Operator: Max and MaxBy BugFix: Emit an IllegalArgumentException instead of ArithmeticException if the observable is empty Implement the  Using  operator Implement the scheduler overloads for Range  From  StartWith Add contravariant for min and max Reimplement the  SequenceEqual  operator Implement the  Start  operator Update the timeout docs Add the selector variants of timeout in RxScala BugFix: Chain Subscription in TimeoutSubscriber and SerializedSubscriber Reimplement the ElementAt operator and add it to rxjava-scala Add drop(skip) and dropRight(skipLast) to rxscala Optimize OperatorSkipLastTimed OperatorToObservableFuture OperatorToMultimap OperatorToMap OperatorUsing OperatorTimeInterval OperatorThrottleFirst OperatorTakeLast Update  contains  signature to  contains(Object) Add  replay  and  multicast  variants to RxScala Fix the bug that int overflow can bypass the range check Fix the bug that  flatMap  swallows OnErrorNotImplementedException Change Transformer to Func1<Observable<T>  Observable<R>> Fix a potential memory leak in schedulePeriodically Fix a wrong assertion in assertError Replace the Java 7 AssertionError(message  cause) with initCause 1.x: A minor doc fix for  interval 1.x: Fix other places that may swallow OnErrorFailedException Fix an unsubscribe race in EventLoopWorker 1.x: Use the correct Throwable to set the cause for CompositeException Fix withLatestFrom s tparam 2.x: Make CompositeExcpetion thread-safe like 1.x and also fix some issues 2.x: Don t wrap with CompositeException when there is only one error, This implements the operator  Any  from #24 in all two variants.  However  I encountered two problems.  Updated: the online document http://msdn.microsoft.com/en-us/library/hh211993(v=vs.103).aspx is wrong. See my later discussion.  Another question is if I add the  any  method to  rx.Observable<T>   some unit tests will fail as the method  any  in   rx.Observable<T>  overrides the method  org.mockito.Matchers.any(java.lang.Class<T>)  in some unit tests (e.g.   rx.subjects.ReplaySubject<T> ). Do I need to use another method name  or just modify the unit tests? Now the  any  methods in  rx.Observable<T>  are commented out.  Thanks. Hi   This implements the  ElementAt  and  ElementAtOrDefault  operators from #41.  For  ElementAt   if the index is less than 0  or greater than or equal to the number of elements in the source sequence  an IndexOutOfBoundsException will be threw.  For  ElementAtOrDefault    if the index is less than 0  an IndexOutOfBoundsException will be threw. What s more  I added a  defaultValue  parameter. I can not get the element type in the source observable due to type erasure. So I can not determine the default value automatically. That s why  ElementAtOrDefault  needs  a  defaultValue  parameter. Hi   I implemented #84 to support that sending a lock to the  synchronize  operator.  I also found that there was a issue that  testMultiThreadedWithNPE  and  testMultiThreadedWithNPEinMiddle  might fail in some special situation. When  onError  is invoked before any  onNext   the last statement  assertEquals(1  busyObserver.maxConcurrentThreads.get())   in these methods will fail. I also fixed this issue in the pull request. Hi   I implemented the  Empty  operator with scheduler #42. Please take a look. Thanks. Hi   I implemented the  Throw  operator #89 with scheduler. I found that RxJava had an  error  method. So I just implemented the scheduler overload. Hi   I implemented the  IgnoreElements  operator #54. Please take a look. Thanks. Hi  this PR implemented the  TimeInterval  operator #90. Please take a look. Thanks. Hi  this is the scheduler version of the  Return  operator #73. Hi  this PR implemented the  Amb  operator #22. I used varargs to support the array version and first-second version in one method. So in my PR  there are only two variants. Hi  this PR implemented the rest overloads of  Timeout  operator #91. Please take a look. Thanks. Hi  this PR implemented the  Operator: Min and MinBy  #63 and  Operator: Max and MaxBy  #61. Every operator has 2 variants  one for  Comparable   another for  Comparator . Please take a look. Thanks! This PR fixed the  average  issue in #423. If an observable is empty   average  will emit an  IllegalArgumentException  instead of  ArithmeticException . Thanks! Hi  this PR implemented the  Using  operator #99. Please take a look. Thanks! Hi  this PR implemented the scheduler overloads for Range #68  From #98   StartWith #82. Please take a look. Thanks! Hi  this PR added  contravariant for min and max mentioned in #494. Hi  this PR reimplemented the  SequenceEqual  operator #76 and should fix the issue #564.  The wiki page https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#sequenceequal still needs to be updated. @DavidMGross could you help update the marble diagram of  SequenceEqual ? Thanks! Hi  this PR implemented the  Start  operator #81. Please take a look. Updated the timeout docs. This PR added the selector variants of the  timeout  operator in the Scala and also added two examples. This PR chains Subscription in TimeoutSubscriber  and SerializedSubscriber. Found by @rbramw #951. Thanks for your unit tests  @rbramw nan nan Changed OperatorSkipLastTimed to only cache the latest items in the specified time window. Also make the Observable be able to unsubscribe.  Issue #1060 Operator  ToMultimap   Issue #1060 Operator  ToMap   Issue #1060 Operator  Using   Issue #1060 Operator  TimeInterval   Issue #1060 Operator  ThrottleFirst  and moved tests in  ThrottleFirstTests  to  OperatorThrottleFirstTest .  Issue #1060 Operator  TakeLast .  There are two changes comparing with the original implementations: - Throw IndexOutOfBoundsException at once when calling  takeLast  with  count < 0 . - Replace IllegalArgumentException with IndexOutOfBoundsException  when  count < 0  in  TakeLastWithTimed .  Issue #1060 The original  contains  signature can not support the following codes:      java     public void test() {         ArrayList<String> l = new ArrayList<String>()          l.add( test )          Observable<ArrayList<String>> o = Observable.<ArrayList<String>>from(l)          o.contains(Arrays.asList( test ))      }      This PR changes the signature from  contains(T)  to  contains(Object) . It s also consistent with  equals(Object) .  This change should not break the old codes. This PR has some breaking changes: - Change  def multicast[R >: T](subject: rx.lang.scala.Subject[R]): (() => Subscription  Observable[R])  to  def multicast[R >: T](subject: rx.lang.scala.Subject[R]): ConnectableObservable[R]  - Change  def replay: (() => Subscription  Observable[T])  to  def replay: ConnectableObservable[T]  - Remove  Observable.apply(Int)   So it s better to merge it at the next major release. #1152  #1153.  /cc @headinthebox @samuelgruetter Fix the bug mentioned in #1266 Fixed #1365 Not sure if any other place will swallow  OnErrorNotImplementedException  or the fatal errors. Less variance is better. I cannot find any bad case for this PR. Can someone help test it in Java 8 and Groovy? There is a potential memory leak in  schedulePeriodically  that may keep a reference to  action  after  unsubscribe .   Because  mas.set  is called after  schedule    it may replace a new Subscription (created in  recursiveAction ) with the old one. Therefore   unsubscribe  won t be able to unsubscribe the new Subscription and will keep the reference to  action  until the period time elapses.  This PR fixed it by calling  mas.set  before  schedule . nan AssertionError(message  cause)  is a Java 7 API. This PR uses RuntimeException to replace it  just like  assertNoErrors . nan Reviewed all usages of  OnErrorNotImplementedException  and fixed issues similar to #3455. There is an unsubscribe race condition similar to #3842 in  CachedThreadScheduler.EventLoopWorker  and  EventLoopsScheduler.EventLoopWorker . Image the following execution order:  | Execution Order | thread 1 | thread 2 | | --- | --- | --- | | 1 |  | submit task A | | 2 |  | submit task B | | 3 | unsubscribe Worker |  | | 4 | unsubscribe task A |  | | 5 |  | task A won t run as it s unsubscribed | | 6 |  | run task B | | 7 | unsubscribe task B |  |  So task B will run but its previous task A will be skipped.  This PR adds a check before running an action and moves  workerUnderConcurrentUnsubscribeShouldNotAllowLaterTasksToRunDueToUnsubscriptionRace  to  AbstractSchedulerConcurrencyTests  to test all concurrent schedulers. The cause of #3679 is we use a wrong Throwable (its cause has been set) to set the cause and  initCause  will throw an exception. Hence  the cause chain is not created correctly. In this PR  it searches the root cause (which doesn t have a cause) and use it to call  initCause . nan Right now CompositeExcpetion has several issues: -  CompositeException(Throwable... exceptions)  doesn t deduplicate exceptions and flatten CompositeExceptions like  CompositeException(Iterable<? extends Throwable> errors)  - If using  CompositeException(Iterable<? extends Throwable> errors)  to create CompositeException   suppress  cannot be used. -  suppress  doesn t update  cause . -  suppress  doesn t deduplicate exceptions and flatten CompositeExceptions. -  suppress  and  Throwable.addSuppressed  are pretty confusing for Java 7+ users. Without looking at the implementation  it s hard to figure out the differences.  This PR made the following changes: - Remove  CompositeException.suppress  so that it s easy to make CompositeException thread-safe.   - This may cause some performance lost in some path rarely happening  e.g.  an excpetion is thrown from  onError   but that s not a big deal.   - Since  suppress  is removed  it doesn t make sense to create an empty CompositeException  so  isEmpty  is removed and defense codes are added. - Defense codes for bad exceptions. - Deduplicate excepctions and flatten CompositeExceptions for  CompositeException(Throwable... exceptions) . nan,
0,0,0,0,0,0,Zsombor Erdődy-Nagy, 4567,0,0,1,0,1,0, Add extra Maybe iterable Amb tests for overlapped emissions, - Asserting that downstream will get the results of the first source that began emission  even if multiple sources have overlapped emissions - Testing Success and Error paths,
0,0,0,0,1,0,Logan Johnson, 1766 1767 3498 3733,0,0,1,1,1,1, Unhandled errors go to UncaughtExceptionHandler ExecutorScheduler delivers uncaught exceptions 1.x: Rename cache(int) to cacheWithInitialCapacity(int) Avoid swallowing errors in Completable, Rather than swallowing/logging errors  ScheduledAction now delivers them to the UncaughtExceptionHandler for the executing Thread. This gives client applications control over the handling of errors that occur off of the calling Thread. Instead of swallowing unhandled errors  ExecutorScheduler delivers them to the executing thread s UncaughtExceptionHandler.  This addresses the same issue as ReactiveX/RxJava#1682  but for ExecutorScheduler which does not used ScheduledAction. ~~The parameter is a capacity hint  but more frequently confused with a buffer size like replay(int) than it is correctly understood. It also offers no guarantees  only the weak hope of optimization.~~  The parameter is a capacity hint  but more frequently confused with a buffer size like replay(int) than it is correctly understood. It also offers no guarantees  only the weak hope of optimization.  This change renames the method  deprecating the old name. It also adds javadoc calling out that the parameter is not a bound and referencing replay(int).autoConnect() as a way to achieve that behavior. Instead  deliver them up to the thread s uncaught exception handler.  Fixes reactivex/rxjava#3726,
0,0,0,0,0,0,Luis Cortes, 6544 6556 6193 6199,0,0,1,0,1,1, Fixing version tag on Schedulers.from(Executor  boolean) 3.x rename on error resume next methods to disambiguate when calling from kotlin (#6551) Add  error handling  java docs section to from callable & co Fix terminology of cancel/dispose in the JavaDocs, Resolves #6543   Updating the version tag on  Schedulers.from(Executor  boolean)  since it was promoted. Resolves #6551   - Renamed  onErrorResumeNext(Source)  to  onErrorResumeWith(Source)  for  Observable    Maybe    Single   and  Flowable  - Renamed some unit tests and their classes to reflect the method name change - Changed parameter type of  Single.onErrorResumeWith  from  Single  to  SingleSource    - Updated JavaDocs for all renamed methods - Removed redundant casts for unit tests - Deleted duplicate unit test that arose from no longer needing to cast arguments Resolves #6179  Added JavaDocs describing the regular and canceled/disposed behavior for  -  Observable.fromCallable()  -  Single.fromCallable()  -  Maybe.fromAction()  -  Completable.fromCallable()  -  Completable.fromAction()  -  Flowable.fromCallable()   Did not alter  Maybe.fromCallable()  because the existing JavaDoc appears to be adequate. Resolves #6196  Changing terminology from cancel -> dispose wherever appropriate in the following classes:  -  Observable.java  -  Single.java  -  Maybe.java  -  Completable.java   Areas where I did _not_ change from cancel -> disposal include:   - where the cancellation was in reference to a  Flowable    Publisher   or a  Future  -  test()  methods where the  TestObserver  returned actually has a  cancel()  method,
0,0,0,0,0,0,Dmitriy Zaitsev, 4793 4118 4120,0,0,0,0,1,1, 2.x: Fix exceptions in javaDoc 1.x: provide an explanation why certain tests are ignored 2.x: provide an explanation why certain tests are ignored, I ve corrected some javadocs for methods that check arguments using  ObjectHelper.requireNonNull(arg   message ) . It throws  NullPointerException  instead of  IllegalArgumentException   but as we know copy-pasting is an insidious thing.  ) During code reading I ve found some tests that are ignored but don t have a record why they are being ignored. Some of them have meaningful explanations present as line comments  so I decided to make them the parameters of  @Ignore  annotation  so it will be correct. The same as #4118  but for 2.x,
0,1,1,0,1,1,David Karnok, 6375 6398 6405 4639 4641 4648 4658 4661 6488 4663 6498 4666 4667 4674 4678 506 513 514 563 565 567 571 587 593 609 612 635 638 657 659 664 667 733 734 735 736 738 739 740 741 4686 6504 6506 4689 6507 6511 6514 6516 6517 4692 818 819 824 6519 4696 6522 6523 6526 955 958 964 972 1012 4701 1061 1062 1066 1073 1079 1080 1081 1083 1084 1085 1086 1087 1095 1096 1098 1103 1106 1107 1108 1109 1110 1117 1118 1119 1120 1121 1122 1128 1130 1131 1144 1158 1161 4705 1175 1183 1185 4706 1195 1223 4708 4712 4714 1235 1236 1237 1248 1271 1272 1287 4716 4717 4720 1747 4723 1751 1752 1757 1866 1922 1937 1947 1973 2053 2332 2335 2465 2470 2477 2493 2553 2561 2565 2572 2585 2591 2601 2622 2627 2630 2648 2760 2762 2767 2804 2817 2818 2820 2831 2837 2883 4730 2901 2907 2923 2928 2948 2963 2969 2970 2972 2983 3023 3029 3039 3048 3052 3093 3109 3110 3112 3117 3129 3141 3149 3150 3169 3172 3175 3183 3185 3186 3188 3189 3190 3191 3193 3194 3196 3197 3198 3199 3200 3202 3204 3205 3206 3207 3208 3209 3212 3215 3220 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3234 3235 3237 3238 3240 3241 3242 3243 3244 3245 3246 3247 3248 3250 3251 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3265 3267 3268 3270 3271 3273 3275 3276 3277 3278 3279 3280 3282 3283 3284 3292 3293 3294 3297 3298 3300 3301 3303 3305 3306 3309 3311 3312 3313 3315 3316 3317 3318 3319 3320 3322 3323 3325 3327 3328 3329 4732 3330 3331 3333 3334 3335 3352 3353 4736 6529 6530 3354 3357 3358 3371 3376 3382 3408 6531 3438 3444 3447 3467 6532 6534 3470 3477 3512 3513 6535 3569 3585 3614 6537 6538 3661 3668 4738 4742 6539 3671 3678 3682 4747 3683 3689 3692 4751 3707 4755 4761 4763 3752 3753 3756 3759 3760 3763 3765 3783 4766 3787 3822 3824 3828 3836 3848 3883 3887 3888 3898 3907 3909 3918 3919 3934 3936 3941 3942 3949 4770 3951 3966 3971 3974 3981 3987 3996 4005 4011 4783 4019 4024 4026 4027 4030 4819 4824 4830 4831 4832 4833 4835 4838 4839 4846 4034 4039 4041 4042 4849 4043 4851 4852 4858 4873 4045 4877 6564 4884 4049 4885 4893 6566 6570 6572 4911 4921 4927 4930 4932 6579 4943 4945 6581 6582 4949 4955 4957 4962 4963 4966 4967 4970 4051 4974 4059 4060 4063 4088 4091 4096 4097 4103 4107 6598 4122 4124 4126 4129 4133 4134 6601 6602 4136 4139 4142 4145 4146 4151 4157 4160 6609 4165 4166 6612 4167 4172 4176 4178 4182 4188 4190 4192 4195 4204 4217 6616 4222 6618 4225 4254 6621 4266 6626 6627 4268 6628 6629 6632 4273 6637 6638 4278 6639 4288 4982 4984 4987 4990 4992 6648 6652 6653 6657 6662 6664 6668 6674 6676 6677 6682 6684 5005 5006 6708 6709 6710 6714 6715 4310 4311 6719 6720 6722 6723 6729 6730 6732 6739 6740 6744 5007 5020 6745 6748 6750 6756 6758 6761 6762 6765 5027 5036 5043 6778 6779 5056 5064 6780 5069 5075 6783 6785 5080 5086 4322 5088 5090 5091 5092 5101 4337 4342 5103 5106 5112 4346 4352 4355 4357 4360 4361 4368 6790 6791 6795 6797 6798 4370 4371 6799 6800 6801 6804 4375 4378 6805 6806 6809 6812 6813 6814 6815 6826 6827 6831 6835 6837 6838 6839 6840 4403 6843 6844 6847 6853 6857 6858 6860 6862 6866 6867 6868 6869 6870 6871 6873 6874 6875 6876 6877 4410 6879 4413 6881 4417 4421 4422 4430 4431 6882 6884 4434 6885 6886 6887 6888 6890 6893 4435 6894 6895 6897 6899 6901 5114 6917 5115 6921 5117 6946 6953 6956 6969 6975 6979 6983 6988 6994 5119 4437 5127 5133 5136 5137 5140 5141 5153 7040 7049 7051 5155 5163 5170 7071 7083 7084 7089 5176 7091 7093 7113 7121 5182 4442 7126 5183 7127 4450 7144 7145 7150 7151 7163 5184 7165 5187 5188 7168 4454 7173 7191 5197 5199 5202 7203 5207 7206 5208 5209 5210 7212 5213 7272 5222 7274 5223 5225 5240 5247 5256 5271 5277 5281 5286 5287 5301 5302 4467 5307 4468 5309 5310 5318 5344 5351 5367 5379 4469 5386 5415 5419 5421 5422 5427 5432 4484 4488 5440 5441 4491 5457 4493 5460 5465 5471 5486 5493 5495 5507 5517 5524 5541 5560 5586 5594 5602 5609 5624 5633 5640 5651 5652 5660 5661 5669 5675 5677 5680 5683 5695 5696 5709 5713 5715 5717 4503 4506 4507 5740 5741 4513 4516 5745 5746 5755 5756 5758 5759 5760 4519 5761 5773 4528 5778 5780 5781 5783 5785 5786 5790 5792 5795 5797 5798 5799 5802 5804 5805 5811 5816 5820 5824 5826 5830 5833 5834 5837 5841 5843 5844 5845 5847 4530 5848 5856 5857 4533 4537 4538 5861 5863 5865 5870 5871 5872 5873 5875 4541 5883 4542 4549 5886 5887 5888 5889 5891 4554 5892 5893 5897 5898 5900 5902 5904 5905 5907 5910 5914 4570 4573 5915 5918 4574 5919 5923 5924 5928 4576 5951 5957 5959 5966 5972 5975 5977 5978 5979 5981 5982 5984 5985 5986 5991 6002 6014 6017 6019 6022 6023 6024 6028 6029 6030 6031 4579 6053 6054 6057 6060 6078 6079 6080 6083 6085 6090 6096 6097 6098 6101 6103 6105 4583 4602 4604 4609 4612 4622 6119 6121 6123 6129 6143 6145 6150 6152 6155 6158 6167 6171 6182 6187 6200 6205 6220 6232 6236 6252 6254 6255 6257 6258 6269 6275 6278 6281 6283 6297 6346 6359 6364 6370 6371,1,1,1,1,1,1, 2.x: Don t dispose the winner of {Single|Maybe|Completable}.amb() 2.x: Fix window() with start/end selector not disposing/cancelling properly 2.x: Fix concatEager to dispose sources & clean up properly. 2.x: fix Mockito 2.1 changes using deprecated API of its own 1.x: SafeSubscriber not to call RxJavaHooks before delivering the original error. 1.x: rework Single internals to reduce overhead and stack depth 2.x: Observable.compose to use ObservableTransformer 2.x: cleanup and coverage 10/03 2.x: Fix zip not stopping the subscription upon eager error 2.x: cleanup and fixes 10/03-2 3.x: Merge in changes from 2.x since the initial branching 2.x: coverage and cleanup 10/04-1 2.x: flatMap{Completable  Maybe  Single} operators 2.x: add javadoc and unit test to the recently changed XTransformers 2.x: fix flatMapX calling SpscLinkedArrayQueue.offer concurrently Operators: And  Then  When Operators toMap and toMultimap again Operation Join again Operation GroupByUntil Operator GroupJoin v2 Operation Timestamp with Scheduler Operation Sample with Observable v2 Operation LongCount Lock-free subscriptions Operation Timer 3.0 Replay additional overloads Operators: switchCase (Case)  ifThen (If)  doWhile (DoWhile)  WhileDo (W... Operators DelaySubscription  TakeLast w/ time  TakeLastBuffer Operations Aggregate  Average and Sum with selector Missing fixes from the subject rewrite Operation AsObservable Operators Skip  SkipLast  Take with time Buffer with Observable boundary. Delay with subscription and item delaying observables. Window with Observable boundary. MergeMap with Iterable and resultSelector overloads Publish and PublishLast overloads Debounce with selector Timeout with selector overloads Zip with iterable  removed old aggregator version and updated tests 2.: Fix flatMapX over-cancellation in case of an inner error 2.x: Fix javadocs & imports 2.x: Expand the Javadoc of Flowable 2.x: coverage and cleanup 10/11-1 3.x: Sync up with 2.2.10 snapshot 3.x: Widen functional interface throws  replace Callable with Supplier 3.x: Merge as() into to() 3.x: remove getValues() from some subjects/processors 3.x: Various small API changes and removals 2.x: coverage  fixes and cleanup 10/11-2 CompositeSubscription memory reduction CompositeSubscription performance increase Set setDaemon on NewThreadScheduler 3.x: ConnectableFlowable/ConnetableObservabe redesign 2.x: coverage and cleanup 10/12-1 2.x: Fix concatMapDelayError not continuing on fused inner source crash 3.x: Fix concatMapDelayError not continuing on fused inner source crash 3.x: Remove methods from test consumers  make internal versions Fixed ReplaySubject leak OperatorSkipWhile SubjectSubscriptionManager fix. Fixed deadlock in Subjects + OperatorCache. Removed window between the two synchronized blocks. 2.x: coverage and cleanup 10/13-1 OperatorAll OperatorAny CompositeSubscription fix OperatorBuffer OperatorCombineLatest OperatorDefaultIfEmpty OperatorDefer OperatorDematerialize OperatorDistinct OperatorDistinctUntilChanged OperatorFinallyDo OperatorMergeMap OperatorGroupByUntil OperatorGroupJoin OperatorTimerAndSample OperatorJoin OperatorMergeMaxConcurrent Fix ReplaySubject s double termination problem. OperatorMulticastAndReplay OperatorOnErrorResumeNextViaObservable OperatorOnErrorReturn Operator OnExceptionResumeNextViaObservable Operator ParallelMerge OperatorRefCount OperatorSequenceEqual OperatorSkipTimed OperatorSkipUntil Fix for SerializedObserverTest Operator Switch Operator TakeTimed Operator Delay rebase & fixes Scheduler correctness improvements. Removed use of deprecated API from tests & operators  fixed year in head... 2.x: coverage  cleanup fixes 10/14-1 Fixed synchronous ConnectableObservable.connect problem NotificationLite.accept performance improvements Behavior subject time gap fix 2 2.x: cleanup  coverage  fixes 10/14-2 SwingScheduler: allow negative schedule ReplaySubject enhancement with time and/or size bounds 2.x: coverage  fixes  cleanup 10/15-1 2.x: coverage  cleanup  fixes 10/15-2 2.x: test sync from Observable to Flowable 10/16-1 Lock-free  MPSC-queue based  fast-path serializing Observer. CompositeSubscription with atomic field updater SafeSubscriber memory reduction Fixed testConcurrentOnNextFailsValidation Operator Retry with predicate ExecutorScheduler to wrap an Executor ReplaySubject remove replayState CHM and related SubjectObserver changes 1.x: fix subscribe(Action1 [  Action1]) to report isUnsubscribed 2.x: coverage and cleanup 10/17-1 2.x: remove variance from the input source of retryWhen Cleanup: final and utility classes 2.x: coverage  fixes  enhancements  cleanup 10/18-1 Removed unused imports and variables. Added missing headers  removed unnecessary casts Cleanup: added missing annotations  removed unnecesary annotations Fix memory leak in bounded ReplaySubject due to retaining the node index Set removeOnCancelPolicy on the threadpool if supported Scheduler.Worker to be finally unsubscribed to avoid interference Fixed first emission racing with pre and post subscription. Fixed test issuing non-serialized messages to the subject. Fixed wrong bounded ReplaySubject use in test. Operator retry test fix attempt A set of stateless operators that don t need to be instantiated ScheduledExecutorService: call purge periodically on JDK 6 to avoid Subject state information methods & bounded ReplaySubject termination Backpressure tests fix0121 Operator TakeUntil with predicate RxRingBuffer with synchronization Updating queue code from JCTools Obstruction detection in tests. Give more time to certain concurrency tests. Operator: switchIfEmpty Changed the naming of the NewThreadWorker s system parameters Added common Exceptions.throwIfAny to throw a collection of exceptions Changed Observable.empty() into a stateless constant observable. FlatMap overloads with maximum concurrency parameter Cast back Observer to Subscriber if passed to subscribe(Observer) TakeWhile: don t unsubscribe downstream. Operator: WithLatestFrom Optimized isUnsubscribed check Optimized scalar observeOn/subscribeOn ObserveOn throughput enhancements Fix for non-deterministic: testOnBackpressureDropWithAction Small fix for the getValue javadoc in AsyncSubject and BehaviorSubject Backpressure for window(size) testOnBackpressureDropWithAction restored original test count Fixed a non-deterministic test and a few scheduler leaks. Proposal: standardized Subject state-peeking methods. 2.x: coverage  fixes  cleanup  copy to Flowable 10/19-1 Operators toList and toSortedList now support backpressure Fixed schedule race and task retention with ExecutorScheduler. OnBackpressureLatest: Non-blocking version of the toBlocking().latest() operator. Merge and MergeMaxConcurrent unified and rewritten More assertions for TestSubscriber Set of standard producers and updated queue implementations with some Operator cache() now supports backpressure Deprecated onBackpressureBlock Fixed window(time) to work properly with unsubscription  added Fixed multiple calls to onStart. ConnectableObservable autoConnect operator Replaced tabs with spaces for good. Window with Observable: fixed unsubscription and behavior CompositeException extra NPE protection Reduce test failure likelihood of testMultiThreadedWithNPEinMiddle Fix request != 0 checking in the scalar paths of merge() Unit tests and cleanup of JCTools  queues. Test coverage of rx.functions utility methods. Observers package test coverage and fixes. Operator replay() now supports backpressure (again) Fix retry with predicate ignoring backpressure. Improved Scheduler.Worker memory leak detection Scheduler shutdown capability Window operators now support backpressure in the inner observable. Merge can now operate in horizontally unbounded mode. RS dependency  some basic Observable/Observer methods. Some safe queue implementations Refactored exception reporting of most operators. PublishSubject  AsyncSubject and a few helper classes Disposable interface and a bunch of general resource containers. Schedulers (a few) + API  slight modifications to other classes Added a bunch of basic event sources and helper Subscription Basic Subscribers and plugin class Operators map and flatMap ConnectableObservable and autoConnect Operators of take (untimed)  plugin error reporting fix for other The skips and filter operators added to Observable Operator toList and toSortedList Operators publish  replay and cache. Operators all  any  count  elementAt  single All standard schedulers ported and cleaned up. Operators observeOn  subscribeOn and unsubscribeOn Operator concatMap and related convenience methods Lambda-based subscribe and lifecycle tracking methods TestSubscriber implemented Some Repeat + Retry methods  fix to SubscriptionArbiter. Operators interval and intervalRange Operators onBackpressure(Drop|Buffer|Latest) Operator groupBy Operator zip plus Function3..Function9. Strenghtening flatMap against misbehaving sources  TestSubscriber + Operator WithLatestFrom  PublishLift to help with operator fusing Fixes to classes  convenience operators mostly. Operator distinct  timeInterval  common Timed container. Operations doOnX. Operator collect  toMap and toMultimap based on it. collect: javac is unable to select the right overload for some reason ConditionalSubscriber to help fusing filter-like operators into Operator sample with time or with another publisher Operato switchIfEmpty  defaultIfEmpty Operator takeLast time + size  skipLast time Operators first  last  multi-offer for SpscLinkedArrayQueue Operator switchMap  switchOnNext  added missing merge and concat Operator amb  ambWith Operators onErrorReturn  onErrorResumeNext  onExceptionResumeNext Operator retryWhen  repeatWhen  Notification Operator sequenceEqual Operator combineLatest Operator using  some internal refactorings. Operator materialize  dematerialize  minor notification fix. Operators delay  delaySubscription  share. BlockingObservable  next  latest  mostRecent  first  last  single Operator refCount UnicastSubject  onBackpressureBuffer-like behavior for a single Operators buffer: size  time  size + time Operator buffer with boundary and open-close  fixes to the timed Window with count  count + skip. Operator window timespan  timespan + count  timespan + timeskip Operator debounce (time  selector)  throttleWithTimeout (alias) Operator scan  reduce. Fixes to TestSubscriber async behavior. Fixed debounce behavior  added throttleFirst  throttleLast alias Operator timeout  onBackpressureBuffer(onOverflow)  fixes to parameter ReplaySubject RxJavaPlugins extended with handler registration and reset support BehaviorSubject Fixes to ReplaySubject and BehaviorSubject. Operator window with boundary (exact  selector  exact + supplier). Subjects onNext and onError null safety RxJavaPlugins performance enabling fix & lockdown. Operator generate: create an observable that generates values by calling Standard disposables  changes to resource containers to support them. UnicastSubject javadoc  support for onCancelled notification. First unit test and fixes to operators. Fix attempt to the firehose test. Simplest combineLatest tests and fix to groupBy. Simplest concat test from 1.x ErrorHandlingTests and EventStream Simplest tests of groupBy  merge and Notification ConversionTest and DoOnTest ObservableTests and bugfixes. Simpler tests for window reduce  scan  starWith. SubscriberTests port from 1.x Simpler tests of throttleLast  throttleWithTimeout  zip Unit test for Blocking operators. Test some UnicastSubject  cache  NotificationLite  amb More tests and bugfixes to operators. 2.x: unit tests and fixes for fromIterable and range 2.x: tests for refCount and timer  fixes to flatMap  publish and range 2.x: test for operators all  any  asObservable  fixes to all and any 2.x: test for buffer  I m still missing the boundary-supplier version 2.x: added missing buffer overload (with boundary selector) 2.x: classes Single and NbpObservable 2.x: operators cast and concat tests 2.x: operator test distinct  distinctUntilChanged and doOnEach 2.x: operator test elementAt  filter  finally  first 2.x: operator test flatMap  merge  mergeDelayError 2.x: operator test for groupBy  fix to groupBy and type argument swap 2.x: operator test observeOn 2.x: operator test onBackpressure(Buffer|Drop|Latest) and their bugfix 2.x: operator test onError and onException  relevant bugfixes 2.x: operator tests: publish  reduce  repeat + fixes 2.x: operator test for replay 2.x: operator test: retry  retryWhen 2.x: operator test: serialize  single + SerializedSubscriber fix 2.x: operator test: skip variants and bugfix 2.x: operator tests: take family + fixes 2.x: operator tests: timestamp  toMap  toMultiMap  toList  toSortedList 2.x: operator tests unsubscribeOn  withLatestFrom  zip (partial) 2.x: operator test: window variants 2.x: coverage  minor fixes  cleanup 10/19-2 2.x: operator test zip and SafeSubscriberTest 2.x: schedulers test of classic schedulers 2.x: subscribers/observers tests 2.x: disposable unit tests + fix to RefCountDisposable behavior 2.x: scalar flatMap optimization enabled 2.x: perf checks for flatMap and merge 2.x: range perf + added missing header. 2.x: cleanup  fixes  coverage 10/20-1 3.x: Add X.fromSupplier() 3.x: disambiguate startWith+1 to startWithItem & startWithIterable 2.x: perf change wait to spin-loop for short async benchmarks Eager ConcatMap 2.x: Single class more operators + test from 1.x 2.x: non-backpressure NbpObservable all relevant operators + tests. 2.x: perf comparing Observable  NbpObservable  Stream and ParallelStream 2.x: fix SpscLinkedArrayQueue leaves 1 slot null just before growing DoOnEach: report both original exception and callback exception. 3.x: add marbles to X.fromSupplier Better null tolerance in rx.exceptions.*Exception classes. 1.x: Completable class to support valueless event composition + tests 1.x: DelaySubscription with a plain other Observable. 1.x: compensation for significant clock drifts in schedulePeriodically 3.x: Add eager truncation to bounded replay() to avoid item retention 3.x: Make using() resource disposal order consistent with eager-mode 1.x: replay request coordination reduce overhead 1.x: add a source OnSubscribe which works from an array directly 1.x: fix SafeSubscriber documentation regarding unsubscribe 1.x: add shorter RxJavaPlugin class lookup approach. 3.x: JavaDocs: clarify create emitters are per consumer 1.x: fix renamed operator in Single. 1.x: fix Completable.using not disposing the resource if the factory crashes during the subscription phase. 1.x: just() now supports backpressure (+ related fixes/changes) 3.x: Promote Beta/Experimental to Standard 3.x: Add concatMap with Scheduler guaranteeing where the mapper runs 1.x: CombineLatest now supports any number of sources 2.x: full JDK 6 compatible backport + including bugfixes up to today 2.x: coverage  fixes  cleanup 10/20-2 2.x: coverage  fixes  cleanup 10/21-1 3.x: remove no-arg dematerialize()  remove replay(Scheduler) variants 2.x: fix SchedulerLifecycle.testStartIdempotence vs cached threads dying 1.x: fix counted buffer and window backpressure 1.x: fix observeOn resource handling  add delayError capability 2.x: distinctUntilChanged to store the selected key instead of the value 1.x: javadoc for rx.exceptions.Exceptions 1.x: unified onErrorX and onExceptionResumeNext and fixed backpressure 1.x: Fix Completable using JDK 7 suppressed exceptions feature 2.x: fix Flowable.concatMapEager hang due to bad request management 1.x: make Completable.subscribe() report isUnsubscribed consistently 2.x: fix window-timed test leaking an MBE that affects unrelated tests 2.x: cleanup  fixes  coverage 10/24-1 2.x: cleanup & coverage 10/24-2 1.x: Single.using() 1.x: fix SerializedObserverTest.testNotificationDelay 1.x: clarify join/groupJoin no ordering guarantees 1.x: concatMap full rewrite + delayError + performance 1.x: fix ExecutorScheduler and GenericScheduledExecutorService reorder bug 1.x: combineLatestDelayError 1.x: switchOnNextDelayError and switchMapDelayError 2.x: rename and refactor classes to match the design document 2.x: cleanup  fixes and coverage 10/25 1.x: fix GroupBy delaying group completion till all groups were emitted 1.x: make defensive copy of the properties in RxJavaPlugins 1.x: javac 9 compatibility fixes 1.x: AsyncSubject now supports backpressure 1.x: fix switchMap/switchOnNext producer retention and backpressure 1.x: deanonymize Observable inner classes 1.x: fix multiple chained Single.doAfterTerminate not calling actions Have undeliverable errors on subscribe() sent to plugin error handler. 1.x: proposal: onTerminateDetach - detach upstream/downstream for GC 1.x: Add missing license headers 1.x: DoOnUnsubscribe javadoc clarifications 1.x: Single.retryWhen javadoc clarifications 1.x: ReplaySubject now supports backpressure 1.x: Subscriber.NOT_SET Long -> long  saves an unboxing per instance 1.x: TestSubscriber extra info on assertion failures 1.x: promote UnicastSubject to be a standard+experimental Subject 1.x: fix Single.flatMap not composing subscription through 1.x: add Completable.safeSubscribe option + RxJavaPlugins hook support 1.x: javac- and javadoc-related cleanup in components  part 1 2.x: allow subscribeOn to work with blocking create 1.x: javac- and javadoc-related cleanup in components  part 2 1.x: add multi-other withLatestFrom operators 1.x: request rebatch operator 1.x: add terminal clarification to switchMap operators 1.x: document zip() eagerness Add more time to certain tests that failed under heavy CI load 1.x: fix reset() shutting down everything other than the schedulers 1.x: fix Spsc queues reporting not empty but then poll() returns null 1.x: Deprecate TestObserver  enhance TestSubscriber a bit 2.x: fix Observable.repeatWhen & retryWhen not disposing the inner 1.x: make the latest CompositeSubscription test more robust. 1.x: update doOnEach(Observer) javadoc 1.x: expand and explain cache() in more detail 1.x: fix Completable.onErrorComplete(Func1) not relaying function crash 2.x: first step switching to the reduced-allocation architecture 2.x: Observable.repeatWhen fix for onError 1.x: update AssertableSubscriber API and add Javadoc 1.x: Completable.doAfterTerminate to run after onError as well 2.x: add doFinally for handling post-terminal or cancel cleanup 2.x: add doFinally to the rest of the reactive base classes 2.x: add  Flowable.doAfterNext  operator + 3 doX TCKs 2.x: add doAfterNext & doAfterSuccess to the other types 2.x: add fluent requestMore to TestSubscriber 2.x: javadoc: fix wording of some operators  remove @throws implications 1.x: remove ObjectPool  code style cleanups 1.x: distinctUntilChanged with direct value comparator - alternative 1.x: add missing javadoc elements  fix some descriptions 2.x: Update Observable s ops to work with ObservableConsumable 2.x: Use XConsumable in Completable and Single 1.x: fix Completable.concat & merge hanging in async situations 2.x: factor out Completable ops  unify disposed markers 1.x: add Single.fromEmitter 1.x: Single::takeUntil CancellationException message enh. 2.x: add Maybe.flatMapSingleElement returning Maybe 2.x: TestObserver shouldn t clear the upstream disposable on terminated 2.x: Single operators factored out  headers added 2.x: Apply missing RxJavaPlugins.onAssembly on ops 3.x: remove buffer/window with supplier & onExceptionResumeNext 1.x: enable TestScheduler with nanosecond periodic scheduling 2.x: make Flowable operators extend Flowable directly to reduce allocation 2.x: dedicated reduce() op implementations 2.x: fix compilation errors when using Java 8 3.x: fix wording in Single javadocs 3.x: Code verification fixes for javac s generated switchmap classes 3.x: fix switchMaps inconsistency swallowing errors when cancelled 2.x: fix & update Observable.repeatWhen and retryWhen (again) 2.x: fix TestSubscriber/Observer message texts 2.x: fix timer() ISE due to bad resource mgmt 2.x: add Completable.cache() 2.x: add safeguards to generate() 3.x: widen throws on the XOnSubscribe interfaces 2.x: fix publish(Function) not replenishing its queue 2.x: fix timeout with fallback not cancelling the main source 3.x: Add more time for GC in RefCountTest.publishNoLeak 3.x: Fix truncation bugs in replay() and ReplaySubject/Processor 1.x: header and whitespace cleanup 2.x: add sample() overload that can emit the very last buffered item 2.x: fix LambdaObserver calling dispose when terminating 2.x: fix Single.takeUntil() other triggering twice 1.x: add missing marbles  fix image sizes 2.x: add strict() operator for strong RS conformance 2.x: add subjects for Single  Maybe and Completable 2.x: fix withLatestFrom null checks  lifecycle 1.x: fix ReplaySubject anomaly around caughtUp by removing that optimization 2.x: add Flowable.parallel() and parallel operators 2.x: cleanup a few additional SubscriptionHelper locations 1.x: coverage improvements  small adjustments 1.x: scan & reduce give javadoc about unsharing the initialValue 1.x: fix some flaky tests  add more timeout to others 1.x: apply fixes based on PMD suggestions 2.x: convert Observable OnSubscribe to direct implementation 1.x: update map() and filter() to implement OnSubscribe directly 2.x: prepare the operator-fusion enhancement 2.x: make sure the helper returns true if the pre-swap value was null 3.x: Fix mergeWith not cancelling the other source if the main errors Refactor ConditionalSubscriber  add base fuseable Subscribers Switch some Observable ops to direct  map fuseable Remove XResource classes 2.x: cleanup of PMD suggestions Refactor private constructor checker into a utility class 2.x: cleanup and test renames 2.x: ObservableBlockingSubscribe compares with wrong object 2.x: Fix truncation bugs in replay() and ReplaySubject/Processor 2.x: enable fuseable sources  adjust operators 2.x: fix flaky tests 1.x: add RxJavaHooks tests  fix small bugs Observable direct rest Fix the initialization of Completable.complete() 2.x: enable scalar and async fuseable sources and intermediates 2.x: Enable fusion-consumers 2.x: enable op-fusion on GroupBy  doOnX  fix mistakes in map and filter 3.x: Fix refCount not resetting when termination triggers cross-cancel 2.x: fix wrong reference check in FlattenIterable 2.x: measure overhead of toBlocking() first and last 3.x: Fix many operators swallowing undeliverable exceptions 2.x: reduce overhead of blocking first/last/single 1.x: add missing backpressure descriptions and update old ones 1.x: optimize collect  reduce and takeLast(1) 1.x: improve coverage of rx.Observable methods 1.x: add missing RxJavaHooks options  fix bugs 1.x: add missing headers  add SuppressWarnings 2.x: implement concat(Map)Eager(DelayError) and expose concat(Map)DelayError overload 2.x: +fromAsync  distinctUC  skip  take overloads  fix TestSubscriber API 2.x: sync unit tests of Completable  add missing features 2.x: test sync + cleanup 2.x: Test sync  +groupJoin  +join  +onTerminateDetach 3.x: Fix switchMap incorrect sync-fusion & error management 2.x: subscribeOn allow cancelling before the actual subscription happens (just like 1.x) 2.x: Fix switchMap incorrect sync-fusion & error management 1.x: PublishSubject fail-fast when backpressured 1.x: fix SingleTest generics warnings 3.x: Refactor to io.reactivex.rxjava3.** 2.x: add dedicated concat for array of publishers 3.x: Fix blockingIterable not unblocking when force-disposed 2.x: Fix blockingIterable hang when force-disposed 2.x: test sync and operator fixes 3.x: better leak detection via GC/sleep loop 2.x: Fix refCount() not resetting when cross-canceled 3.x: Upgrade Gradle & dependency versions 2.x: test sync and missing operators (8/02) 3.x: Avoid using System.getProperties() due to security restrictions 3.x: Rename zipIterable  remove zip(O(O))  adjust concatMapX arg order 2.x: Functional interfaces now throw 3.x: Cleanup addThrowable   2.x  and null-value error messages 2.x: move Exceptions to public area  + ExceptionHelper 2.x: fix Observable.concatMapEager bad logic for immediate scalars 2.x: fix cross-boundary invalid fusion with observeOn  flatMap & zip 2.x: make Obs.combineLatest consistent with Flowable + doc cornercase 2.x: Update marble diagrams for sample overloads 2.x: A.flatMapB to eagerly check for cancellations before subscribing 3.x: Fix takeLast(time) last events time window calculation. 3.x: Fix size+time bound window not creating windows properly 2.x: Fix takeLast(time) last events time window calculation. 2.x: Fix size+time bound window not creating windows properly 3.x: Multiple empty line detection to ignore whitespace 3.x: Fix groupBy group emission in some cases 3.x: Add missing marble diagams to Single 3.x: Fix window(time) possible interrupts while terminating 3.x: Fix concurrent clear() calls when fused chains are canceled 2.x: Fix concurrent clear() calls when fused chains are canceled 3.x: Fix type inference problem when compiling with newer JDKs 2.x: Fix window(time) possible interrupts while terminating 2.x: ExecutorScheduler.scheduleDirect to report isDisposed on complete 2.x: improve the parallel() mode test coverage  improve its code 3.x: Fix concurrent clear in observeOn while output-fused 3.x: cleanup of some Javadoc parts 2.x: Fix concurrent clear in observeOn while output-fused 3.x: Fix MulticastProcessor not requesting more after limit is reached 2.x: Fix MulticastProcessor not requesting more after limit is reached 2.x: fix SubscriptionArbiter reentrancy/cancel bug 1.x: Schedulers.from() to call RxJavaHooks.onScheduleAction 3.x: Fix parallel() on grouped flowable not replenishing properly 2.x: Fix parallel() on grouped flowable not replenishing properly 2.x: Update javadoc for observeOn to mention its eagerness 3.x: observeOn and Schedulers.from eagerness javadoc updates 3.x: Fix self-see references  some comments 3.x: Add Maybe marble diagrams (14 cases) 3.x: Update Single.zip marble diagrams (4 cases) 3.x: Mockito fix deprecated API use after bump to 3.2.0 3.x: Change Flowable.groupBy to signal MBE instead of possibly hanging 3.x: Add fair mode overload to Schedulers.from(Executor) 1.x: update sample(time) diagram to indicate emission of last 2.x: option to fail for using blockingX on the computation scheduler 3.x: Make DisposableContainer public API 3.x: Change how the cause of CompositeException is generated 3.x: Update observeOn docs with links and +backpressure explanation 3.x: Fix Observable amb  combineLatest & zip ArrayStoreException 3.x: Fix Flowable.window (size  time) cancellation and abandonment 3.x: Fix Observable.window (size & time) cancellation and abandonment 3.x: Fix window (boundary  start/end) cancel and abandonment 3.x: [Java 8] Upgrade to Java 8  add Flowable.fromX operators 2.x: dedicated Single.zip implementation  no dispose on all-success 2.x: reintroduce OnErrorNotImplementedException for 0-1 argument subscribe() 2.x: add parallel hooks to RxJavaPlugins  add missing params validation 3.x: Javadocs package-info made nicer  update README regarding Java 8 3.x: [Java 8] Add blockingStream & flatMapStream to Flowable 2.x: document (internal) SimpleQueue 2.x: fix replay() cancel/dispose NPE 3.x: [Java 8] Add AutoCloseable <-> Disposable conversions  nicen docs 2.x: compatibility fixes (JDK 9 & IntelliJ 2017.1 EAP) 2.x: cancel upstream first  dispose worker last 3.x: [Java 8] Add fromOpt/Stage  mapOptional  toCompletionStage to M/S/C 3.x: Cleanup and prettify Javadocs  widen XOperator throws 2.x: wrap undeliverable errors 1.x: deprecate create()  add alternatives 1.x: add TestSubscriber.assertValuesAndClear 2.x: fix CI load sensitive BlockingNextTests  XFlatMapTest 2.x: fix scan(seed  f) to emit accumulated values asap 1.x: create+subscribeOn avoid same-pool deadlock 1.x: add Single.merge(Obs)  Obs.flatMapSingle & flatMapCompletable 2.x: fix Maybe.concat() subscribe-after-cancel  verify others 2.x: move DisposableObserver to public area  add some javadocs 2.x: sync javadoc of Flowable 2.x: fix doOnSubscribe signalling Undeliv.Exception instead of just onError 2.x: fix window(time  size) not completing windows on timeout 2.x: Flowable as a Publisher to be fully RS compliant 2.x: sync Javadoc of Observable (copy&adjust Flowable s) 2.x: Sync Single javadoc with 1.x 2.x: sync Completable javadoc and related changes 2.x: switch to throwing Action  switchMapDelayError  other cleanup 2.x: factor out inner classes from the base reactive types 2.x: test sync  fix retryWhen/redoWhen/publish(Function) 2.x: add withLatestFrom many  cleanups and other enhancements 3.x: Remove now unnecessary unchecked warning suppressions 3.x: Add NonNull & SafeVarargs annotations + validator 3.x: Add missing annotations  fix many diamonds 3.x: [Java 8] Add Observable operators + cleanup 3.x: [Java 8] Add ParallelFlowable operators + cleanup 2.x: remove Try+Optional  introduce Notification 2.x: move blocking operators into the base classes 3.x: XProcessor.offer to throw NPE immediately 3.x: Add blockingForEach(Consumer  int) overload 3.x: Add missing throwIfFatal calls 3.x: Fix diamonds  spelling  unnecessary code 2.x: added missing ops  cleanup 8/19-1 2.x: implement ops  add javadoc  remove unused components 8/19-2 3.x: [Java 8] Add flattenStreamAsX to Maybe/Single 3.x: Prettify Flowable javadoc + validator 3.x: Improve Javadocs of Completable and some others 3.x: Improve Javadocs of Single 3.x: Fix Junit 4.13 deprecated API use 3.x: Remove fromFuture(...  Scheduler) overloads 3.x: Improve JavaDocs of Maybe 3.x: Fix Flowable.flatMap not canceling the inner sources on outer error 2.x: Fix Flowable.flatMap not canceling the inner sources on outer error 3.x: Improve JavaDocs of Observable and fix similar issues elsewhere 3.x: Cleanup javadoc for parameter validation all around 3.x: Remove a pointless Observable.concatMapIterable overload 3.x: Rename to combineLatestArrayDelayError 3.x: enable javac parameter saving in class files 3.x: Add nullability annotations to type arguments 2.x: add missing ops  cleanup  fusion fixes 3.x: Improve wording of operators 3.x: Remove Maybe.onExceptionResumeNext 3.x: Simplify @return sentences in Flowable JavaDocs 3.x: Fix method argument naming across types 3.x: [Wiki] Improve Operator-Matrix with links and notes 3.x: Verify the use of base interfaces in operator inputs & lambdas 3.x: Add last missing throws tag to JavaDocs 3.x: Add Maybe/Single/Completable blockingSubscribe 3.x: Fix many marbles in Maybe 3.x: Add onErrorComplete to Flowable  Observable and Single 3.x: Add Completable.onErrorResumeWith 3.x: Add Single/Completable retryUntil + marbles 3.x: Add Maybe/Single/Completable switchOnNext & switchOnNextDelayError 3.x: Add Maybe.dematerialize 3.x: Add many fromX operators + marbles 3.x: Add timeInterval & timestamp to M/S 3.x: Add Maybe/Completable toFuture 3.x: Add Single.ofType 3.x: Add doOnLifecycle to Maybe  Single & Completable 2.x: cleanup  enhancements 8/23-1 3.x: Add concatMapX operators (aliases) 2.x: API removals and renames 3.x: Add various concatXDelayError operators 2.x: add assembly tracking  minor fixes and cleanup 2.x: fixes  cleanups  renames 2.x: add subscribeWith to get back the subscriber/observer fluently 2.x Improve coverage  fix bugs 2.x: coverage  fixes  cleanup 8/27-1 3.x: Add Single.mergeArray & mergeArrayDelayError 3.x: Add Completable.sequenceEqual 2.x: cleanup  bugfixes  coverage 8/27-2 3.x: Add missing startWith overloads 3.x: Add Completable.onErrorReturn[Item] 3.x: Add safeSubscribe to Maybe  Single & Completable 3.x: Use more appropriate operators when delegating to Flowable ops 3.x: Fix marble dimensions  add program that checks them 3.x: Reenable XFlatMapTest.maybeSingle  add missing Single operators 2.x: cleanup  behavior clarifications  fixes  coverage 8/28-1 2.x: Fix groupBy not requesting more if a group is cancelled with buffered items 3.x: Fix groupBy not requesting more if a group is cancelled w/ items 3.x: Add remaining Maybe marbles (+50) 3.x: Add concatEagerDelayError across 3.x: Add missing coverage  fix unused/inconsistent ops 2.x: fix Observable.combineLatest to dispose eagerly 3.x: Fix Flowable.switchMap not canceling properly during onNext-cancel races 2.x: benchmark the new strict/interop mode 3.x: Fix replay() not resetting when the connection is disposed 2.x: add ParallelFlowable.sequentialDelayError 3.x: Fix Observable.flatMap with maxConcurrency hangs 3.x: Workaround flakyness of multiThreadedWithNPE* tests 3.x: Fix scheduled tasks  fatal exception behavior 3.x: Allow setting the drift tolerance timeunit via system property 3.x: Fix Flowable.groupBy eviction logic double decrement and hang 3.x: Fix Flowable.groupBy cancellation/cleanup/eviction race hangs 3.x: Disable fusion on the groups of Flowable.groupBy 3.x: Fix Flowable.groupBy eviction-completion-replenishment problems 3.x: Fix recent groupBy tests sometimes failing with MBE 2.x: improve coverage  remove unused code 2.x: Subject/Processor improvements & small cleanup 2.x: update javadoc of flatMap() overloads 2.x: fix flatMap not cancelling the upstream eagerly 2.x: fix repeatWhen and retryWhen signatures 2.x: add TestSubscriber.withTag 2.x: fix timed replay-like components replaying outdated items 1.x: fix timed replay() not terminating when all items timeout 2.x: Java 9 compatibility fixes (March 3) 3.x: Fix map() conditional chain causing NPE 3.x: Fix Observable.window (size  skip  overlap) dispose behavior 3.x: Update marbles of onErrorResume(Next|With) + cleanup 2.x: improve BaseTestConsumer with awaitCount & timeout 2.x: Single.subscribe() to report isDisposed() true on success/error 2.x: fix LambdaObserver not cancelling the upstream 3.x: fromRunnable/fromAction javadoc improvements 3.x: Fix toFlowable(ERROR) not cancelling on MBE 2.x: Fix toFlowable(ERROR) not cancelling upon MBE 3.x: Fix Flowable.concatMap backpressure w/ scalars 2.x: fix private field access  few generics problems 2.x: Fix Flowable.concatMap backpressure w/ scalars Clarify the documentation for scan operators 3.x: Fix source locator code to support GitHub Actions folder layout 3.x: Remove unnecessary cancel/dispose calls from terminating using 2.x: fix replay().refCount() leaking items between connections 1.x: cleanup  javadoc  Completable.fromEmitter 3.x: Improve error messages in the test consumers 2.x: test to disallow anonymous inner classes 3.x: Improve Javadocs of Connectable sources 2.x: fixes  cleanup  coverage 8/31-1 3.x: Update marbles of amb()  ambArray() and ambWith() 3.x: Fix take() mentioning the old limit() operator 3.x: Document Schedulers.from s RejectedExecutionException handling 3.x: onReduceBackpressure internals cleanup 3.x: TestScheduler option to use onSchedule hook 2.x: add offer() method to Publish & Behavior Processors 3.x: Add fusion support to concatMap{Maybe|Single|Completable} 2.x: reflection-based parameter validator & fixes 2.x: fix flatMap emitting the terminal exception indicator on cancel 3.x: Improve Javadocs style of Schedulers 2.x: start reimplementing Maybe with up-to-date javadoc  tests and algo 3.x: Workaround for FutureTask.toString + JDK 11 build 3.x: Add onSubscribe hook to ParallelFlowable operators 2.x: add ParallelTransformer interface  params-validation 2.x: increase timeout on parallel & completable tests 2.x: add resilient versions of parallel map()  filter() & doOnNext() 3.x: Fix Schedulers.from to honor interruptibleWorker across methods 2.x: prevent tasks to self interrupt on the standard schedulers 3.x: Fix wrong reference in Single.flattenStreamAsObservable javadoc 2.x: fix images of firstElement  flattenAsX  flatMapIterable 1.x: add marble diagram to UnicastSubject  fix javadoc 2.x: better documentation on the abstract consumer classes 3.x: CompositeException.printStackTrace to write directly into PrintStream/PrintWriter 2.x: fix window() with time+size emission problems 3.x: Fix copy-paste error in Completable javadoc 2.x: cleanup based on IntelliJ 2017.1 inspections 3.x: Javadoc: Fix wording of *OnSubscribe interfaces 2.x: improve the documentation of Schedulers utility class. 1.x: fix Completable.onErrorResumeNext unsubscribe not propagated 2.x: fix CallbackCompletableObserver calling onError  ResourceX wording 2.x: fix Flowable.toList() onNext/cancel race 2.x: fix flatMapIterable appearing to be empty when fused 2.x: enable link to external JDK  fix Schedulers style 2.x: Single.subscribe(BiConsumer) consistent isDisposed 2.x: BehaviorProcessor & Subject terminate-subscribe race 2.x: cleanup for text and javadoc 04/15 2.x: fix Flowable.flatMapMaybe/Single maxConcurrency not requesting more 2.x: more detailed no-multi-subscribe with std consumers error message 2.x: add Single.unsubscribeOn() 2.x: add more Maybe operators  fix a few javadoc mistakes 2.x: Apply promotions for v2.1 2.x: coverage  bugfixes  9/03-1 2.x: Fix Javadoc of Flowable.toObservable 2.x: improve coverage of some classes (no functional changes) 1.x: apply API promotions for 1.3 2.x: add tryOnError to create/XEmitter API 2.x: update some marbles of Observable 2.x: make sure interval+trampoline can be stopped 2.x: add missing null checks on values returned by user functions 2.x: coverage and fixes 9/03-2 2.x: add subscribeOn overload to avoid same-pool deadlock with create 2.x: fix doOnNext failure not triggering doOnError when fused 2.x: fix periodic scheduling with negative period causing IAE 2.x: attempt to fix a few time-sensitive tests. 2.x: more eager cancellation in flatMapX 2.x: fix buffer(time  maxSize) duplicating buffers on time-size race 2.x: fix/clarify the Observable class  javadoc 2.x: Flowable.reduce() to return Single  macro fusion 2.x: add new methods to Maybe  Observable and Single from 4481 2.x: concat to report isDisposed consistently with termination 2.x: fix periodic scheduler purging config not honored 2.x: reduce blockingX overhead  move internal observers to common pkg 2.x: See if sudo required results in consistent & faster build times 2.x: more Maybe operators  minor cleanups 9/07-1 2.x: fix Javadoc mistakes and some style 2.x: fix wording of toList  fix a/an in subscribeOn 1.x: increase timeout of some tests 2.x: small note on Maybe.defaultIfEmpty regarding toSingle 2.x: fix ReplayProcessor backpressure and NotificationLite emission bug 2.x: make withLatestFrom conditional subscriber  test cold consumption 2.x: fix SpscLAQ nepotism  FlowableRefCountTest.testRefCountAsync flaky 2.x: add missing null check to fused Observable.fromCallable 2.x: add/update Observable marbles (07/30) 2.x: Fix flaky MaybeFromCallableTest.noErrorLoss 2.x: fix Obs.combineLatestDelayError sync initial error not emitting 2.x: fix Single.timeout unnecessary dispose calls 2.x: fix assertValueSequence reversed error message 1.x: Workaround for CHM.keySet bad type with Java 8 compiler 2.x: Fix Observable.concatMapEager queueing of source items 2.x: add onTerminateDetach to Single and Completable Upgrade to Gradle 4.2.1  remove nebula plugin dependency 2.x: additional warnings for fromPublisher() 2.x: update Obs.just(2..10) & switchOnNextDelayError marbles 2.x: inline disposability in Obs.concatMap(Completable) 1.x: fix timeout (timed  selector) unsubscribe bug 2.x: improve Flowable.timeout() 2.x: fix PublishProcessor cancel/emission overflow bug 2.x: Add PublishProcessor JMH perf comparison 2.x: make parallel() a fusion-async-boundary 2.x: More Observable marble fixes (10/18) 2.x: Add TCK test for limit() 2.x: fix Completable.concat to use replace (don t dispose old) 1.x: fix Completable.concat to use replace (don t dispose old) 2.x: Improve Javadocs of flatMapSingle and flatMapMaybe 2.x: BaseTestConsumer values() and errors() thread-safety clarifications 2.x: distinguish between sync and async dispose in ScheduledRunnable 2.x: Javadocs: add period to custom scheduler use sentences 2.x: add system properties to adjust thread priorities of Schedulers 2.x: fix operator RefCount  disable FindBugs (due to Travis OOM) 2.x: add Reactive-Streams TCK infrastructure and couple of tests 2.x: marbles for Observable all  fromPublisher  zipArray 2.x: internal API to get distinct Workers from some Schedulers 2.x: fix switchMap bad cancellation 2.x: fix Single.using  add unit tests and coverage 2.x: add/update Observable marbles 11/28 2.x: improve wording and links in package-infos + remove unused imports 2.x: Add marbles for Observable (12/06) 2.x: improve autoConnect() Javadoc + add its marble 2.x: add a couple of @see to Completable 2.x: marble additions and updates (12/11) 2.x: Subject NPE fixes  add UnicastProcessor TCK 2.x: add more Maybe operators 9/09-1 2.x: fix timed exact buffer calling cancel unnecessarily 2.x: Improve JavaDoc of retryWhen() operators 2.x: add Maybe operators  add annotation and source code checker tests 2.x: Improve BehaviorProcessor JavaDoc 2.x: Improve BehaviorSubject JavaDoc + related clarifications 2.x: Describe merge() error handling. 2.x: Fix JavaDoc wording of onTerminateDetach 2.x: Update Maybe doOn{Success Error Complete} JavaDoc 2.x: add error handling section to merge() operator docs 2.x: improve request accounting overhead in retry/repeat 2.x: Fix flatMap inner fused poll crash not cancelling the upstream 2.x: More marbles 01/08-a 2.x: Observable marble fixes 01/08-b 2.x: Observable.replay(Function  ...) marble fixes 2.x: Add missing {Maybe|Single}.mergeDelayError variants 2.x: Improved XSubject JavaDocs 2.x: More Observable marbles  01/10-a 2.x: Final planned Observable marble additions/fixes 2.x: Fix buffer(open  close) not disposing indicators properly 2.x: Add Subject and Processor marbles 1.x: Plugin lookup workaround for System.properties access restrictions 2.x: Improve the wording of the share() JavaDocs 2.x: Fix O.blockingIterable(int) & add O.blockingLatest marbles 2.x: Reword the just() operator and reference other typical alternatives 2.x: Fix Observable.switchMap main onError not disposing the current inner source 2.x: Fix copy-paste errors in SingleSubject JavaDoc 2.x: Detail distinct() & distinctUntilChanged() in JavaDoc 2.x: Improve JavaDoc of XObserver types. 2.x: Expand the JavaDocs of the Scheduler API 2.x: Explain the properties of the XEmitter interfaces in detail 2.x: Add efficient concatWith(Single|Maybe|Completable) overloads 2.x: Add efficient mergeWith(Single|Maybe|Completable) overloads. 2.x: cleanup 9/12-1  more Maybe operators  more source code checking 2.x: Improve the wording of the Maybe.fromCallable JavaDoc 2.x: Add finite requirement to various collector operators JavaDoc 2.x: Unify race test loop counts and invocations 2.x: more cleanup and fixed checker  Maybe.takeUntil 2.x: last Maybe operators 2.x: add most relevant ~100 operators  Reactive-Streams TCK tests 2.x: Fix Javadoc warnings  links to the JDK types 2.x: Expand the documentation of the Flowable.lift() operator 2.x: Improve the JavaDoc of the other lift() operators 2.x: Add Flowable.switchMapCompletable{DelayError} operator 2.x: Add Flowable.concatMapCompletable{DelayError} operator 2.x: Add Flowable.concatMap{Maybe Single}{DelayError} operators 2.x: Add Flowable.switchMap{Maybe Single}{DelayError} operators 2.x: Add Observable switchMapX and concatMapX operators 2.x: small cleanup and TCK fix 2.x: Improve coverage and fix small mistakes/untaken paths in operators 2.x: cleanup of some javadoc errors and mentions of  Nbp 1.2 preparation cleanup and Experimental/Beta/Deprecated adjustments 2.x: Upgrade the algorithm of Observable.timeout(time|selector) operators 2.x: Fix window(Observable|Callable) upstream handling 2.x: Fix Flowable.window(Publisher|Callable) upstream handling 2.x: Cleanup  coverage and related component fixes 2.x: Improve coverage & related cleanup 03/05 2.x: make internal naming consistent  refactor some classes 9/14-2 2.x: Fix the extra retention problem in ReplaySubject 2.x: Fix Flowable.publish(-|Function) subscriber swap possible data loss 2.x: clarify dematerialize() and terminal items/signals 2.x: Fix excess item retention in the other replay components 2.x: Fix Observable.flatMap scalar maxConcurrency overflow 2.x: Perf measure of Flowable flatMap & flatMapCompletable 2.x: Fix Flowable.singleOrError().toFlowable() not signalling NoSuchElementException 2.x: Coverage improvements  logical fixes and cleanups 03/08 2.x: Cleanup test local variable names 2.x: Improve coverage  fix operator logic 03/12 2.x: Benchmark X-Map-Z operators 2.x: last() to return Single 2.x: make any() and all() return Single  patch up tests 2.x: Optimize ObservableConcatMapCompletable 2.x: Improve the scalar source performance of Observable.(concat|switch)MapX 2.x: collect  toList  toSortedList  toMap  toMultimap to return Single 2.x: Add fusion support to ObservableSwitchMap inner source 2.x: Fix JavaDoc warnings of buffer(Publisher|Callable) 2.x: Update Single.flatMapPublisher marble 2.x: Fix concatMapSingle & concatMapMaybe dispose-cleanup crash 2.x: count  elementAt  ingoreElements  last  single  reduce  reduceWith to return non-Flowable 2.x: blockingX JavaDoc to mention wrapping of checked Exceptions 2.x: Add Single.ignoreElement  deprecate toCompletable 2.x: Fix some grammar mistakes 2.x: Workaround for Objects.requireNonNull inserted by javac 2.x: Fix Observable.concatMapSingle dropping upstream items 2.x: Fix refCount() connect/subscribe/cancel deadlock 2.x: Maybe/Single Javadoc  annotation cleanup 2.x: Fix Flowable.take to route post-cancel errors to RxJavaPlugins.onError 2.x: Add throttleLatest operator 2.x: improve JavaDocs of the subscribeActual methods 2.x: deprecate getValues() in Subjects/Processors 2.x: Add blockingSubscribe JavaDoc clarifications 2.x: Small cleanups in the Scheduler class 2.x: Add refCount with count & disconnect timeout 2.x: Fix switchMap to indicate boundary fusion 2.x: Add MulticastProcessor 2.x: Fix & prevent null checks on primitives 2.x: benchmark (0..1).flatMap  andThen & flattenAs performance 2.x: Fix Single.takeUntil  Maybe.takeUntil dispose behavior 2.x: Add TCK for MulticastProcessor & {0..1}.flatMapPublisher 2.x: More time to BehaviorProcessor & Interval TCK tests 2.x: Dedicated {Single|Maybe}.flatMap{Publisher|Observable} & andThen(Observable|Publisher) implementations 2.x: Improve Observable.takeUntil 2.x: Upgrade to Gradle 4.3.1  add TakeUntilPerf 2.x: Fix MulticastProcessor JavaDoc warnings 2.x: Inline CompositeDisposable JavaDoc 2.x: convert the Observable operators to return Single/Maybe 2.x: Add Maybe marble diagrams 06/21/a 2.x: Expand {X}Processor JavaDocs by syncing with {X}Subject docs 2.x: Use different wording on blockingForEach() JavaDocs 2.x: Fix concatMap{Single|Maybe} null emission on dispose race 2.x: Add Maybe.hide() marble diagram 2.x: Add Completable.takeUntil(Completable) operator 2.x: Improve class Javadoc of Single  Maybe and Completable 2.x: Add Completable marble diagrams (07/17a) 2.x: More Completable marbles (+18)  add Completable.fromMaybe 2.x: Add missing Completable marbles (+17  07/18a) 2.x: Improve Completable.delay operator internals 2.x: Add missing Completable marbles (+19  07/19a) 2.x: Several more Completable marbles (7/19b) 2.x: Final set of missing Completable marbles (+26) 2.x: Fix Completable mergeX JavaDoc missing dt before dd 2.2: Promote all Experimental/Beta API to standard 2.x fix Flowable.create() not reporting null values properly  unify 2.x: benchmark just() and fromCallable() throughput 2.x: add flattenAs{Observable Flowable} to Single and Maybe 2.x: Factor out typical TestObserver/TestSubscriber methods 2.x: improve performance of Observable.flatMapIterable 2.x: enable operator fusion in onBackpressureBuffer 2.x: Test cleanup 2.x: Flowable.onErrorResumeNext improvements 2.x: Improve Completable.onErrorResumeNext internals 2.x: Cleaunp - rename fields to upstream and downstream 2.x: Add concatArrayEagerDelayError operator (expose feature) 2.x: Fix boundary fusion of concatMap and publish operator 2.x: cleanup newline separation  some field namings 2.x: Clarify TestObserver.assertValueSet in docs and via tests 2.x: Fix marble of Maybe.flatMap events to MaybeSource 2.x: Make Flowable.fromCallable consistent with the other fromCallables 2.x: Make observeOn not let worker.dispose() called prematurely 2.x: Add explanation text to Undeliverable & OnErrorNotImplemented exs 2.x: Cleanup multiple empty lines in sources 2.x: Fix refCount termination-reconnect race 2.x: Fix toFuture marbles and descriptions 2.x: Assert instead of print Undeliverable in some tests 2.x JavaDocs: Remove unnecessary  s  from ConnectableObservable 2.x: Cleanup Observable.flatMap drain logic 2.x: Adjust Undeliverable & OnErrorNotImpl message to use full inner exception 2.x: Expand and fix Completable.delaySubscription tests 2.x: Fix flaky sample() backpressure test  improve coverage 2.x: Cleanup code style  commas  spaces  docs 2.x: Add Completable.delaySubscription marble  fix some javadoc 2.x: Fix cancel/dispose upon upstream switch for some operators 2.x: Call the doOn{Dispose|Cancel} handler at most once 2.x: Improve the Observable/Flowable cache() operators 2.x: Add materialize() and dematerialize() 2.x: Add dematerialize(selector)  deprecate old 2.x: Fix Observable.flatMap to sustain concurrency level 2.x: Fix refCount eager disconnect not resetting the connection Javadoc: fix examples using markdown instead of @code 2.x: Fix the error/race in Observable.repeatWhen due to flooding repeat signal 2.x: Fix publish not requesting upon client change 2.x: Add interruptible mode to Schedulers.from 2.x: Fix bounded replay() memory leak due to bad node retention, This PR fixes the  Single.amb    Maybe.amb  and  Completable.amb  operators to not dispose the winner source  causing potential interruptions as a side-effect on the current thread.  The fix is to [delete](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/disposables/CompositeDisposable.html#delete-io.reactivex.disposables.Disposable-) the winner from the composite before disposing the rest to avoid the interruption race.  Unit tests were added to verify this behavior on all  amb  implementations.  Flowable  and  Observable  were already working correctly.  Fixes: #6373 This PR fixes the start-end selector variant of  Observable.window  and  Flowable.window  to properly   - dispose the window-opening sequence upon disposing the main output flow and  - disposing the main upstream upon disposing the main output flow provided there are no windows open.  Fixes: #6397 This PR fixes the  concatMapEager  operator (which drives the static variants as well) to properly dispose and clean up the state of the operator upon cancelling/disposing the sequence.  -  Flowable.concatMapEager  did not cancel the current active inner consumer  only the ones coming after -  Observable.concatMapEager  did not dispose the main source of the inner observables.  Both variants have received the same two unit tests to verify their behavior.  Fixes: #6404 anyListOf()  is deprecated in Mockito 2.1.0-RC.2 and the GitHub diff can t show such uses.  (In addition  there was a missing  serialVersionUID  in another PR.) Before the introduction of  RxJavaHooks   the  SafeSubscriber._onError  called the original error handler with the exception it received which was by default an empty handler. The default  RxJavaHooks.onError  behavior  however is to signal errors to the uncaught exception handler of the caller thread which leads to unnecessary logging or app crashes even though the error itself is to be handled properly.  This PR restores the  SafeSubscriber._onError  to skip the  RxJavaHooks  and call the original handler directy so old tracking code should still get all safe error while newer hooking doesn t get called.  Related: #4332. This PR makes the  Single.OnSubscribe  as the primary means to execute the subscribe action in  Single  and former couple of reused  Observable  operators are now recreated with  Single.OnSubscribe .  Because  Single  is now marked final  we can t remove the former  Observable.Operator  and  Observable.OnSubscribe  entry points (but may be deprecated in a separate PR). This changes the  Observable.compose  type to  ObservableTransformer  to reduce the type-argument/inference problem. The other base types have been previously updated to their respective transfomer types. - remove unused methods and classes - make sure  Maybe.toFlowable  and  Maybe.toObservable  allows macro-fusion back to the original type - improve coverage of various components The  Observable.zip  did not stop subscribing to the next sources if the previous one failed with an  onError .  Flowable.zip  works as intended.  Fixes #6487 - More coverage - fix some composite exception ordering - fix a few bugs ### Version 2.2.9 #### Bugfixes - #6488: Fix zip not stopping the subscription upon eager error. #### Documentation changes - #6453: Fixed wrong type referenced in Maybe and Single JavaDocs. - #6458: Update the Javadoc of the retry operator. #### Other - #6452: Remove dependency of Schedulers from ObservableRefCount. - #6461: Change error message in ObservableFromArray. - #6469: Remove redundant methods from sample(Observable). - #6470: Remove unused import from Flowable.java. - #6485: Remove unused else from the Observable.  ### Version 2.2.8 - March 26  2019 (Maven) #### Bugfixes - #6442: Add missing undeliverable error handling logic for Completable.fromRunnable & fromAction operators. #### Documentation changes - #6432: Improve the docs of CompositeDisposable. - #6434: Improve subjects and processors package doc. - #6436: Improve Creating-Observables wiki doc. #### Other - #6433: Make error messages of parameter checks consistent. - Improve coverage - remove unused  unnecessary or impossible code paths - fix order of inner exceptions in the reported  CompositeException  in various operators -  Maybe.ignoreElement()  now returns  Completable This PR adds  Observable.flatMapCompletable(Function<T  CompletableSource>)  and  Flowable.flatMapCompletable(Function<T  CompletableSource>)   both resulting in  Completable  (+ support for fusing back to the original type).  **Edit**  Added  flatMapMaybe  and  flatMapSingle  variants to both  Flowable  and  Observable . This PR adds the javadoc and crash-testing for each XTransformer interface changed by #4672. I forgot to synchronize the offer part of the new flatMapX operators (since of course  Spsc is for single producer only but here there could be concurrent non fast-path queueing of values).   (There is an MpscLinkedArrayQueue in JCTools but I m not confident in it and don t want to use MpscLinkedQueue due to the node allocation.) Issue #23  Issue #88  Issue #100  Can be extended to Plan4..Plan9 and Pattern4..Pattern9 if Action4..Action9 is available. Not sure about the ActionN version. Issue #96 and Issue #97  toMap: 3 overloads toMultimap: 4 overloads Added groovy test to verify overloading Issue #56 Issue #52  Rebased. Issue #53  Rebased.  Still: @headinthebox While writing the test for the operator  I ve noticed that when both duration selectors are never()  Rx.NET never calls onCompleted on the group subjects  even though the left and right sources onComplete(). I haven t seen Rx.NET test for this scenario. This comes into play when I want to emulate join() with groupJoin(): the outer merge never onCompletes(). If I understand the behavior corretly  when both left and right sources get depleted  there is no way a new group or new group value would arrive  and all the open groups and the main observer can be onCompleted(). This is somewhat similar to join() and groupByUntil() behavior. Issue #93 Issue #74 - Sample will terminate if either the source or the sampler terminates or throws an error. - The sampler now emits values only in its onNext() method. Therefore  if the sampler completes and there is a sampled value available ( valueTaken == false )  it won t emit the value before terminating. Issue #60  Straightforward version of the regular count().   (However  I would have implemented it differently so the constant boxing-unboxing could be avoided.) - Uniform naming of inner components: Issue #592 - Lock-free approach to avoid deadlocks: Issue #577 - SerialSubscription.isUnsubscribe added: Issue #590  Remarks: - IMO  an unsubscribed Single/Serial/Multiple subscription return Subscriptions.empty() instead of null. So unless the user put a null in there he/she shouldn t worry about null. - There was a concurrency bug in @jloisel  s reimplementation of CompositeSubscription. It allowed multiple threads to enter the mutation part if the current state was already MUTATE. I ve added the necessary checks to allow only NORMAL -> MUTATE transitions. Rebased. Issue #71 - Added several overloads of the  replay  operator:    - limited buffer  limited time window  buffer+time     - scheduler overloads     - versions which perform a projection before the replay - Added missing  multicast  overload ...hile)  Issue #634  No MSDN references available. Issue #634 Issue #653  Remarks: - I know we can combine ops to get one of the new aggregate variant  but I think it might be worth having a direct version which avoids nesting several layers of Observables  Observers and Subscriptions. - The  averageInteger  and  sumInteger  (and the other types) are handy if we want to use chained operation invocations (with less overhead):      java Observable.from( a    bb    ccc ).sumInteger(s -> s.length())     .toBlockingObservable().single()       instead of      java Observable.sumIntegers(Observable.from( a    bb    ccc ).map(s -> s.length()))     .toBlockingObservable().single() Two small changes: - Prevent overwriting the terminal notification in  BehaviorSubject  so new subscribers to a terminated subject can see the error/completion. - Call  Thread.currentThread().interrupt()  if the  terminationLatch.await()  throws. Split from PR #641 Rebased version  without the drain scheduler variant. - Fixes issue mentioned in #666 as well. Mentined in Issue #653. - 1 overload where the user can specify the capacity of the internal buffer. Listed in #653  Note: onError and onCompleted events of the source are immediately propagated and will prevent emitting any pending values. Listed in issue #653. Listed in #653. Listed in #653  These operators use the existing multicast and subject infrastructure so I omitted any direct tests. Listed in #653 Listed in #653. Listed in #653. A non-delayed error set the cancellation flag and thus any subsequent drain would just quit instead of delivering the error.  (And while I m at it  I ll try to figure out a way to not get killed by OOMKiller).  Reported in #4684. - Fix some errors in the Javadoc links. - Remove unused imports. - Add the ParallelFlowable page to the javadoc cleanup routine. - Add links to Reactive Streams - Fix hyphenation - Turn some  @code  into  @link s. - Add a short protocol description - Add basic example usage - Add example to use  create  for custom sources - Mention the synchronous/sequential nature and link in some operators. This PR enhances the coverage of  Maybe  operators (run out of time for this batch  5 remaining) and fixes an NPE bug in  Maybe.doOnEvent  due to not saving the  Disposable . Some inner receivers no longer implement  Disposable  as  isDisposed  is unreachable and not really necessary.  In addition  Maybe.toCompletable  was removed in favor of  Maybe.ignoreElement() . The Changes.md always comes up conflicting. I ll leave it as it is for now. This PR widens the  throws Exception  into  throws Throwable  in the functional interfaces and adjusts  catch (Exception  to  catch(Throwable  where needed.  The major change is the replacement of  java.util.concurrent.Callable  in almost all API with  io.reactivex.functions.Supplier  which is defined with  throws Throwable . Since subinterfaces can t widen the throws clause  only narrow it   Supplier  can t extend  Callable .   fromCallable  remained in all base classes and a separate PR will introduce  fromSupplier .  The single-valued fusion now works with  Supplier  and  ScalarSupplier  types instead of  Callable  and  ScalarCallable  (removed). In 2.x  the  to()  operator used the generic  Function  to allow assembly-time conversion of flows into arbitrary types. The drawback of this approach was that each base reactive type had the same  Function  interface in their method signature  thus it was impossible to implement multiple converters for different reactive types within the same class. To work around this issue  the  as  operator and  XConverter  interfaces have been introduced in 2.x  which interfaces are distinct and can be implemented on the same class. Changing the signature of  to  in 2.x was not possible due to the pledged binary compatibility of the library.  From 3.x  the  as()  methods have been removed and the  to()  methods now each work with their respective  XConverer  interfaces:  -  Flowable.to(Function<Flowable<T>  R>)  is now  Flowable.to(FlowableConverter<T  R>)  -  Observable.to(Function<Observable<T>  R>)  is now  Observable.to(ObservableConverter<T  R>)  -  Maybe.to(Function<Flowable<T>  R>)  is now  Maybe.to(MaybeConverter<T  R>)  -  Single.to(Function<Flowable<T>  R>)  is now  Maybe.to(SingleConverter<T  R>)  -  Completable.to(Function<Completable  R>)  is now  Completable.to(CompletableConverter<R>)  -  ParallelFlowable.to(Function<ParallelFlowable<T>  R)  is now  ParallelFlowable.to(ParallelFlowableConverter<T  R>)   If one was using these methods with a lambda expression  only a recompilation is needed:     java // before source.to(flowable -> flowable.blockingFirst())   // after source.to(flowable -> flowable.blockingFirst())       If one was implementing a Function interface (typically anonymously)  the interface type  type arguments and the  throws  clause have to be adjusted     java // before source.to(new Function<Flowable<Integer>  Integer>() {     @Override     public Integer apply(Flowable<Integer> t) throws Exception {         return t.blockingFirst()      } })   // after source.to(new FlowableConverter<Integer  Integer>() {     @Override     public Integer apply(Flowable<Integer> t) {         return t.blockingFirst()      } })       Resolves: #5654 The  getValue()  and  getValues(T[])  methods were a remnant from a time where  Subject  and  FlowableProcessor  was unifying all state peeking methods for every kind of subject/processor. These have been marked as  @Deprecated  in 2.x and are now removed from 3.x. They can be trivially replaced with  getValue()  if necessary  for example:     java Object value = subject.getValue()  if (value == null) {    return new Object[1]  } return new Object[] { value }       Related: #5622 -  Maybe.defaultIfEmpty()  returns  Single . - Removal of  Maybe.toSingle(T) . - Removal of  Flowable.subscribe(4 args)  - Removal of  Observable.subscribe(4 args)  - Removal of  Single.toCompletable()  - Removal of  Completable.blockingGet()  - Removal of  Flowable.subscribe(/* 4 args */)  - Removal of  Observable.subscribe(/* 4 args */) - cover remaining  Maybe  operators - cover  Single  operators - cover some of the  Completable  operators - fix missing  onSubscribe  calls - compact a few operator implementations - fix the order of inner Throwables on certain  CompositeException  emissions Since CompositeSubscription is now used everywhere with Subscriber  I looked at the code again and tried to reduce memory consumption. I ve added CLEAR_STATE_UNSUBSCRIBED singleton to transition into when unsubscribed. Note that the previous version kept the subscription array after the unsubscription  keeping references to other subscriptions alive (although unsubscribed)  I m not certain why unsubscription didn t simply discard the array before.  I ve played with changing the  add  and  remove  methods (not included in this PR) to do more direct array manipulation with about 10-40% speed increase for tests like add directly followed by remove. The speed increase comes from: - using arraycopy to avoid dynamic array creation in copyOf  - handling case where CS contains a single item to be removed and transitions into CLEAR_STATE instead of creating a new empty state.  Similar memory reduction could be implemented in MAS and SAS. - Optimized the case when the composite holds only a single element. - Replaced Arrays.copyOf with regular arraycopy to avoid the cost of reflective array creation - Included perf test where I got 32% increase on my i7 4770K First noticed by @zsxwing. This PR changes the connectable API to have a specific  reset  method to reset a terminated connectable source as part of the official API.  In 2.x  when  publish()  terminated  it reset itself to a fresh state which could lead to late consumers not receiving events as there might be no one to call  connect()  again (see #6501). However   replay()  did not reset itself  thus late consumers got the cached events  however  a reconnect started the sequence and new consumers may have missed items.  In 3.x  this two corner cases have been fixed by the introduction of  reset() . Both  publish  and  replay  now remain in their terminated state until  reset  is called. If the connection is disposed  it will automatically reset their state just like before. The state transitions are as follows:  1. **fresh** ->  connect()  -> **running** ->  onComplete() / onError()  -> **terminated** ->  reset()  -> **fresh** 2. **fresh** ->  connect()  -> **running** ->  dispose()  -> **fresh** 3. **fresh** ->  connect()  -> **running** ->  onComplete() / onError()  -> **terminated** ->  dispose()  -> **fresh** 4. **fresh** ->  connect()  -> **running** ->  onComplete() / onError()  -> **terminated** ->  connect()  -> **running**  This does resolve the race condition with  publish().refCount()  described in #6501.  In addition  there are some changes to  Flowable.publish()  s behavior:  It no longer keeps consuming the upstream if there are no subscribers. This implies if the source terminates while there are unconsumed items in the internal buffer  those will be available for observation. *I have no strong preference on this property and in comparison   Observable.publish  drops items because there is no backpressure buffer in its implementation.*  Upstream errors are not reported to the  RxJavaPlugins.onError  handler when if there are no subscribers but have to be observed via a subscriber. *Because terminal events are available until  reset  now  we can t know really if there is going to be a subscriber or not. However  it might be possible to detect the no-consumer case upon an error and still report it when  reset  or  dispose  is called.*  Resolves #5628 Resolves #5899 - Add coverage to remaining  Completable  operators - Fix inner Throwable order for  CompletablePeek  - Compact/rewrite a few operators The  Callable  fused path didn t consider the error-delay settings and cut the sequence short.  Fixes: #6520 The  Supplier  fused path didn t consider the error-delay settings and cut the sequence short.  Fixes: #6520 Remove methods from the standard test consumers based on feedback in [6153 comment](https://github.com/ReactiveX/RxJava/issues/6153#issuecomment-463184785).  Some test support has been moved into the  io.reactivex.testsupport  package in the form of  TestObserverEx  and  TestSubscriberEx .  Resolves: #6153 Fix for issue #939. Reimplemented OperatorSkipWhile (the OperationSkipWhile has a state-sharing bug with  skipping  and  index ).  +1 test for many subscribers. Fix for #961  If an already unsubscribed Subscriber is added  the subscription function ends up in an infinite loop as the inner unsubscription logic changes the state to another object before the outer state machine continues. - The outer state machine loop now exits if unsubscription happened and doesn t attempt to modify the state. - The removeObserver method is changed so that if the subscription to be removed is not in the array  it returns this instead of an unnecessary copy. In addition  copyOf calls have been replaced by arraycopy to avoid reflective array creation. Fix for Issue #971. - I had to rewrite OperatorCache to allow testing for deadlocks in all Subject types. - The terminationLatch was unnecessarily waiting for existing subscribers to deliver their termination events  which caused deadlock with repeat(). - Treating subjects as internal implementations was not necessary to fix the problem. In the original version  there was a window between finding a null queue and setting emitting false due to being in different synchronized block. If another thread came in this window  it created a new queue with its event which was not emitted until another onXXX method was called  causing unnecessary event delivery delay.  While running the tests  the  SerializedObserverTest.testNotificationDelay  failed from time to time due to thread timing. I haven t fixed this test. Improve coverage of  Subject s and  FlowableProcessor s  remove impossible paths  cleanup code. Reimplemented  All .  Issue #1060 Reimplemented  Any   aka  IsEmpty  and  Exists .  Issue #1060 A bug in the remove() method caused ArrayIndexOutOfBoundsException if the composite is not empty and trying to remove a subscription that is not in the composite at all. Operator Buffer  split into 4 variants.  Issue #1060.  There are some important behavioral changes compared to the original versions: - When an onError event appears from anywhere  the currently accumulated chunk(s) are _NOT_ emitted before the error is propagated. This conforms with Rx Design Guideline 6.6. - The Observable returned by the Func0 inside the  buffer(Func0<Observable<B>>)  now is used as long as possible and whenever it fires an event  a new buffer chunk is started. The Func0 is called only once per subscriber. The original called it and subscribed to it all the time  causing all-increasing resubscriptions. Operator CombineLatest  Issue #1060  Remarks: - Added an overload to Observable which accepts any number of sources. Not sure why it wasn t exposed before? Perhaps removed? - Relying on just the SO s onNext is not enough as leaving the synchronized block allows reordering of onNext calls. Therefore  the combinator uses the trick from SerializedObserver to make sure the combination order is consistent with whe winning of the synchronization  race . Operator DefaultIfEmpty  Issue #1060 Operator Defer  Issue #1060 Operator Dematerialize  Issue #1060  Two notes: - Since the dematerialize() is an instance method  there is no correct type parametrization for the operator. Therefore  I just used a raw version in the call. - The original dematerialize could send out two onCompleted or an onError followed by an onCompleted because the materialize() always adds an onCompleted after the raw events. This affected operators due to unsafeSubscribe. This new version ensures this doesn t happen. Operator Distinct  Issue #1060  I didn t port the variant with the custom key comparator because it has been decided to rely on  Object.equals  and there were not exposed anyway. Operator DistinctUntilChanged  Issue #1060  Again  I haven t ported the custom comparator version. Operator FinallyDo  Issue #1060 Operator MergeMap  namely the paired and the one which turns all event kinds into Observables to merge.  Issue #1060 Operator GroupByUntil  For Issue #1060  While rewriting  I ve noticed a common pitfall with the observation of the duration: many other operators react to onNext or onCompleted  but one should only  expire  once. I ll review my recent operators and post a separate PR if any. Operator GroupJoin  for Issue #1060  Maybe this could be moved to the new joins. Operator Timer and Sample  Because there was a dependency in Sample towards the now removed Interval  I had to reimplement Sample in this PR as well.  Note that the new  OperatorSampleWithTime  schedules its first sample call before any upstream code is executed. Given the TestScheduler  a sample with 1sec and a timer with 1sec as well won t sample any value. The reason is that in the internal queue of TestScheduler  the sampler s action to take the sample is followed by the action to emit the timer s value. Operator Join  Issue #1060  Remark: now that the client.onNext is called outside the synchronization block  joint results may appear in arbitrary order in case both left and right observables emit values concurrently. I suppose the strict ordering is not really expected here  but someone who uses this operator can tell (@duncani perhaps?) . Operator MergeMaxConcurrent  Issue #1060 Fix for issue #1105 Operator Multicast and Replay  because Replay is effectively a multicasted subject.  Issue #1060 Operator OnErrorResumeNextViaObservable  Issue #1060 Operator OnErrorReturn  Issue #1060 Operator OnExceptionResumeNextViaObservable  Issue #1060 Operator ParallelMerge  just renamed  Issue #1060 Operator RefCount #1060 Operator SequenceEqual #1060  Lightened the operator  but note that NotificationLite escaping an operator may cause undesired effects in other operators relying on NotificationLite as well. Operator SkipTimed #1060  There was an unexpected dependency in  OperationTakeTimedTest  and is surely to cause conflict when  TakeTimed  is rewritten. Once all operators have been merged  I suggest we create a primary  TestException  and rewrite tests to use it instead of all those custom exception classes everywhere. Operator SkipUntil #1060 Fixed the SerializedObserverTest s problematic assertions: -  testMultiThreadedWithNPEinMiddle  might schedule all non-null values before the exception might reach the serialized observer. In addition  waiting after the serialization doesn t help because the cheap value emissions get queued up before that  again  possibly before the exception. The new code adds some delays to the non-null elements allowing the exception to get into the queue. I ve looped it 10.000 times without failure  but there is still a non-zero chance the  new NullPointerException()  thread is significantly delayed and ends up as the last event. -  testNotificationDelay  might fail due to thread scheduling of the two  OnNextThread  delayed too much in respect to each other before the main thread allows the pass-through. The fix is to let bot instances  Thread reach the run method and then let the main thread pass through them. Again  a loop of 10.000 succeeded locally. - Both tests are run 10 times to be more sure. Operator Switch  Issue #1060 Operator Take with time  Issue #1060 Operator Delay  Issue #1060 Second round on the scheduler correctness issue.  Sure it looks more heavy as  ScheduledAction  now has its own inner  CompositeSubscription  and a shared reference to the parent  innerSubscription .  I ve tried to benchmark it with  SchedulerPerformanceTests  but that test is flawed: - Multiple threads pound on the same long sum value  so naturally additions get lost. - The LongObserver gets unsubscribed after the first loop so  from  will not actually call  onNext  but  isUnsubscribed  a lot. - Does not wait for the computations to finish and basically measures how fast 5M tasks can be added to the NewThreadScheduler s innerSubscription.  The flawed test gives ~ 11M ops/sec on my machine. If I fix the test and run against the master  5M takes extremely long to finish due to the inherent slowness of add/remove in CompositeSubscription if large. On my 4 core hyperthread enabled machine  I get 50k-150k ops/second for baseline with a 100k loop.  The proposed changes run with the flawed test gives ~10.8M ops/sec. With the test fixed and with the proposed changes  I get ~1.2M ops/sec. ...ers  added and removed suppressions  fixed line endings  replaced tabs with spaces  I haven t deleted  OnSubscribeFunc  because I was not sure when the general cleanup of deprecated stuff will happen  I just made sure Java tests don t use it anymore. - improve coverage of  Observable  operators - remove impossible or unused code paths - fix  Observable.flatMap  s dispose behavior and error accumulation ConnectableObservable.connect returns a Subscription and thus cannot be unsubscribed synchronously  similar how take didn t work before the Subscriber changes. This PR modifies the  ConnectableObservable  and its current implementation  OperatorMulticast  to extract the connection Subscription token before it is connected to the source. Cancelling this extracted token makes sure the synchronous connection is unsubscribed.  (The Rx.NET version of the test case seemingly doesn t exhibit the problem. I suspect it is the interplay of  IDisposable s.) This is a proposal for speeding up the  accept()  method (i.e.  reducing its latency).  Benchmark comparison:  direct onNext: 488 MOps/s master accept: 378 MOps/s this accept: 477 MOps/s  (i7 4770K  JDK 1.8u5 x64) Based on discussions in #1181  I ve unified the behavior among the Subjects.  BehaviorSubject doesn t seem to exhibit issue #658 and #1184.  A second pair of eyes would be great to confirm the correctness and check if the removal of the CountDownLatch was the correct approach. - more  Observable  operator coverage - enable fusion with  filter  and  fromCallable  - change order of size parameter in timed  buffer  and  window  operators - fix minor mistakes in operators Fix for issue #1193   The new  schedulePeriodic  may calculate negative delay times if the next task was already due. This change will allow negative timing on the swing scheduler indicating an immediate schedule. Reapplied the enhancements to bring size and/or time bound  ReplaySubject  capabilities while exposing a single subject class (i.e.  no separate BoundedReplaySubject or CustomReplaySubject). It now uses the renewed  SubjectSubscriptionManager .  In addition  I ve moved a confusing behavior from SubjectObserver into AsyncSubject where it belongs. - improve coverage of  Observable  operators - remove unnecessary code paths - fix  publish(Function)  latecommer behavior - remove  bufferSize  overloads of  publish  as there is no need to buffer anything for an  Observable  - simplify  Observable.publish - more  Observable  coverage - make  Observable.sequenceEqual  return  Single<Boolean>  - reimplement  Observable.distinct()  - fix  Observable.combineLatest  error management - remove or compact unused code paths - fix  Observable.flatMap  maxConcurrency behavior with scalars  use of unbounded queue - fix  Observable.timeInterval  not saving the  Disposable - copy the recent unit tests from  Observable  to  Flowable  - fix the same bugs - perform the same cleanups - compact the same operators - factor out fusion method and constants to  QueueFuseable  - have  Flowable.toList(Callable)  return  Single I ve rewritten the  SerializedObserver  to improve performance. It is now lock-free  uses a multiple-producer-single-consumer queue based on Netty s implementation and employs a fast-path logic for single-threaded write-through.  Benchmarked by measuring how fast 500k integers can get through it  if running 1-8 producers at the same time. For a single threaded case  master gives about 18 MOps/s  this implementation gives ~36 MOps/s (would be ~16 MOps/s on the slow path). For producers > 2  master gives ~5.5 MOps/s and this gives ~11.5 MOps/s. For 2 producers  aka 1 producer - 1 consumer  master gives ~4.5 MOps and this gives ~8.5 MOps/s.  The two new class   PaddedAtomicInteger  and  MpscPaddedQueue  will come in handy with other lock-free structures such as Schedulers  etc. We may consider adding back the  rx.util  or some other sub-package to store these helper classes: they don t need to be part of the public API but can be left  public  to enable cross-package access internally.  Things I learned during the implementation: - It is worth padding the wip counter to fit a cache line so the constant cache thrashing won t affect the parent class  other fields  most likely. - Using FieldUpdaters saves space but  sun.misc.Unsafe  can add 8-10% more throughput. To avoid platform issues  I stayed with the FieldUpdaters. - Using  getAndIncrement  and  decrementAndGet  are intrinsified in Java 8 and are compiled to a single x86 instruction  which generally outperforms any CAS loop. Same is true for the  getAndSet . - Padding out the  tail  in the  MpscPaddedQueue  again helps separate producers trashing on the tail and a consumer reading the head. Without it  the throughput would decrease by about ~1.5 MOps/s - By adding the fast-path logic  the single-threaded throughput increases by a factor of 2 since it avoids an unnecessary enqueue and dequeue and all associated volatile writes. However  if taking the fast-path fails  it incurs extra cost on the slow path for everyone else because of the +1 failed CAS at the start. To fix this case  I ve introduced a flag that enables and disables fast-path. To disable the fast path  the active fast path checks if it was able to change wip to zero. If not  it means there was concurrent access and continues on the emission loop path  but disables the fast-path then on. It is basically a detector for concurrent use. Since such concurrent use may be transient  the loop counts how many elements it had to emit  an if it was only 1 or 2  it reenables the fast-path. This limit is the result of trying several values with the benchmark above. - The fast-path logic has its weak spot in 2 producer case compared to a plain MPSC queue running in SPSC mode  the latter gives about ~11 MOps/s which is better than this implementation s ~8.5 MOps/s. In contrast  the single-treaded use for the plain MPSC is only ~16 MOps/s. Both implementations perform the same if producers > 2. Therefore  I decided it is more worth having an implementation that is weak for 2 producers but otherwise is as good or outperforms the alternatives. Note that if one knows the number of producers up front  one can create a more specialized implementation  but this is not the case with RxJava operators. This may affect  merge  and co which serialize multiple sources. Note however  that if the source speed isn t that high as in the benchmark  this implementation still provide less latency than the alternatives because the fast-path would be most likely open if the source emission is interleaved. This PR is aimed at #1204 to reduce unnecessary memory overhead in frequently used classes. This change in  CompositeSubscription  saves about 24 bytes per instance.  In addition  the field updaters may be faster by about 8-15% for small adds and removals. I ve changed the implementation of unsubscribe to use getAndSet which leverages platform intrinsics and is usually compiled to a single instruction: this makes unsubscribing a tiny bit faster and thus reducing latency in benchmarks that only pass on single element around. For #1204. This saves 24 bytes per instance. The two instructions need to be swapped to make sure woken-up awaiters see the error reliably. Operator Retry with predicate + 1 overload for Issue #1214.  The Func1 version is simply named  retry   the Func2 version is named  retryIf  due to lack of ideas and because to avoid overload resolution issues. I also had to open up the OperatorRetryTest classes a bit. For issue #1219 (and #1206)  This implementation should conform with the Scheduler contract except it is not possible to avoid thread-hopping (don t worry  the tasks execute serially  but maybe not on the same physical thread).  Few open improvement possibilities: - Usage of  MpscLinkedQueue  once available. - A better performing subscription container for this kind of queue-drain task tracking instead of  CompositeSubscription . - Ability to remove a  Subscription  from a  CompositeSubscription  without it calling unsubscribe on the removed Subscription  á la  MultipleAssignmentSubscription.set() . For issue #1204  This change should help avoid CHM garbage (although boxed Integers will still fly around). In addition  I moved the NotificationLite around to make room for the index. I ve also removed the callback onAdd in PublishSubject because it was unnecessary. The lambda version didn t report  isUnsubscribed()  as before because of the removal of the  SafeSubscriber  wrapping. This PR makes sure it reports consistently again.  Repored in: #4715  Note that there is no  unsafeSubscribe(SingleSubscriber)  so a regular  subscribe(SingleSubscriber)  by default won t report  isUnsubscribed() == true  unless the implementation of  onSuccess  and  onError  - controlled by the user - doesn t call  unsubscribe  on itself. A small set of coverage and cleanup of  Observable  operators. The variance of the  retryWhen  operator doesn t infere properly with java 8. This PR removes the  ? extends  from the function s input  Observable .  Reported in: https://twitter.com/HansWurst315/status/788108336285753344 - Added  final  to utility classes. - Added private constructor to utility classes. - improve coverage of more  Observable  operators - reduce allocation of  ConnectableObservable.connect(Consumer)  and  ConnectableFlowable.connect(Consumer)  - enable fusion on  Observable.observeOn  - fix fusion of  Observable.just  - remove  flatMapIterable(Function  int)  overload and have  flatMapIterable(Function)  use the flatten operator. - fix  Observable.replay()  potential emission before  onSubscribe  call nan nan plus fixed a few unnecessary casts I missed last time. indefinitely once the Subscriber caught up.  For issue #1865. This should solve the task retention problem of unused timeout tasks mentioned in #1919.  I know Java 7+ ScheduledThreadPoolExecutor has the  setRemoveOnCancelPolicy  and I remember seeing it in Android although I can t tell from which API version.  In Java 6  this can t be solved without rewriting the entire scheduler or using a backported executor. ... and leaks. There was a subtle race between the subscription and emission which delayed the delivery of the first emission if it happened between the pre- and post-subscription of a subscriber. The fix is the same logic used by the BehaviorSubject to avoid the same problem. Should resolve the test failure of #1972 .  When the main part of the test succeded  an onCompleted was sent out from the main thread which was not serialized in respect to the onNext(1) issued from the worker thread  therefore  two replay was attempted sometimes. At first the caughtUp was seen false  the replay was entered but the next instruction cleared the index causing the IllegalStateException. Same issue as before. Maybe the error function was not emitting events properly. for  lift()  all the time. cancelled task-retention.  First debated in #1922  see also #1919.  We may want to discuss the naming of system parameters. I chose these so RxJava 2.0 specific properties may be trivially separated:   io.reactivex.rxjava.scheduler.jdk6.purge-frequency-millis  Specifies the purge frequency in milliseconds. Default is 1000.   io.reactivex.rxjava.scheduler.jdk6.purge-force  Forces the use of the purge (if set to true) even if the setRemoveOnCancelPolicy is supported. The benefit is that removing cancelled tasks now runs on a different thread so the main pool thread doesn t waste time on them. The drawback is the retention window can be still to large.  Do we have a wiki page where such parameters are listed? fix.  This PR aims to support the requests in #2331 and #1897 by adding methods to the (final) subject classes that let developers access in-flight state in a snapshot fashion.   This may be considered safe API change because all subject classes were final already so adding extra methods won t break anyone s code (and we will be careful with our Observable in the future). -  NotificationLite  is now extended with two missing value checks: isNull and isNext. - Each subject has  hasCompleted    hasThrowable  and  getThrowable  methods  however  I can t add them to  Subject  because that would be an incompatible API change. - Where applicable   getValue  and  getThrowable  return  null  instead of throwing exceptions so users are encouraged to call hasXXX methods beforehand. - There was a chaining bug in the bounded ReplaySubject: because the terminal value was added after a potential pruning  the node links could get broken and concurrent replays might not have seen the terminal value. - Since  ReplaySubject  can have multiple values  I ve added  size()    hasAnyValue()  (isEmpty is taken) and  getValues()  methods to make a snapshot of the current buffer contents whether or not the  ReplaySubject  has terminated (the usual toList() would wait until the subject has terminated).  - The unrelated  OperatorMergeTest.testConcurrency  hangs for me for some reason without activity (either a buffer bug or a merge bug is in play there). I ve added a timeout so it doesn t stop the other tests. - Increased the limits of  testMergeAsyncThenObserveOn  - Fixed  testOnBackpressureDrop  because in case there was no drop at all  the last value would be NUM - 1. - Changed  SLOW_PASS_THRU  to perform non-trivial work that can t be optimized away by JIT. Take values and check the condition after the value is emitted.  For enhancement request #1649. Changed RxRingBuffer to use synchronized blocks for correctness. We are relying here upon biased locking and lock-elision. It gets pretty close to the baseline  Benchmark:      Benchmark              (size)        1.x   |    PR#2333  |    this    1SyncStreamOfN              1  3779678 748 | 3767936 028 | 3775157 195 1SyncStreamOfN           1000    21250 675 |   18530 542 |   20759 900 1SyncStreamOfN        1000000       20 406 |      17 712 |      19 768 NAsyncStreamsOfN            1   115390 116 |  115629 480 |  113859 532 NAsyncStreamsOfN         1000        2 579 |       2 546 |       2 435 NSyncStreamsOf1             1  3543551 254 | 3602242 709 | 3539162 675 NSyncStreamsOf1           100   299166 910 |  301703 721 |  302642 458 NSyncStreamsOf1          1000    28404 751 |   28420 833 |   28030 881 NSyncStreamsOfN             1  4054571 577 | 4003156 953 | 4061124 105 NSyncStreamsOfN          1000       24 324 |      20 601 |      23 137 TwoAsyncStreamsOfN          1    85846 727 |   85682 983 |   86691 331 TwoAsyncStreamsOfN       1000     1823 137 |    1889 458 |    1761 977 reamOfNthatMergesIn1        1  3724179 351 | 3725068 220 | 3715637 985 reamOfNthatMergesIn1     1000    19051 928 |   19392 595 |   19487 059 reamOfNthatMergesIn1  1000000       18 265 |      18 069 |      18 102      Changes (in respect of 1.x): - using SpscArrayQueue  removed look-ahead and null check - using peek to check for emptyness in certain positions - using short-as-possible synchronization blocks Rebased onto master. To make sure tests don t hang the computation scheduler. On my Windows machine  I ve virtualized an Ubuntu machine and adjusted some tests according to the time it takes on this  slow machine . Changes to #2091 Changed the parameter naming as per [discussed](https://github.com/ReactiveX/RxJava/pull/2465#discussion_r24035981). Tried to be as flexible with the error text as possible. Empty was always stateless so creating a new instance all the time (especially through a  from(Iterable) ) is wasteful. Besides   onCompleted  events don t have to be backpressured.  Should enable identity based optimizations discussed in #1653. For issue #2626.  There is no point in adding maxConcurrent to flatMapIterable because each iterable is subscribed to sequentially and run to completion. Rebased #2600. Fixes #2647 issue with TakeWhile. Named after RxJS  for issue #405 Extracted isUnsubscribed optimization from #2603.      Benchmark                                   (size)   Mode   Samples          1.x        2603     r.s.ComputationSchedulerPerf.observeOn           1  thrpt         5   104110.926  104707.286 r.s.ComputationSchedulerPerf.observeOn          10  thrpt         5   100723.402  105825.148 r.s.ComputationSchedulerPerf.observeOn         100  thrpt         5    24609.763   65571.461 r.s.ComputationSchedulerPerf.observeOn        1000  thrpt         5     3212.434   13020.027 r.s.ComputationSchedulerPerf.observeOn       10000  thrpt         5      955.002    1555.493   r.s.ComputationSchedulerPerf.observeOn      100000  thrpt         5       96.628     160.218   r.s.ComputationSchedulerPerf.observeOn     1000000  thrpt         5        9.508      16.559   r.s.ComputationSchedulerPerf.subscribeOn         1  thrpt         5   114212.000  114485.516   r.s.ComputationSchedulerPerf.subscribeOn        10  thrpt         5   112376.809  112270.024   r.s.ComputationSchedulerPerf.subscribeOn       100  thrpt         5    88433.002  104240.739   r.s.ComputationSchedulerPerf.subscribeOn      1000  thrpt         5    31503.640   64446.984   r.s.ComputationSchedulerPerf.subscribeOn     10000  thrpt         5     3932.988    8200.048 r.s.ComputationSchedulerPerf.subscribeOn    100000  thrpt         5      437.626    1439.069 r.s.ComputationSchedulerPerf.subscribeOn   1000000  thrpt         5       43.104     146.385 Redone #2603.  Run on i7 920  2.6GHz  Windows 7 x64  JDK 1.8u31      Benchmark      (size)       this   Score error       1.x   Score error observeOn           1  160377 408     3091 205  140913 081     7097 415 observeOn          10  132990 049     1477 661  125288 149    14304 259 observeOn         100   43701 203     2342 570   43840 921      944 682 observeOn        1000   11603 952     2377 205   11400 340     1400 628 observeOn        2000    6769 716      220 476    6853 283       71 276 observeOn        3000    4753 876      326 497    4741 108      120 612 observeOn        4000    3616 782      212 285    3632 433      433 754 observeOn       10000    1544 141       28 796    1548 504       61 419 observeOn      100000     149 573       14 974     150 924        8 331 observeOn     1000000      14 909        2 079      13 658        7 702 subscribeOn         1  160639 801    16463 799  156911 862     2463 637 subscribeOn        10  148883 172     6885 684  151514 397     9425 348 subscribeOn       100  133756 358     3329 421  133327 933     3479 124 subscribeOn      1000   56411 785    22525 962   52902 999    19948 305 subscribeOn      2000   35471 110    12240 514   34272 374    16515 454 subscribeOn      3000   25868 564     2755 244   26291 293     2435 165 subscribeOn      4000   20453 512     2996 777   19598 400     4643 195 subscribeOn     10000    8817 797      465 195    5389 428      272 784 subscribeOn    100000     958 665       22 157     900 036      320 547 subscribeOn   1000000      91 606        2 462      91 396        3 407      Note that since the tests create a lot of garbage  some perf numbers have quite some error margin: some appear to be faster with this PR while others appear to be slower  even if they are not affected by the changes. Squashed commits of #2773.  ---  Further optimizations to  observeOn . - Using SpscArrayQueue directly in observeOn instead of  RingBuffer  to avoid the synchronization block - Split tracking structure to serial (SubscriptionList) and timed (CompositeSubscription) in  EventLoopsScheduler  which improves the sequential scheduling performance because a completing task s subscription will be most likely the first item in the underlying LinkedList.  Benchmark: (i7 920  Window 7 x64  Java 1.8u31  5x1s warmup  5x5s iteration)      Benchmark      (size)         1.x    1.x error      this PR   this error observeOn           1  162326 012     2458 085   166536 559     3154 174 observeOn          10  132471 205     1857 434   142517 407     3734 424 ++ observeOn         100   43282 527     2145 910   112238 179     2270 103 ++ observeOn        1000   11779 482      173 370    25726 564      309 193 ++ observeOn        2000    6756 211       89 196    12123 276      276 470 ++ observeOn        3000    4736 893      253 796     9342 673      263 667 ++ observeOn        4000    3661 874       51 359     7346 015      123 049 ++ observeOn       10000    1519 282      108 503     1546 547       21 885 observeOn      100000     151 193        2 569      156 160        1 974 observeOn     1000000      15 373        1 310       15 660        0 153 subscribeOn         1  161290 037     2867 882   164952 259      797 408 subscribeOn        10  151842 821     2448 734   147906 491     4373 682 subscribeOn       100  136418 065     1773 558   136889 052     2362 203 subscribeOn      1000   58389 066     4559 030    59482 225     1372 692 subscribeOn      2000   34089 152     9318 205    36581 203     1264 100 subscribeOn      3000   26712 331     1265 442    26519 320     1319 293 subscribeOn      4000   20118 326     2018 439    20163 395      839 709 subscribeOn     10000    8914 213      677 164     9059 934      200 158 subscribeOn    100000     958 038       43 349      965 663       60 708 subscribeOn   1000000      91 849        2 148       92 706        1 202      Notes: - At  size = 1   the throughput varies in a +/- 3000 range on each run  and since the changes don t touch the scalar optimization  there is no real improvement there. - At  size = 10.000  my system reached either the cache capacity or the OS scheduler s time resolution so there no improvement there on. - At  size = 100.000  and  size = 1.000.000  the throughput doubles if I introduce some extra delay (i.e.  via sleep(1) or some extra work). - The benchmark generates a lot of garbage due to boxing: switching to a constant emitter increases the throughput  subscribeOn(1.000.000)  from 91 to 136.   Since it conflicts with #2772 anyway  this is PR is to let others verify the optimizations actually work on other OSes  because on my Windows  I sometimes get significant variance in the throughput during iterations. Increased iteration time may be required as well. It is possible the synchronized block inside RxRingBuffer blocks out the firehose thread long enough that there will be enough requests cumulating up and no values have to be dropped. The change increases the taken value count and should decrease the likelihood of such no-drop situation. nan Changes to the  window(size)  operator to respect the backpressure on its _outer_ Observable: asking for 1 window will request  size  values from upstream.   Backpressure is ignored on the inner Observable for now  partially because the  BufferUntilSubscriber  doesn t support it  partially because coordinating the inner requests with the outer requests needs more thoughts. The problem is that the outer has to request at least 1 element from upstream in order to open the window  but the inner subscriber may not want that single element just yet or would request more than the remaining window size and it would trigger new windows whose value it can t receive but would overflow the next window s observers.   window(size  skip)  is not changed as I need to think about it more. Not for merge. Diagnosing travis build failure. nan This PR modifies the  Subject  class to host the union of the state-peeking methods of the various  Subject  implementations and fixes the inconsistent behavior of  ReplaySubject.getValues(T[]) .  The changes enable the  SerializedSubject  to relay such state-peeking method calls into the wrapped subject and allows future  Subject  wrappers to do the same (#2458). - Explain  Observable.observeOn  unboundedness - improve  Observable  operator coverage - copy test methods over to  Flowable  operators - apply fixes to  Flowable  operators - add missing calls to  RxJavaPlugins.onError()  - add more time to RS TCK test of  observeOn Added support for backpressure in  toList  and  toSortedList : they emit their buffered content only when downstream actually requested it.  Few other notes: - Added overload to  toSortedList  taking a  initialCapacity  argument which should help reduce the number of times the buffer needs to be resized. - The Func2 parameter of  toSortedList  is now wrapped once per operator instead of once per subscriber. - Using non-final list buffers which are set to null on completion to not hold onto the buffer. -  toSortedList now returns a modifiable  ArrayList : since it is a handoff procedure  there is no value in forcing a non-modification constraint on the emitted list (similar to  toList  even before this PR). Fixes a race condition with the timed schedule (first potentially overwriting the result of the untimed schedule in mas) and a scheduled task retention problem due to not tracking those. This is essentially the pair of the  OnBackpressureDrop . While  OnBackpressureDrop  emits the first value requested and then drops the rest   OnBackpressureLatest  drops values but the latest and emits that when requested. One can also think of this operator as a sample with backpressure.  One mentionable property is that since it holds onto the very last value  downstream has to request at least one to receive  onCompleted() . I ve rewritten  merge  and  mergeMaxConcurrent  together from scratch. - Added experimental  maxConcurrent  overloads to the array-merge and the mergeDelayError - Fixed  OperatorMapNotification  beause it disregarded backpressure on its terminal emissions. - While debugging some merge test failures  I ve encountered a bug in OperatorPublish with the same underlying logical error (see comment) and fixed it here. - Accidentally introduced a few tabs  therefore  I went in and replaced all tabs with spaces. - I ve changed  OperatorMergeTest.shouldNotCompleteIfThereArePendingScalarSynchronousEmissionsWhenTheLastInnerSubscriberCompletes  because it is legal to get onCompleted without any request. Additional asserts for TestSubscriber and the option to specify the initial request via a constructor. platform-safe variants. I ve removed the controversial features and made the backing CachedObservable internal.  Related issue #1483. See #2799 for reasons to deprecate. backpressure support to window(size  skip).  See #1880. Started investigating multiple calls to onStart based on #2979 and found a bunch  but since onStart can be overridden  I might have missed cases. In addition  I ve found a single place where a producer is set twice on a subscriber but again  many other places may exist. There is a need for auto-connection capability for an arbitrary ConnectableObservable similar to how it is possible now to use cache() as an auto-connected unbounded replay.  The new  autoConnect()  method let s specify the number of  Subscriber s required for the real connection to happen and also offers the ability to receive the connection  Subscription .  I ve also updated the parameter name of  cache(int)  to reflect it is a capacity hint and not a bound. Somehow  every second rebase I do I get this tab-space conversion which pollutes my PRs. Fixed unsubscription propagation of two Window variants (boundary  start-end).  In addition  there was a discrepancy reported on [StackOverflow](http://stackoverflow.com/questions/30963993/rxjava-window-buffer-overload-questions-incompatibility-with-rx-net) regarding the factory-boundary version. In Rx.NET  the factory is called whenever the previous boundary observable has produced a value. I.e.  instead of a series of  onNexts  from the same  Observable   it uses a series of  Observable s with a single  onNext  emission as a boundary indicator. CompositeException  won t crash if it received null by some means. A  null  collection or  null  collection item is replaced by a  NullPointerException  instance.  See also: #3046. Factored out the NPE before the thread creation as it can take several milliseconds and other values can just slip through. Requested amount could reach zero between the first check and entering the synchronized block where it has to be re-read in order to verify the scalar emission can really happen at that point  the new  testMergeAsyncThenObserveOnLoop  test failed with  MissingBackpressureException  after ~20 rounds on my i7 4770K.  This might or might not relate to the canary failure  if combined with retry()  it could have failed over and over  but I m not sure where the worker retention might have happened. Increased test coverage of JCTools  queues and unsafe activities. Fixed inconsistencies in the queues. Since these are public API methods  their expected behavior needs to be verified. This includes a rewrite of  SerializedObserver  to have a more cleaner exception semantics.  The  TestSubscriberTest  can be improved further but I ve run out of time for today. And applied the hardenings as well. Apparently  we forgot about this operator. The backpressure handling is a trivial case with  ProducerArbiter . I ve also fixed some apparent code indentation error.  Originally reported in #3128 with a test case which I didn t include due to its lengthy nature  however  I did run the test manually and both passed after the fix. The former Executor-based check instantiated the wrong worker. In addition  I ve refactored the common parts  added check for periodic task retention (after the first round) and added the checks to computation scheduler test as well. Repost of #3022. Repost of #3050. Resolves #3156   Note that since the default merge operation is unbounded  this change could lead to an excessive memory usage when flatMapping fast sources. Note that the pre 1.0.13 version did this albeit on a slighty slower path.  The change also affects the scalar optimization as well. Pre 1.0.13 implicitly limited the concurrency level to RxRingBuffer.SIZE when scalars were received. This version now fills the queue up to the concurrency level.  For 2.0  I suggest having a bounded behavior by default and require the developer to specify Integer.MAX_VALUE to go for the unbounded behavior so he/she knows about the consequences. - Added compile dependency for reactive-streams. - Added some basic methods to Observable.  As long as the project defaults to 1.x  the create PR webpage will take a long time to render because it tries to compare a small branch 2.x against the huge 1.x branch with lots of  deleted  content. A separate project would be much simpler to operate. Spsc: - power-of-2 array - exact capacity array - linked array  Mpsc: - linked Added two convenient methods to  Exceptions  which either throws a fatal exception or reports it with our without the causing value to an Observer. We can use  Publisher  directly and no need for  OnSubscribe .  Operator  is still quite a convenience. Mostly internal addition plus the public  Disposable  interface.  Naming of packages and classes can be changed at any time if one wishes... incomplete.  This PR has a few TODO questions that require decisions. implementations. - SafeSubscriber - SerializedSubscriber - RxJavaPlugins (partial) With all  flatMap    merge  and  mergeDelayError  overloads. refCount  will come later  although its behavior is sometimes surprising to developers: it disconnects and reconnects in certain use pattern. The alternative is to use  autoConnect(n  connectionConsumer)  which lets the developer explicitly disconnect. operators Forgot to add them in the previous PR. toSortedList  is implemented with  toList().map() . I m not 100% certain about the the timing of the onSubscribe() calls inside the operators  I ll have a second run over them once the tests are also added. - isEmpty == any(v -> true) - updated RxJavaPlugins and added decorator calls to the Schedulers. Few considerations: - Added an option to specify if  subscribeOn  should also request on the same worker or not. If not  the consumer thread may freely grab the producer and thus reduce the inter-thread communication. - The scheduling of the subscription in  subscribeOn  now can t be cancelled because in RS  the indication of  subscription  is to call  onSubscribe  on the proper thread. Since the  Subscriber  can t call cancel until it receives the subscription through  onSubscribe  the time it receives the subscription there is no point in cancelling the operation. - Added two parametrization option to  observeOn : the ability to delay the error after all the  onNext  events and the ability to specify the buffer size. Since many get surprised by the 1.x behavior  this should help the situation and also makes it possible to avoid wrapping/materializing the sequence. The second ability should help with fine tuning a particular sequence independent to the other sequences. - I ve padded away (since the  @Contended  annotation is not standard) the request and wip counters in  observeOn . If unpadded  they bash each other constantly and I ve experienced 15-20% throughput loss. This includes - concatMap - concat - startWith - endWith - concatWith - mergeWith (via merge) - forEachWhile that allows stopping the stream from within the onNext callback by returning false.  The lambda subscribe()s return a Disposable so they can be asynchronously cancelled. - internal  EmptySubscriber I ll post the  retryWhen  and  repeatWhen  separately. intervalRange  helps when one needs a fixed amount of timed values and wants to avoid map+take overhead. There won t be  onBackpressureBlock  although it can work with  subscribeOn(scheduler  false)  since that won t schedule the request behind the blocked emission.  Operator  onBackpressureBuffer  has now a  delayError  option  I d like to give the developer the option on this one. Naturally  the default is false. This default implementation supports backpressure but doesn t coordinate the group requests with the main requests in any way.   This means  for example  that given a million element source and a constant true key selector will queue up all million elements until a single subscriber consumes them.  The 1.x version had some coordination and all sorts of group management logic which I don t understand. I ll revisit this operator later. FunctionX extends Function<Object[]  R> and the default method for it unpacks the array. methods. SubscriptionHelper for common validation logic.  The SubscriptionHelper s methods are not yet applied to former operators. Also corrected the naming of one-shot timer and fixed-period interval Instead of having  Timestamped  and  TimeInterval  with the same structure  let s have just a single one:  Timed .   distinctUntilChanged  is implemented via special  distinct . The various doOnXXX operator overloads + range(scheduler) + repeat(scheduler). I know  toList  can be also implemented this way but its frequent use makes it eligible for a custom operator. javac is unable to select the right overload for some reason emission/drain loops.  This may help with operators that call request(1) to replenish a dropped value (filter for example).  I ve only implemented this with the array-source and with a lot of code duplication. I ll think about how to reduce this duplication via inheritance or with lambdas (which might negate the benefit). I d like to state that I try to use  Publisher  as much as possible: this adds the benefit that RxJava can use someone else s publisher without the explicit need to wrap it into an  Observable  all the time. nan - bufferSize +delayError options  as usual by now The multi-offer helps with the timed skipLast. By offering two at once  the drain won t loop until the second value arrives. overloads  some refactorings Very similar to zip in terms of structure. - onErrorReturnValue - a fix to OperatorOnErrorNext Inlined (no zipping and wrapping like in 1.x) - Some minor internal refactorings in  Observable . EmptySubscriber convenience method to reduce boilerplate. Optional.ofNullable  returns an empty instance  not a null-containing one. The  delaySubscription  is implemented via composition. subscribe  stream  forEach  iterator  Now it extends both Publisher and Iterable directly. Converted nicely. subscriber only.  Should be the official API replacement of BufferUntilSubscriber. The boundary version will come next. variants.   Added  QueueDrain  and  QueueDrainSubscriber  for common queue-drain operations. Not applied outside the  buffer() s as of now. Luckily  there is no need to count the emission per subject but just use arithmetic. The timed buffer and window operators are quite complicated in terms of concurrency. I m not sure if all corner cases are covered. (Taking a break from  window()  operators.) TestSubscriber now does asynchronous requests and cancellation. I ve implemented the wrong debounce logic in #3254 . types. - FullArbiter and FullArbiterSubscriber to work with total-ordered notifications across sources.  I ve also sorted  Observable  members. Has full backpressure support (replays as many elements as requested). nan The continuous delivery guarantee and the no-duplication requirement makes it necessary to read/write an index and object values together. I ve implemented this with another synchronized block. The alternatives are: - use an object of (index  value) and atomically set the reference (requires allocation on every value delivered. - this current nested-synchronized block (no deadlock) - use a reader-writer lock which works better when concurrent subscribers want to do their first emission at the same time. ReplaySubject: time and size bound trimming was incorrectly deleting the terminal notification  BehaviorSubject: double emission of the same value. The following loop fails (prints  Bad pattern received: [2  2] ) with 1.x:      java for (int i = 0  i < 1_000_000  i++) {     if (i % 1000 == 0) {         System.out.println( -->   + i)      }     BehaviorSubject<Object> bs = BehaviorSubject.create(1)       List<Object> list = new ArrayList<>()      CyclicBarrier cb = new CyclicBarrier(2)      CountDownLatch cdl = new CountDownLatch(1)       ForkJoinPool.commonPool().submit(() -> {         cb.await()          bs.onNext(2)          cdl.countDown()          return null      })       cb.await()      bs.subscribe(v -> list.add(v))      cdl.await()       if (Arrays.asList(2).equals(list)) {         continue      }     if (Arrays.asList(1  2).equals(list)) {         continue      }     System.out.println( Bad pattern received:   + list)          break      } } I m not 100% certain about the state management: when to let the main source keep running and when to stop. I.e.  the in the selector version  if the other completes  it means no new window will be opened but the active should keep receiving values until their closer fires. If all such closers have fired  the main can be stopped. Subjects are exposed so they may receive nulls that would mess up the internal state. By using null checks and direct returns we can avoid a dynamic dispatch on a volatile variable which always more expensive.  I ve also added the  lockdown()  method to prevent any further changing of the plugin handlers. There is a  unlock  package-private method to allow testing the plugin in the locked state and then return to the unlocked state as other tests may want to install custom plugins. a function and handling backpressure/resource cleanup automatically.  The logic is based on @stealthcode  s SyncSubscriber proposal from 1.x but using only the lambda-form. -  Disposables  utility class with wrapper methods named  from . The cancellation notification will come in handy with window (and in groupby). It helps with the case when the main source has been cancelled but the individual windows/groups are still being consumed. If those get cancelled by their single Subscribers  this notification will reach the source and once all windows/groups get cancelled  the main source can be cancelled.  Fix to generator production accounting. Fixed mistakes in the operators. Either the test is non-deterministic or I still have a bug. Forgot to deliver the value inside the GroupedUnicast drain loop. I ve also added convenience overloads to concat 2-9 sources because  concat(Publisher...)  causes overload resolution conflict with  concat(Publisher<Publisher>) . I ve changed them to use  safeSubscribe  because plain RS subscribers are not expected to throw. We need to talk about  Notification s. Forgot to call request  refactored some validation code. Bugfixes in many operators. I ve refectored the mockSubscriber method out into a helper enum since it will be required almost everywhere. They seem to try testing the request mechanism on thin implementations and are somewhat of no use. Tests expect certain operator parameter orders so I d expect a few changes in Observable in this regard.  Fixed timing bug with  throttleWithTimeout  but I m not 100% certain it works as expected beyond this single test. nan - bugfix to cache  skipUntil and takeUnit nan nan nan Bugfix: since they would emit a value on an empty source  they have to hold it until an actual request comes in. nan - added AsyncSubscription that allows setting the actual subscription   later and can hold a resource. It has less overhead than   SubscriptionArbiter due to single use. Single  is a deferred single-value emitting Observable.   NbpObservable  is the non-backpressure Observable  named this way until the main Observable gets all its tests ported so a refactor can deal with all of them.  I ve implemented the most basic construction and operator methods on them. The concat reuses the same inner subscriber to save on its allocation cost which works only if the inner source conforms with the spec and doesn t emit any event after an onComplete(). There is a test that explicitly calls onComplete() twice to test the resilience of concat. The current workaround makes this test pass but any async non-conforming source may still bug out the operator.   This is a tradeoff between safety and performance. If we d expect such non-conforming behavior  the current optimization has to be turned into a regular individually allocated inner subscribers. Note: several tests have been ignored due to non-conformance with RS  Added missing distinct and distinctUntilChanged overloads  fixed doOnEach not cancelling upstream if the callback crashes on the onNext path. - fixed exceptions throw by elementAt - added operator flatMap of notifications  fixed a bug in onBackpressureBuffer  Note also the few ignored tests because they either want to test against a null value or try to throw from RS methods. for GroupedObservable - added BooleanSubscription to detect cancellation without caring about   requests.  I m still not 100% convinced the groupBy request coordination works properly (i.e.  no stall due lack of requests from one of the groups). - fix to observeOn to not request if cancelled in onNext delivery - fix combineLatest error emission if the other sources are late or   never emit - fix interval and PublishSubject to send MissingBackpressureException nan I had to ignore tests that throw exceptions from a Publisher.subscribe or an Operator.apply due to their non-conformant behavior. - added toSingle and toNbpObservable to Observable - fixed bugs in many operators and in the IO scheduler s release logic Note that testIssue_2191_SchedulerUnsubscribe had to change the call count to pass. I don t understand this test and the over-mocking (but recognize the style). - retry with bipredicate - fixed map not checking the returned value for null - since RS doesn t allow throwing other than NPE  temporarily subscribe   and lift will throw NPE with the actual error as cause so we don t miss   an operator bug due to swallowed exceptions. nan Note that since we know have time unit in schedulers  one must be careful with the time unit of the timed skip operators. The timestamps will be calculated via this unit and may not return the expected values.   For example  a skipLast of 1 second will not skip the value 0.5 seconds before completion because its timestamp is rounded down to the start of the second. But if one uses 1000 milliseconds  the value will be skipped. - fixed a deadlock possibility in one of the merge tests - signature fix to toMultimap and removed deprecated markers. - fixed cancellation behavior of observeOn  subscribeOn and   unsubscribeOn (when and what to call cancel on) - fixed infinite loop in ScheduledRunnable - fixed zip not quitting eagerly if one of the sources was shorter - added specific ZipIterable because zip-iterable tests expect it to be   not prefetching any of the sources (the plain zip does prefetch) - made the fromIterable more resilient to Iterable/Iterator crashes and   added null-value checks I had to adjust some test slightly due to the a new behavior: if one cancels a source which is windowed  as long as the windows are active  the source has to stay active. However  there are more subtle possibilities that need new tests. - Improve coverage of a few  Observable  operators - move some classes into their solo user parent class -  checkDisposed  now calls  dispose / cancel  twice to have better conditional coverage of those methods nan nan I had to ignore many tests because they either test with null or throw an exception from a Subscriber method which are not allowed with RS. - added Observers and Subscribers to create Observers/Subscribers with convenience. - sorted  Observable  and added  @BackpressureSupport  and    SchedulerSupport  annotations. - created  @Beta  and  @Experimental  annotations  nothing is marked   with them because I intent everything to be standard at this point. - I wanted to make sure the slow path passes all tests before enabling   the scalar optimization. - Fixed headers for internal classes Ported the two perf tests to evaluate 2.x throughput.  ![image](https://cloud.githubusercontent.com/assets/1269832/9907226/67a454c8-5c8e-11e5-8644-c3196b2e58d8.png)  My primary suspect for the extra overhead are the atomics of queue-drain. The 1.x uses a synchronized-based emitter-loop which is elided by the JIT compiler but atomics can t be elided. As I mentioned before  synchronized works better for light-to-none asynchronous use whereas atomics work better for asynchronous use.  Also quote from #3157  > Exceptions that do not require a :+1: would be: >  > javadoc changes > unit test additions or refactoring > **perf test additions  fixes or refactoring** > grammatical and presentation fixes to README  CONTRIBUTING  and other such metadata files Benchmarks synchronous  asynchronous (where the emission can hop onto the receiver thread) and strictly-pipelined (the emitter and receiver are on different threads). Results on i7 4790  Windows 7 x64  Java 1.8u60:      Benchmark                (times)   Mode  Cnt         Score        Error  Units RangePerf.rangeAsync           1  thrpt    5    135410 552 ?  20521 908  ops/s RangePerf.rangeAsync        1000  thrpt    5     25634 730 ?    284 526  ops/s RangePerf.rangeAsync     1000000  thrpt    5        59 073 ?      1 154  ops/s RangePerf.rangePipeline        1  thrpt    5     98895 846 ?  11398 363  ops/s RangePerf.rangePipeline     1000  thrpt    5     16233 903 ?    741 712  ops/s RangePerf.rangePipeline  1000000  thrpt    5        10 621 ?      2 606  ops/s RangePerf.rangeSync            1  thrpt    5  30367277 992 ? 170100 628  ops/s RangePerf.rangeSync         1000  thrpt    5    212293 380 ?   3605 320  ops/s RangePerf.rangeSync      1000000  thrpt    5       248 135 ?      1 775  ops/s - Finished covering  Observable  operators to a reasonable level (the remaining are either impossible or only reachable by probabilistic race) - Synced operator coverage between  Observable  and  Flowable  - Started covering  Flowable  operators - Cleaning up a few  Flowable  operators (cache  concatMap) - fix  onBackpressureBuffer(long  Action  BufferOverflowStrategy)  return type - fix  concatMapDelayError  wrong barrier mode selected This PR adds the  fromSupplier  operator to support the new  Supplier  interface.  The marble diagrams will be updated in a separate PR. startWith(T)  and  startWith(Iterable)  was causing some trouble with  startWith(Publisher) . This PR will rename the former two.  The diagrams will be updated in a separate PR.  Resolves: #6122 I ve noticed that the  times = 1  async range sometimes produces double the throughput without any change to the underlying structure and I ve figured out it is because how my operation system wakes up the await in the benchmark. I switched the tests to spin-loop and now I get a consistent and higher value than before:  ![image](https://cloud.githubusercontent.com/assets/1269832/9958923/0ce916fe-5e0f-11e5-988a-3e8cac1098dc.png)  There are a few light-greens and a few light-reds which I attribute to other fluctuating factors on my computer.  In addition  I ve experimented with two optimizations: one for observing a scalar value on a different thread and one where the  OperatorObserveOn  is turned into a  PublisherObserveOn  to save on the allocation of a  PublisherLift . The scalar optimization ended up being slower by 15% for some reason I don t understand and the  PublishObserveOn  had no impact on the throughput within the error range. Related discussion in #3017. I ve added the methods from the 1.x Single plus a couple more based on Observable operators that makes sense to me in respect to Single. No plus unit tests and no javadoc. - non-backpressured subjects. This benchmark compares the overhead of backpressured range  non-backpressured range  streamed range and parallel-streamed range. Run on i7 4770K  Windows 7 x64  Java 1.8u60.  ![image](https://cloud.githubusercontent.com/assets/1269832/10107747/75d7c094-63bd-11e5-9e6d-fd3afd50b552.png) Discovered while debugging #3381. Confirmed with JCTools in https://github.com/JCTools/JCTools/pull/80 This came up in a [Stackoverflow](http://stackoverflow.com/questions/32889008/do-operators-instead-of-a-whole-subscriber) answer. If the  doOnError  s callback or the  doOnEach  s  onError  method throws  any non-fatal exception replaced the original error which got lost. This PR will wrap them both into a  CompositeException .  2.x note: since Java 8 supports  addSuppressed  all callbacks in this situation either attach to the original exception or the original exception is attached to the callback s exception. This PR adds marbles to the new  fromSupplier  operators:  #### Flowable: ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromSupplier.png)  #### Observable: ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.fromSupplier.png)  #### Maybe: ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromSupplier.png)  #### Single: ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.fromSupplier.png)  #### Completable: ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromSupplier.png) There seems to be a tendency to send  null  values through  onError  which eventually causes repeated failures. This PR converts these  null  values into  NullPointerException s so the error origin is can be discovered and prevents the XXXExceptions from throwing NPEs in their constructors as well.  I ve also added some missing javadoc. This is a backport of #3439. Requested in #3445.  This is an efficient implementation as it avoids allocating the lifter object  doesn t require a function wrapper and doesn t use producer arbitration.  (Bonus points to those who can recognize the similarities with #3446). There is a problem  reported in #3461 and #2943  in which if the system clock drifts  the periodic calculation inside Scheduler.Worker gets off and either taking a longer time for the next invocation of the task or doing  catching-up  with all the lost invocations.  The solution checks the wall clock difference between the last run and the current run and if it went back or forward significantly  it rebases the timer period and schedules the next execution relative to now.  If the clock goes back  the original code scheduled the next invocation way into the future. This PR will schedule it after the period.  If the clock goes forward  the original code scheduled executions for all the missed time between the last run and the new time immediately  yielding a bunch of 0 delays. This PR will simply schedule the next invocation after the period.  The algorithm for both cases is the same: make sure the next invocation is scheduled relative to now and recalculate the start timestamp as if the whole sequence run under the new drifted clock all along. The subsequent invocations will be scheduled at a fixed rate again.  I ve added the system parameter  rx.scheduler.drift-tolerance  (unit: minutes  default: 15 minutes)  which is used to determine if the clock drifted too far between invocations of the periodic task. This PR adds the  eagerTruncate  option to the  replay  operator so that the  head  node will lose the item reference it holds upon truncation.  The bounded buffers in  replay  implement a linked list that when truncated  moves the head reference forward along the links atomically. This allows late consumers to pick up the head and follow the links between them to get items replayed. However  the truncation may happen concurrently with a consumer working on some prior nodes so if the truncation would  null  out the value  the consumer reaching the same node would see  null  as well and fail.  ![image](https://user-images.githubusercontent.com/1269832/59920898-55c5a980-942c-11e9-8dc1-b9e07264a36f.png)  To avoid this type of retention  the head node has to be refreshed with a new node still pointing to the next node in the chain but without any value.   ![image](https://user-images.githubusercontent.com/1269832/59921066-dbe1f000-942c-11e9-92a9-d2e06f1839a0.png)  The reason this is not the default is that it requires an additional allocation for each new incoming value when the buffer is full  which would reduce performance in cases where the excess retention is not a problem.  Overloads to both the direct and function-variants of both  Flowable.replay()  and  Observable.replay()  have been added. To avoid too many overloads  only one extra overload has been added extending the signature of the longest parameterized method per each bounds mode (size  time  time+size).  Their unit test files have been cloned so that both the non-eager (original) behavior and the eager behavior is tested separately.  Fixes #6475 Make the resource disposal order in all  using  implementations are consistent with the eagerness of the operator:  **eager**: dispose resource then dispose the upstream **non-eager**: dispose the upstream then dispose the resource.  Fixes: #6347 Reported in #3469.  This change will make sure whenever a new subscriber arrives  the request coordination doesn t scan every other subscriber unnecessary. (They will trigger a manageRequests individually anyway).  Unfortunately  I can t make the subscription registration constant (via a HashSet) because that would slow down the dispatching loop (which is quite expensive to for-each over compared to a plain array).  Note also that this will likely conflict with #3454.  I get the following numbers with the program in #3469.      subscribing... subscribed so far 10000  took 54ms to subscribe last 10000 at rate: 185185 per sec... subscribed so far 20000  took 110ms to subscribe last 10000 at rate: 90909 per sec... subscribed so far 30000  took 157ms to subscribe last 10000 at rate: 63694 per sec... subscribed so far 40000  took 267ms to subscribe last 10000 at rate: 37453 per sec... subscribed so far 50000  took 211ms to subscribe last 10000 at rate: 47393 per sec... subscribed so far 60000  took 320ms to subscribe last 10000 at rate: 31250 per sec... subscribed so far 70000  took 331ms to subscribe last 10000 at rate: 30211 per sec... subscribed so far 80000  took 369ms to subscribe last 10000 at rate: 27100 per sec... subscribed so far 90000  took 415ms to subscribe last 10000 at rate: 24096 per sec... subscribed so far 100000  took 462ms to subscribe last 10000 at rate: 21645 per sec... subscribed so far 110000  took 516ms to subscribe last 10000 at rate: 19379 per sec... subscribed so far 120000  took 547ms to subscribe last 10000 at rate: 18281 per sec... subscribed so far 130000  took 647ms to subscribe last 10000 at rate: 15455 per sec... subscribed so far 140000  took 720ms to subscribe last 10000 at rate: 13888 per sec... subscribed so far 150000  took 811ms to subscribe last 10000 at rate: 12330 per sec... subscribed so far 160000  took 806ms to subscribe last 10000 at rate: 12406 per sec... subscribed so far 170000  took 873ms to subscribe last 10000 at rate: 11454 per sec... subscribed so far 180000  took 911ms to subscribe last 10000 at rate: 10976 per sec... subscribed so far 190000  took 986ms to subscribe last 10000 at rate: 10141 per sec... subscribed so far 200000  took 1003ms to subscribe last 10000 at rate: 9970 per sec... subscribed so far 210000  took 1168ms to subscribe last 10000 at rate: 8561 per sec... subscribed so far 220000  took 1213ms to subscribe last 10000 at rate: 8244 per sec... subscribed so far 230000  took 1340ms to subscribe last 10000 at rate: 7462 per sec... subscribed so far 240000  took 1314ms to subscribe last 10000 at rate: 7610 per sec... subscribed so far 250000  took 1548ms to subscribe last 10000 at rate: 6459 per sec... subscribed so far 260000  took 1372ms to subscribe last 10000 at rate: 7288 per sec... subscribed so far 270000  took 1835ms to subscribe last 10000 at rate: 5449 per sec... subscribed so far 280000  took 2087ms to subscribe last 10000 at rate: 4791 per sec... subscribed so far 290000  took 1910ms to subscribe last 10000 at rate: 5235 per sec... subscribed so far 300000  took 1966ms to subscribe last 10000 at rate: 5086 per sec... unsubscribing... unsubscribed so far 10000  took 1910ms to unsubscribe last 10000 at rate: 5235 per sec... unsubscribed so far 20000  took 1782ms to unsubscribe last 10000 at rate: 5611 per sec... unsubscribed so far 30000  took 1730ms to unsubscribe last 10000 at rate: 5780 per sec... unsubscribed so far 40000  took 1593ms to unsubscribe last 10000 at rate: 6277 per sec... unsubscribed so far 50000  took 1514ms to unsubscribe last 10000 at rate: 6605 per sec... unsubscribed so far 60000  took 1468ms to unsubscribe last 10000 at rate: 6811 per sec... unsubscribed so far 70000  took 1188ms to unsubscribe last 10000 at rate: 8417 per sec... unsubscribed so far 80000  took 1234ms to unsubscribe last 10000 at rate: 8103 per sec... unsubscribed so far 90000  took 1271ms to unsubscribe last 10000 at rate: 7867 per sec... unsubscribed so far 100000  took 1358ms to unsubscribe last 10000 at rate: 7363 per sec... unsubscribed so far 110000  took 1103ms to unsubscribe last 10000 at rate: 9066 per sec... unsubscribed so far 120000  took 1100ms to unsubscribe last 10000 at rate: 9090 per sec... unsubscribed so far 130000  took 990ms to unsubscribe last 10000 at rate: 10101 per sec... unsubscribed so far 140000  took 953ms to unsubscribe last 10000 at rate: 10493 per sec... unsubscribed so far 150000  took 854ms to unsubscribe last 10000 at rate: 11709 per sec... unsubscribed so far 160000  took 789ms to unsubscribe last 10000 at rate: 12674 per sec... unsubscribed so far 170000  took 779ms to unsubscribe last 10000 at rate: 12836 per sec... unsubscribed so far 180000  took 624ms to unsubscribe last 10000 at rate: 16025 per sec... unsubscribed so far 190000  took 634ms to unsubscribe last 10000 at rate: 15772 per sec... unsubscribed so far 200000  took 514ms to unsubscribe last 10000 at rate: 19455 per sec... unsubscribed so far 210000  took 411ms to unsubscribe last 10000 at rate: 24330 per sec... unsubscribed so far 220000  took 373ms to unsubscribe last 10000 at rate: 26809 per sec... unsubscribed so far 230000  took 337ms to unsubscribe last 10000 at rate: 29673 per sec... unsubscribed so far 240000  took 286ms to unsubscribe last 10000 at rate: 34965 per sec... unsubscribed so far 250000  took 234ms to unsubscribe last 10000 at rate: 42735 per sec... unsubscribed so far 260000  took 222ms to unsubscribe last 10000 at rate: 45045 per sec... unsubscribed so far 270000  took 159ms to unsubscribe last 10000 at rate: 62893 per sec... unsubscribed so far 280000  took 96ms to unsubscribe last 10000 at rate: 104166 per sec... unsubscribed so far 290000  took 63ms to unsubscribe last 10000 at rate: 158730 per sec... unsubscribed so far 300000  took 31ms to unsubscribe last 10000 at rate: 322580 per sec... This specialized OnSubscribe performs ~33% better on longer streams.  Benchmark comparison (i7 4770K  Windows 7 x64  Java 8u66):  ![image](https://cloud.githubusercontent.com/assets/1269832/10802983/1ef4027a-7dc0-11e5-996a-9e9cf7033ed3.png)  The  slowpath  requests the available amount + 1 to trigger a slow path   slowpath2  requests in batches of 128 and replenishes only after all were received. The documentation was wrong in two points: unsubscription doesn t call onCompleted  and unsubscription doesn t directly prevent delivery of  onXXX  events since the implementation doesn t even check isUnsubscribed: (it is the responsibility of the upstream to do that).  Related issue: #3059. This adds a new pattern and lookup method that let s the developer specify the custom plugins with shorter system property keys. Android is quite restrictive and allows only 31 characters.  The new pattern splits the target simple class name and its implementation into two separate system properties:      rxjava.plugin.1.class=SimpleClassName rxjava.plugin.1.impl=path.to.impl.Class      The index tag ( 1 ) can be any string of your chosing:      rxjava.plugin.mykey.class=SimpleClassName rxjava.plugin.mykey.impl=path.to.impl.Class      but make sure they are paired  otherwise nothing will happen.  If there are multiple  class  entries with the same  SimpleClassName  one of them will be chosen (depending on the walk order in  java.util.Properties ).  Related issue #2835. This PR adds this documentation part to the various  create  JavaDocs (adapted):  Whenever an  Observer  subscribes to the returned  Observable   the provided  ObservableOnSubscribe  callback is invoked with a fresh instance of an  ObservableEmitter  that will interact only with that specific  Observer . If this  Observer  disposes the flow (making  ObservableEmitter#isDisposed  return true)  other observers subscribed to the same returned  Observable  are not affected.   Resolves #6390 There was a cross dependency between two PRs yielding a broken compilation in main. This PR fixes the cases when the Completable factory throws an exception or returns null and the resource is not disposed before reporting error to the subscriber. Updated  just()  to fully support backpressure.  This is a repost of #3496 due to merge and rebase problems. Promote the following experimental operators to standard:  -  Completable.delaySubscription(long  TimeUnit [  Scheduler])  -  Completable.materialize()  -  Flowable.dematerialize(Function)  -  Maybe.doOnTerminate()  -  Maybe.materialize()  -  Observable.dematerialize(Function)  -  Single.dematerialize(Function)  -  Single.materialize()   There were no  Beta  operators in 2.2.x. This PR adds an overload to  concatMap  and  concatMapDelayError  in both  Flowable  and  Observable  which makes sure the  mapper  function is always executed on a dedicated scheduler.  By default  concatMap  may execute the  mapper  function on various threads: the subscribing thread  the upstream thread generating the items to be mapped or the thread where the generated inner source terminates. These overloads remove this kind of uncertainty.  The implementation is a copy of the original concatMap instead of an extension so that optimizations for the non-scheduled variants still work without extra overhead.  Overloads to the  concatMap{Single|Maybe|Completable}  and  concatMap{Single|Maybe|Completable}DelayError  *may be added* in a separate PR later.  Resolves #6447 This PR is a backport of the 2.x  combineLatest  with  null  support and let s the programmer combine more than 128 sources at once. Note that 2.x supports manual sizing of the prefetch buffer and allows delaying the exceptions to the last moment  I kept these in case such features are required by 1.x some day.  The original had this 128 limit due to using a single and non-parametric RxRingBuffer to store values from sources. In addition  the original algorithm divided downstream requests among the sources with some strange logic in order to keep them running and not overflow the buffer.  This PR uses an unbounded-linked SPSC queue which can now hold as many elements as there are sources times the default ring buffer size (this is not preallocated and grows/shrinks as necessary).  The algorithm stores the current latest array and the source subscriber in the queue in pairs so when that particular row is emitted to downstream  that source subscriber gets the request() replenishment call that generated the row.  In addition  I ve added an Iterator overload from #3660 as well. Due to the issue with AtomicXFieldUpdaters on certain Android devices  I had to manually replace all of them with regular AtomicX classes. I cut this short so there is time for the **2.0.0-RC release preparations**. - Introduce  SimplePlainQueue  where  poll  doesn t throw  avoiding the need for try-catches where the queue is one of the standard lock-free queues. - Fix  FlatMap  error  cancellation and resource management. - Coverage of some  Flowable  operators - Removal of impossible and unused code paths. - fix  Flowable.materialize()  terminal signal emission in face of backpressure - fix  Flowable.onErrorReturn()  terminal signal emission in face of backpressure - cleanup  Flowable.publish()  and enable operator fusion on its input - fix  Flowable.flatMapSingle()  and  Flowable.flatMapMaybe()  termination detection - compact  Flowable.blockingSubscribe()  and  Observable.blockingSubscribe()  - compact  Flowable.subscribeOn() This PR removes some obsolete API.  The  Flowable.dematerialize()  and  Observable.dematerialize()  were inherently type-unsafe and have been removed. In Rx.NET  the extension methods allowed  dematerialize()  to be applied to  Observable<Notification<T>>  only  but there is no way for doing it in Java as it has no extension methods and one can t restrict a method to appear only with a certain type argument scheme.  The replay(Scheduler)  and other overloads were carried over from the original Rx.NET API set but I can t rememeber if they had any use in the field. Most use cases capture the connectable anyway so there is no much benefit from inlining an  observeOn  into a connectable:     java ConnectableFlowable<Integer> connectable = source.replay()   Flowable<Integr> flowable = connectable.observeOn(Schedulers.io())   // hand flowable to consumers flowable.subscribe()   connectable.connect() I forgot that RxCached threads can get evicted during the test. The new logic makes sure no new threads appeared. This PR fixes the backpressure behavior of the counted  buffer  and  window  operators and consists of several changes.  The main issue lies when  count > skip  in the operators  yielding overlapping buffers/windows.   For  buffer   when the upstream completed  the logic emitted all remaining partial buffers even if there was no request for new buffers  which can result in  MissingBackpressureException  somewhere. The proper handling of the final buffers required a new backpressure management algorithm which is now part of the  BackpressureUtils  class and consists of two new methods:  postCompleteDone  called from onComplete to take over the emission of queued values and  postCompleteRequest  which manages requests before and after the completed state.  For  window   the new window opened was emitted regardless of requests which was common due to request-amplification (i.e.  requesting n windows results in requesting  count + skip * (n - 1)  elements at first (then  skip * n  later) which opens  ceil(count / skip)  windows upfront. To avoid the overflow  the individual windows have to go through the usual queue/drain logic as well. I ve also updated the Javadoc to reflect the backpressure behavior along with parameter validation.  In addition  the window case didn t manage cancellation properly. When the outer observable is unsubscribed  the inner subscribers may be still going and thus cancelling the upstream would stop/hang the inner windows. Instead  the open window count is tracked (also counting the outer as 1 window) and when all get unsubscribed (i.e.  count reaches zero)  the upstream is unsubscribed. To accomplish this  the  UnicastSubject  had to be retrofitted with a new optional callback  Action0  which gets called at most once whenever either  onError  or  onCompleted  is called or when the single  Subscriber  unsubscribes.  A secondary issue was with the  TestSubscriber  s initial request  some upstream operators could get triggered with  Long.MAX_VALUE  despite the initial request amount was set. This PR changes it to be set at construction time instead of in  onStart . This PR fixes the  messing around  reported in #3002 and adds an overload to  observeOn  that allows delaying errors without the need for wrapping (see #3542 and maybe there are other reports).  In addition  this PR adds a proper override of the  isEmpty  method to simply compare the two indexes for emptiness directly instead of  size() == 0  to avoid looping  multi-reading and casting.  Benchmark comparison (i7 4790  Windows 7 x64  Java 8u66):  ![image](https://cloud.githubusercontent.com/assets/1269832/11442154/3f4f104a-9513-11e5-9b0c-00cef5a6bb10.png)  Note that the benchmark is generally quite noisy  yielding hectic results (i.e.  firing up a thread with newThread may take quite some random microseconds). For example   observeOnImmediate  shouldn t be affected by any of the changes yet the run-to-run variance is +/- 10%. I m fine with the results of the benchmark. Fix  distinctUntilChanged  to store the selected key instead of the input value.  Reported in #4743 See #1508 The operators didn t honor backpressure when they switched over to the other Observable.  This PR also includes the fix #3685. The upgraded gradle switched my IDE to use a JDK 6 library I have installed all along and these popped up immediately. Flowable.concatMapEager  s drain loop when encountering a finished inner jumped back to the beginning of the loop but disregarded the potentially changed request amount and just stopped emitting. The fix is to use the typical request management approach of reading the current request at the beginning of the loop and then committing the emission amount before trying to leave the loop.  Related: #4620  In addition  TestHelper.assertError  has been changed to attach the whole unexpected exception to the  AssertionError . The empty and lambda-based  Completable.subscribe()  returns a  Subscription  whose  isUnsubscribed  should be consistent with the rest of the reactive objects by returning true if the sequence terminated (not just when one truly cancelled it). The  FlowableWindowWithTimeTest.restartTimerMany  did not wait for its source to receive the cancellation and subsequent tests could delay this cancel.  Related: #4750 - Remove unused or unnecessary code paths. - Fix cancellation bugs in  Flowable  operators. - Unify  MapNotification    Materialize    OnErrorReturn  last element backpressure under the same helper class. - Move  FlowableBlockingIterator  into  FlowableBlockingIterable . - Reuse parts of  FlowableSequenceEqual  in  FlowableSequenceEqualSingle . - better coverage of  Flowable  operators - cleanup of operator internals - better coverage of standard Schedulers. - rewrite of  takeUntil  to avoid  onSubscribe()  races. This PR adds the factory method  using()  +1 overload to  Single  as requested in #3732.  For convenience  I ve also added  Single.subscribe(Observer) . This PR fixes the  SerializedObserverTest.testNotificationDelay  test to use reentrancy to verify the buffer in  SerializedObserver  is properly drained. For now  it loops 10 000 times to see if the CI brings up the issue again. Takes 400ms on my machine but I ll probably reduce it to 1 000 times.  (The previous version was a bit convoluted with all those countdowns that didn t properly lock out the other thread).  Reported in issue #1389 Original issue: #3616. This is a full rewrite of the  concat / concatMap  operator with the following properties: - using  OnSubscribe  to save on the allocation of  lift  -  concatDelayError  and  concatMapDelayError  to delay errors to the very end - new trampolining logic that also subscribes to the next source even if requested is zero - using  concatMap  or  concatMapDelayError  on a scalar source now bypasses the operator completely and uses  ScalarSynchronousObservable.scalarFlatMap  as well. - the operator now detects  just  and  empty  sources and bypasses subscribing accordingly - added  ExceptionsUtils  to work with composite exceptions and terminal state  useful for other similar delaying operators later on. -  concat  is now implemented as  concatMap(v -> v)  which saves on the allocation of an entire  map  operator -  OperatorWindowWithSizeTest.testBackpressureOuterInexact  had to be ignored because  window  doesn t honor backpressure properly and it is fixed in #3678  once it has been resolved  the test can be reenabled - Added varargs constructor to  CompositeException  for convenience  avoids creating a list when the number of initial exceptions are known upfront.  Performance comparison to baseline (i7 4770K  Windows 7 x64  Java 8u72):  ![image](https://cloud.githubusercontent.com/assets/1269832/13744915/603866a8-e9eb-11e5-8711-8feb24fbb872.png) This PR relates to the failure of  errorThrownIssue1685 .  The underlying problem was with the  GenericScheduledExecutorService . By being multi-threaded  tasks scheduled from the same thread one after the other may get reordered because different worker threads inside the pool could pick them up at the same time. In this case  there is no guarantee they keep their FIFO order.  _(I currently have no idea how one can use trampolining for this case  subsequent tasks may have any relative delays in respect to each other.)_  The solution creates N single threaded  ScheduledExecutorService s and getInstance() hands one of them out. In turn  ExecutorService  takes one in its worker upfront.  However  there is still the problem when the programmer uses a multi-threaded  ScheduledExecutorService  with  Schedulers.from()  when the same issue comes back. A solution to that problem would be to always use the new  GenericScheduledExecutorService  for delaying timed tasks. This PR exposes the  delayError  option in  combineLatest  as  combineLatestDelayError .  (Note that we have convenience overloads with 2-9 sources that could also use an overload  but that just expands the API surface drastically.) This PR adds a delayError version to the  switchOnNext  /  switchMap  operators. This PR renames and moves classes around to match the design document.  In addition  JMH version is updated to 1.11.3 and Gradle to 2.12.  Internal classes haven t been renamed yet and I plan to do it after this PR is merged.  This PR can t be effectively reviewed on GitHub. I suggest a clean checkout to your local IDE and see the proposed structure there. This is the last part of my dedicated coverage improvement run. - Update code paths and remove unnecessary and unused parts. - Fix  skipUntil  lifecycle and concurrency properties. - Fix  concatMapEager  error management. -  Flowable.scan(T  BiFunction)  now emits the initial value only when the upstream signals an event. This has the effect that even if there is a downstream request  the initial value won t get emitted. This change reduces the overhead of the operator greatly. In 1.1.1   groupBy  was fixed to properly honor backpressure on the outer  Observable . The change included a drain loop that emitted  onCompleted()  to the groups only when all  GroupedObservable s were drained from the main queue. This delayed the group s completion unnecessarily causing the  concat  operator to hang in some source-consumer cases such as #3775.  This PR fixes the behavior by signalling  onCompleted()  to the groups the moment the main completes.   Note  however  that concatenating groups is eventually prone to hangs due to the groups not completing until the source completes  thus  concat  can t switch to the next source. One should use  flatMap  or  concatMapEager  instead. Possible solution to #3749. The type inference of javac in JDK 9 has been changed in an incompatible way  marking many generics-related code invalid.  The most common problems: - The inference calculates  Observable<? extends T>  but from its perspective  a call to  subscribe()  with a  Subscriber<T>  is ambiguous as it matches  subscribe(Observer<? super T>)  and  subscribe(Subscriber<? super T>) . Somehow  the more specific class is not considered as a valid choice. Downcasting to  Observable<T>  fixes the error. -  A<?>[]  no longer accepts  A<Ti>  elements  requires the use of raw types to get around  The tests appear to compile fine.  Note that I couldn t find a working IDE for JDK 9 and had to revert to command line trickery:      @echo off  dir /s /B src\main\java\rx\*.java > sources.txt dir /s /B src\test\java\rx\*.java >> sources.txt   c:\program files\java\jdk-9\bin\javac.exe  -cp C:/temp/rx/junit.jar C:/temp/rx/mockito.jar @sources.txt   del sources.txt AsyncSubject  can trivially support backpressure when it emits a single item by setting the  SingleProducer  on the child  Subscriber  instead of calling  onNext  immediately. This PR fixes the producer retention problem and backpressure problem in  switchMap / switchOnNext .  In the original  when an inner source completed  its producer was still referenced after it. If there was no new inner source or the next inner source didn t set a new producer  the operator leaked the previous inner source s internals. The fix involves nulling out the producer field when the inner source completes (and is still the current one).  The original had an additional bug due to a race condition between the request arbitration and switching inner sources. In some cases  the switch didn t properly forward the remaining request amount to the new inner source  causing hangs. In some other cases  both the old and new inner sources were able to emit  causing overflow. The fix involves a new queue-drain loop with some emitter-loop help to work out the state transitions. This PR factors out many anonymous inner classes into named classes and moves them outside  Observable .  This cleanup makes the  Observable  more compact and helps debugging by showing more meaningful names in stacktraces. Resolves #3881.  The bug is caused by the impedance mismatch between  Observable  s  Subscriber  and  Single  s  SingleSubscriber . The original code called  onNext()  which immediately signalled an  onSuccess  but also caused an unsubscription  preventing a delivery of  onCompleted()  in the inner Single.  The fix keeps  onSuccess / onError  rails intact  throughout the chain. This change will make sure if the  Subscriber  has unsubscribed  the non-fatal error is sent to the plugin error handler at least. I.e.       java Observable.create(s -> {     s.onError(new RuntimeException())      throw new IllegalArgumentException()  }).subscribe()       In addition  if the original code threw  RuntimeException  in case the  subscriber.onError()  threw. I ve changed this to  OnErrorFailedException  but not sure the original type was intentional or just left out. By default  operators have final link to their child Subscriber and they never clear the upstream s Producer. If the end subscriber is referenced  for example in a  CompositeSubscription   that keeps an entire chain of objects alive and can cause memory leaks (a use case common on Android).  This proposed operator detaches the structures and nulls out references if the sequence terminates or the downstream unsubscribes - at the cost of atomic operations and mandatory volatile read for each onNext().   I know this issue has been brought up several times  but instead of adding the overhead to every operator  I propose an operator that can be applied when the developer really needs it (i.e.  could be part of the usual compose(subscribeOn/observeOn) setup).  On the implementation side  this requires deferred  Producer / request()  handling because requests from downstream may appear even before the upstream calls  setProducer  (if at all) and we can t use the base class  behavior for this. This PR simply adds missing license header to main and test files. See #3877 See #3774 In addition  the behavior of time-limited mode has been changed. Late subscribers will now skip stale data.  Related issue: #3917 Somehow  Subscriber.NOT_SET was object  Long  instead of primitive  long . This PR adds extra information to assertion failure messages on  TestSubscriber  and  TestObserver   indicating: - the listener didn t receive any  onCompleted  calls  which is an indication of hung or skipping operation  - there were errors received  indicating a failure in the event generation process.  Previously  if there was something wrong with the sequence  the order and type of assertions were mostly unhelpful: if  assertValues  was first  the lack of values failure could hide a revealing onError call. If the  assertNoErrors()  was first  the error is visible but no way of knowing how far the sequence got.  Now  it is generally okay to use  assertValues  first  which along the difference  will print the lack of completion and the number of exceptions received  plus  the  AssertionError  will have its cause initialized to the actual or composited exception. The message format thus changes:      original assertion message with details (0 completions) (+1 error) ... caused by ...      This extra information saved me a lot of time in 2.x and Rsc development.  Note that this change doesn t make the  assertXXX s also assert for completion or error at all. If the values match  but there is an additional error instead of completion  one has to assert that separately  just like now. Plus  the unsubscribe indirection has been inlined  making  State  implement  Subscription  directly (instead of  Action0  +  Subscriptions.create ). See #3940. Add option to safely subscribe a  CompletableSubscriber  / regular  Subscriber  and handle  onXXX  failures.  See also: #3938  Naming and whether or not the safe wrapping should be the default is open to discussion. My Eclipse warned me about several hundred javac and javadoc errors which could hide other significant warnings. This PR is the first part to fix those warnings. Note that  Observable  and  Single  itself is full of those as well (several hundred in each). When running a blocking emission in  Flowable.create  with  subscribeOn   the default behavior of  subscribeOn  is to schedule downstream requests onto the same thread. Unfortunately  the blocking emission prevents the backing threadpool the  create  from accumulating that request amount leading to either buffer bloat or dropped emissions till the very end of the sequence.  This PR introduces a  nonScheduledRequests  parameter to  subscribeOn  that simply calls the upstream s  request()  from the caller s thread without scheduling it. The parameter is not exposed to the surface API but the  subscribeOn  operator does an  instanceof  check to see if the upstream type is  FlowableCreate .  Note that this requires a direct upstream  create  and any intermediate operator re-enables the default behavior. It is possible to traverse the upstream graph to locate a  FlowableCreate  but it has relatively high cost and thus penalizing all  subscribeOn  usages.  Related: #4735 Next round of cleanup  still about 100 cases remain in  Completable  and  Observable   but those will most likely conflict with open PRs. Add  withLatestFrom  operator version that can take 2 to N other sources and combine them with the main source.  Related: #3779. This is a follow-up on #3964 but with a separate operator on  Observable . See #3576 . See #3960 and #3124. Sometimes  the heavy Travis CI load (or throttling) makes a few tests fail with timeout. This increases the timeout for some of them to reduce the likelihood. The reset shut down all the main schedulers and the helper pools  causing the failure in #3993 .  @hzsweers  you were right with the need for the instance-shutdown method. In the spsc queues  the indexes were written before the actual elements and thus a concurrent  isEmpty  check would report a non-empty queue but a  poll  would still return  null . The fix swaps the two writes.  Note that this an inconsistency in the original JCTools code and not the lack of keeping up with it. This PR deprecates  TestObserver  in favor of the richer  TestSubscriber .  In addition   TestSubscriber  gets 3 new methods and 1 deprecation: -  getCompletions()  to return the onCompleted count as int instead of Notifications -  getValueCount()  returns the committed number of onNext events for thread-safe checking of values up to this count -  awaitValueCount  repeatedly sleeps up to a timeout and waits till the committed onNext count reaches/passes the expected amount. The  Observer  that is subscribing to the  Observable  returned by the handler function was not properly linked to the disposing of the end Observer. This PR fixes it by making that  Observer  do async  Disposable  management and make sure the end  Observer  receives a disposable list with both the main and the handler  Disposable s.  The  Flowable  versions worked properly but added unit tests to them regardless.  Reported in #4782. Make sure there is enough time for the test and the latch is always counted down.  /cc @artem-zinnatullin Fixes the documentation problem reported in #3721. This PR rephrases the  cache  documentation a bit and adds workaround for stopping and forgetting the cached values.  Related: #3007. The catch around the predicate didn t actually signal the CompositeException.  Discovered in #4025 This is the first step towards the new architecture where operator implementations are themselves of the base type instead of a 2-3 layer indirection as in 1.x.  This PR removes the instance field  onSubscribe  from the base reactive classes and introduces  subscribeActual  to be overridden with the custom operator logic now on. Existing operators are still working through the classical OnSubscribe/Lift indirection and will be updated in subsequent PRs.  Naming and existence of  subscribeActual  is up for (post-merge) discussion. To recap  the method is needed so that the default  subscribe  method can be made final and ensure plugin hooks can be called (once available). The method is protected and only affects operator implementors that chose to extend the base reactive classes directly.   The alternative is to leave  subscribe  abstract and add a hook to every operator method (for example  see [this](https://github.com/reactor/reactive-streams-commons/blob/master/src/main/java/rsc/publisher/Px.java#L50) and [this](https://github.com/reactor/reactive-streams-commons/blob/master/src/main/java/rsc/publisher/Px.java#L162). Observable.repeatWhen  was not properly signalling an upstream  onError  case. The  Flowable.repeatWhen  works as expected. This PR adds 3 convenience methods -  assertResult    assertFailure  and  assertFailureAndMessage  from 2.x  makes the  assertValueCount  fluent to allow chaining a subsequent  requestMore  call and adds the missing JavaDoc to the  AssertableSubscriber  interface. DoAfterTerminate was intended to call the callback after either onCompleted or onError but somehow missed that behavior in 1.x.  Related: #4822 This PR adds the  Flowable.doFinally  method that executes an action when the upstream terminates or the downstream cancels (but only once per subscriber). Formerly  one could use  doAfterTerminate  +  doOnCancel  together but no support for making sure only one executed the cleanup action.  Based on the feedback  the rest of the base reactive types can get the same operator a bit later. This PR adds the  doFinally  operator to the rest of the base reactive classes. This PR adds the  Flowable.doAfterNext  operator which calls a  Consumer  after the call to  downstream.onNext()  with the same value.  In addition   doOnNext    doAfterNext  and  doFinally  received their Reactive-Streams TCK tests. This PR adds  Observable.doAfterNext    Maybe.doAfterSuccess  and  Single.doAfterSuccess . This PR just adds the  TestSubscriber.requestMore  that calls  request  and returns  this  for method chaining purposes. This PR fixes some javadoc mistakes with operators such as  single    first    last  and co and removes  @throws  tags from operators since those don t throw it when the method is invoked. This PR removes the  ObjectPool  and  SynchronizedQueue   as their utility now seems surpassed.  In addition  this PR contains a bunch of code style cleanups. Use the  ?w=1  [parameter to hide whitespace changes](https://github.com/ReactiveX/RxJava/pull/4846/files?w=1).  Other changes:    - fix finality of  BackpressureOverflow    - introduce the system parameter for io scheduler time-to-live counter:  rx.io-scheduler.keepalive    - mention scheduler system parameters in the  Schedulers  javadoc Alternative implementation to #4001. - Fixes to Javadoc warnings - Type arguments - Missing descriptions This PR updates the  Observable  method signatures to accept  ObservableConsumable   similar to how  Flowable  methods accept  Publisher .  The architecture switch may take a couple of more PRs. I ll try to limit the change amount in each. Update to  Completable  and  Single  to use  CompletableConsumable  and  SingleConsumable  as input. This PR fixes the hang in  Completable.concat(Observable)  and  Completable.merge(Observable)  mainly due to using  subscribe  instead of  unsafeSubscribe . The underlying problem was that  SafeSubscriber  unsubscribed the dowstream consumer which cancelled the outstanding elements of  range .  In addition  I ve upgraded the  concat(Observable)  to use an up-to-date concatenation algorithm and more compact memory footprint. - Moved the operators of Completable into their respective classes. Updated them to extend  Completable  directly. - Fixed a large set of inconsistend  Disposable  management among the  Observable  operators. This PR adds the  Single.fromEmitter  operator  driving a  SingleEmitter  instance similar to  Observable.fromEmitter  and  Completable.fromEmitter . This PR modifies the  CancellationException  message to include the operator name and source type.  Relate: #4756 This PR adds the  Maybe.flatMapSingleElement()  operator that returns a  Maybe  and completes if the source completes unlike  flatMapSingle  where the returned  Single  signals  NoSuchElementException .  Related #4857 TestObserver  replaced the upstream s  Disposable  with the disposed-sentinel when it got a terminal event (unlike  TestSubscriber ) and there seems to be a need for triggering  dispose  in some upstream even after that. This PR changes this behavior and also updates unit tests that expect  isDisposed()  true without actually calling  dispose() .  Related #4872 Single  operators factored out and made them extend  Single  directly. Added missing headers. This PR adds the missing calls to  RxJavaPlugins.onAssembly  on a few operators. This PR removes 3 kinds of operators that had no noticeable use bases or use cases on their own in the past years.  -  buffer(Supplier [  Supplier])  -  window(Supplier [  int])  -  onExceptionResumeNext(<source>)   Resolves #6554  Resolves #6555 The default periodic scheduling code accessed the current worker time as milliseconds which prevents running microsecond and nanosecond scale unit tests with TestScheduler as its internal nanosecond resolution time is always converted  losing precision.  This PR introduces the internal  SchedulePeriodicHelper  class  moves the default scheduling code into a static method and defines a  NowNanoSupplier  interface that is now implemented by TestSchedulerWorker to return the current nano time. The default  Worker.schedulePeriodically  delegates to this static method and given a  null   noNanoSupplier  the  Worker.now()  is converted to nanoseconds as usual.  Related: #4883 Relatively straightforward  although manual an tedious  refactoring of the Flowable operators. The number of files is this large because for consistency  the tests have been renamed as well. This PR adds dedicated operator implementations to    -  Flowable.reduce(seed  reducer)  (returns  Single )    -  Flowable.reduceWith(seedSupplier  reducer)   (returns  Single )    -  Observable.reduce(reducer)  (returns  Maybe )    -  Observable.reduce(seed  reducer)   (returns  Single ) and   -  Observable.reduceWith(seedSupplier  reducer)   (returns  Single )  instead of using  scan().takeLast(1)  ( Flowable.reduce(reducer)  already had a dedicated operator).  Comparison (Celeron 1005M  4GB RAM  Windows 7 x64  Java 8u112  JMH 1.16):  ![image](https://cloud.githubusercontent.com/assets/1269832/20644317/a411f9ba-b430-11e6-8fa7-0db5195f4ddd.png)  The new  ReducePerf  benchmark does a simple sum over a list of integer values. Unfortunately  this creates a lot of garbage for longer sequences (plus the CPU/RAM is not really suited for such benchmarks  the  flowMaybe  lines should be roughly the same since the code didn t change but there is a significant run-to-run variance). This PR fixes a few compilation errors that happen when the project is compiled with Java 8 target (Eclipse is even slower then).  Some covariant casts don t work in 8 and some type arguments inferred as Object get inferred as a more concrete type in 8. The slight drawback is that with the changes  Java 6 compilation needs extra suppressions. Some wording fixes in  Single   includes #6565. Java 13+ compilers generate a synthetic class for switch statements over enumerables now  so  Observable.class  (and a few others) now receive an  Observable$1.class  companion  which trips the no anonymous inner classes heuristic verification. This PR changes the respective unit test to filter out such classes in a heuristic manner too.  In addition  the  findSource  method has been moved into  TestHelper  for clarity and changed so that any capitalization of the  rxjava  host directory is accepted. The various  switchMap  operators did not report any accumulated exceptions to the global error handler when the sequence was cancelled (and thus the errors would never be delivered through the regular channels). This PR fixes the  Observable.repeatWhen  not completing properly if the handler completes. In addition  the  ObservableRedo  has been split to  ObservableRetryWhen  and  ObservableRepeatWhen  just like their  Flowable  counterpart and are now they use a less convoluted algorithm.  Related: #4909 Fix the wrong messages in  TestSubscriber  and  TestObserver .  Related: #4920. Both  Observable.timer()  and  Flowable.timer()  could report  IllegalStateException  because if the delayed task completed before the task s  Disposable  was set  the  setOnce  found a non-null  non-terminal reference already set.  Related: #4926. This PR adds the operator  cache()  to  Completable  to cache the terminal event of a  Completable  sequence.  I came across the need for this when [answering a question](http://stackoverflow.com/a/41241793/61158) where the intent of using  Completable  was to indicate an operation has completed but not actually trigger the operation whenever one subscribed.  A small drawback  just like with other  cache()  operators is that once connected  there is no way for cancel it from within the operator itself. Returning  Completable & Disposable  doesn t work because of the the type restriction of  RxJavaPlugins.onAssembly . There could be a  cache(Consumer<? super Disposable> onDispose)  overload or an example showing  source.ambWith(disposer).cache() . Flowable.generate()  and  Observable.generate()  lacked the safeguards that were present in 1.x. This adds those and adds extra state cleanup.  Related: #4931 This PR widens the  throws Exception  to  throws Throwable  on the callback interfaces of the  create  methods:  {Flowable|Observable|Maybe|Single|Completable}OnSubscribe . I was working on converting the [Monte Carlo PI benchmark](http://swave.io/usage/show-off/monte-carlo-pi.html) to RxJava 2 and it turned out I forgot to replenish the internal queue of  publish(Function)  in case the upstream was not sync-fuseable.  This PR fixes the replenishment problem for non-fused and async-fused sources by requesting after 75% consumption.  In addition  if an inner subscriber cancelled while it was at request 0  the other inner subscribers might not have resumed draining.  I ve also fixed two unit tests with wrong timeout unit of measure that randomly failed the tests on a slow machine or travis (#4902). This PR fixes the lack of dispose/cancel call towards the upstream in the timed+fallback  timeout  operator version.  In addition  the selector version received similar unit tests to ensure they work properly (they did).  Related: #4944. Few of the recent merges failed the  publishNoLeak  test because the GC apparently didn t finish in time. This PR increases the GC time to 250 milliseconds in those tests. This PR fixes several truncation bugs with the time and size-bound replay() operators and their hot class versions:  - Unexpected removal of the last item just added due to becoming out-of-date at the lowest time resolution  creating a hole in the linked chain and hanging the consumer. [Related failure](https://travis-ci.org/akarnokd/RxJava3_BuildMatrix/jobs/562038485#L791). - Incorrect size accounting upon removing old entries leading to more items dropped than expected.  *Sidenote: The operators and classes would benefit from a rewrite to improve on allocation and indirection. I wanted first to get the bugfixes and related tests done to have a known good baseline.* - Add missing header to 3 files   - Remove trailing whitespaces from recent additions The  sample()  operator in 1.x has been changed to always emit the very last buffered item before completion for [1.1.3](https://github.com/ReactiveX/RxJava/releases/tag/v1.1.3): [Discussion](https://github.com/ReactiveX/RxJava/issues/3657)  [PR](https://github.com/ReactiveX/RxJava/pull/3757).  This change has been forgotten in 2.x (because 2.x  sample()  was implemented several months earlier) but unlike 1.x  I don t want to break existing use cases  hence the introduction of 6 overloads (3 for each base type) that let s one define the  tail  behavior.  Note that the associated marble diagrams are inconsistent with the operators implemented  we need a new diagram where the timed-sample also emits the last value:  ![image](https://cloud.githubusercontent.com/assets/1269832/21642878/891ca42a-d285-11e6-876a-e613de2443db.png)  and one new diagram where the sampler-sample doesn t emit the last value:  ![image](https://cloud.githubusercontent.com/assets/1269832/21642917/b4dc257c-d285-11e6-8f25-707043957f26.png)  The default sampler-sample should use this and the  emitLast == true  version can use the current diagram.  (I don t have a Mac thus can t run OmniGraffle).  Related: #4952 This PR changes the  LambdaObserver  to not dispose the upstream when it receives a terminal event. The  LambdaSubscriber  has been previoulsy updated but apparently not synced.  Reported in #4956.  This PR fixes 2 unit test methods of  Flowable.ignoreElements()  as they were not actually testing the operator (discovered when the  Observable.ignoreElements()  initially failed after the patch to  LambdaObserver ). This PR fixes the double termination of  Single.takeUntil(Publisher)  when the  other  fires an item and then completes while ignoring the cancellation in between  trying to signal a  CancellationException  again which is routed to the  RxJavaPlugins.onError  and crashing on Android.  In addition  the  Maybe.takeUntil()  received a unit test verifying this doesn t also happen to it.  Related: #4961. - add  create(SyncOnSubscribe)  marble and update image dimensions   - add  create(AsyncOnSubscribe)  marble and update image dimensions   - add  switchIfEmpty()  marble   - add  toCompletable()  marble and update image dimensions This PR adds a new instance operator  strict() :  Ensures that the event flow between the upstream and downstream follow the Reactive-Streams 1.0 specification by honoring the 3 additional rules (which are omitted in standard operators due to performance reasons).   * §1.3: onNext should not be called concurrently until onSubscribe returns  * §2.3: onError or onComplete must not call cancel  * §3.9: negative requests should emit an onError(IllegalArgumentException)  In addition  if rule §2.12 (onSubscribe must be called at most once) is violated  the sequence is cancelled an onError(IllegalStateException) is emitted. Note that the Reactive-Streams specification doesn t have any sanction for violating §2.12.  The  strict()  operator also replaces the test-only operators that were supporting the Reactive-Streams TCKs already. This PR adds 3 new subject types:  SingleSubject    MaybeSubject  and  CompletableSubject . Their purpose is to provide an imperative way to multicast 0-1-error events as well as cache these events for later observers. They are thread-safe by design and there is no need for a serialized wrapper unlike the other  Subject s. This PR fixes the lack of null check on the result of the  combiner  function as well as fixes the lifecycle of the  FlowableWithLatestFrom  to avoid races with the  onSubscribe . Adding the backpressure support to  ReplaySubject  exposed a race condition around the  caughtUp  optimization.  The problem occurs when the source thread has caught up after  drain()  returned true but at the same time  a concurrent  drain()  starts running (due to a subscribe() process finishing or requesting on top of the previous  Long.MAX_VALUE ). This concurrent drain may think the replay hasn t started yet (by finding  rp.node  null) or seeing that the buffer has more elements (that may get double emitted).  The current solution is to remove this optimization until we come up with a correct optimization.  Related: #4028. This PR adds the  parallel()  method to  Flowable  which opens up a sub-DSL with parallel operations. (Note that only a few operators make sense in a parallel settings.)  This parallel sub-DSL is not limited to computation tasks as it allows specifying the parallelism and the  Scheduler  to run the parallel  rails . For example  you can have parallel downloads that block:     java Flowable.range(1  100) .parallel(10) .runOn(Schedulers.io()) .map(v -> httpClient.blockingGet( http://server/item/  + v)) .sequential() .observeOn(AndroidSchedulers.mainThread()) .subscribe(...) Follow up to #4058 . - update to JUnit 4.12 - remove deprecated use of  junit.framework.Assert  - update to Mockito 1.10.19 - Notification.accept() now uses switch (note that Jacoco can t properly cover enum switches as it only sees the default and impossible path is not taken). - in  Scheduler.schedulePeriodically   move the unsubscribe check after the action to prevent unnecessary schedule of the next iteration. - remove the inner counted loop from  SerializedObserver  as being unnecessary - increate timeout in  OperatorSwitchTest  - add  CompletableSubscriberTest  - extend  Scheduler    SerializedObserver Replacement for #3959. Some tests are sensitive to Travis hiccups. This adds more timeout to some and reduces heavyness on others. Some notable changes: - move fields to the beginning of a class - remove unnecessary modifiers and initializers - avoid creating objects to early - update most drain algorithm to use the (more modern)  while (e != r)  pattern - PMD has a few incorrect checks: complaining about a final local that gets used in an inner class - adding braces to ifs - documenting deliberately empty methods - fix internal field and method namings - delegate to  Exceptions.propagate First part of converting the OnSubscribe operators of  Observable  into direct implementors of  Observable  - saves allocation.  Don t worry about the unnecessary parenthesis  will be removed in a future PR. This change reduces the indirection and allocation count when using  map  or  filter . This PR adds 3 operator-fusion related interfaces:  -  QueueSubscription  will support fusion for  Flowable  - avoid creating queues  avoid cost of multiple enqueue-dequeue  reduce  request()  overhead -  QueueDisposable  will support fusion for  Observable  - avoid creating queues  avoid cost of multiple enqueue-dequeue -  ScalarCallable  - indicate a scalar constant source  In addition  ConditionalSubscriber  is marked and will be moved to the new package and its method renamed to  tryOnNext .  Unlike Reactor-Core (and Rsc)  there is no  Fuseable  marker interface. The ability of fusing is indicated by calling  onSubscribe  with the above  QueueX  enabled instances and then called back via  requestFusion . This allows having less duplicated code compared to Reactor/Rsc - at the cost of usually one extra field to store the  QueueX  value that may be null. The original behavior was somewhat inconsistent: if the target was null before the cancel/dispose  the method didn t return true indicating a successful swap for the current thread. Now that many  cancelled  flag has been removed  it has to consistently trigger the remaining cleanup actions. The  mergeWith  implementations   onError  (called by the main source) cancelled the main source instead of cancelling the other source. This mistake affects all 2 x 3 overloads of the operator.  Fixes #6597 This PR refactors  ConditionalSubscriber  and renames its method to  tryOnNext . In addition  two new abstract subscriber types were added:  BasicFuseableSubscriber  and  BasicFuseableConditionalSubscriber  to help writing operators that support fusion (queue and/or conditional). - Switch a few  Observable  operators to direct implementations (reduces allocation) - Update  map  to support operator fusion  there are no sources or consumer yet though. - Adjust  BasicFuseableX  to have different default conveniences - Modify  CompositeResource  to indicate success of the mutator methods - increase timeout of  FlowableOnBackpressureDropTest.testFixBackpressureWithBuffer This PR removes the  XResource  types and replaces them with  XDisposable  or  XSubscription  where necessary. This PR adjusts the PMD rules and fixes about 300 suggestions. Move into  TestUtil.checkUtilityClass() . This PR adds the missing  @Override  annotations and renames the  Observable  unit tests to conform a single name pattern. It should compare the TERMINATED instance with the value received from the blocking queue.  Fixes: #6576  Related: #6577 This PR fixes several truncation bugs with the time and size-bound replay() operators and their hot class versions:  - Unexpected removal of the last item just added due to becoming out-of-date at the lowest time resolution  creating a hole in the linked chain and hanging the consumer. [Related failure](https://travis-ci.org/akarnokd/RxJava3_BuildMatrix/jobs/562038485#L791). - Incorrect size accounting upon removing old entries leading to more items dropped than expected.  Related: #6582 - adds an operator  hide  to allow hiding and breaking optimizations - update  filter  to support fusions: queue and conditional -  range  now supports fusion: sync-queue and conditional -  fromArray  now supports fusion: sync-queue and conditional -  fromIterable  now supports fusion: sync-queue and conditional - enhanced  TestSubscriber  methods to return this - allows chaining the assertions - extended  TestSubscriber  to act as a consumer for queue-fusion - introduced  FlowableSource  as an intermediate type for operators: allows discovering the upstream in a standard way  allows the IDE to generate a constructor with a source value. - added  BasicQueueSubscription  that locks down unused  Queue  methods plus is a container for an atomic long value useful for request/wip tracking. This PR should fix some test timing out otherwise sensitive to thread hiccups. #4138 #4109 #4054 This PR adds unit tests for the new  RxJavaHooks  facility and fixes - Small mistakes in calling the right hook. - Dealing with constant  Completable  sources such as  complete()  and  never() : they executed the hook on class initialization so they couldn t be properly overridden later via an  onCreate  hook. (This could affect the other constants and will be addressed separately.) This concludes the architecture switch for 2.x. I forgot to invert the noHook -> useHook change. This PR enables operator fusion for scalar and knowingly single-element sources.  There are no fusion-consumers yet. This PR enables fusion-consumers such as  observeOn    flatMap    zip    concatMap   makes  UnicastProcessor  async-fuseable (used by  window )  fixes a few hidden issues with operators and has convenience renames of  SubscriptionHelper.validateX . In addition  it features the new  FlowableFlattenIterable  used by  flatMapIterable  and  concatMapIterable . This short PR enables operator fusion on  groupBy  and on the  doOnNext    doOnError    doOnComplete  and  doOnEach  operators.  In addition  it fixes small mistakes in  map  and  filter  and adds a method to  TestSubscriber  to print better fusion-assertion failure message. This PR fixes both  refCount  implementation to properly reset the source when the source terminates multiple consumers.  In the original  when the source terminated multiple sources  the first termination handler cleared the connection but since the  --subscriberCount  wasn t zero  the source was not reset. If this termination triggered a cancel on the second consumer  that path would not get the source reset either due to losing the connection object. Unfortunately  one can t just take the first termination handler and reset there immediately either because that could disrupt the termination of the rest of the consumers. It has to wait for the source to terminate all consumers or have the consumers cancel all.  This affects 2.x and will be backported in a separate PR.  Fixes #6608 This was due to bad rewrite of field updater to atomic reference. This updates the perf classes a bit and adds a blocking benchmark.  ![image](https://cloud.githubusercontent.com/assets/1269832/16580974/5ff08e54-42a7-11e6-889e-cfbb5c0bdecb.png) Fix many operators to emit the collected exception in case of a cancel/dispose call to the plugin error handler (i.e.  becoming undeliverable excptions).  In addition  the terminal event/error delivery has been unified in many other operators so that the terminal-indicator exception is never leaked.  There will be a separate PR about cleaning up the  addThrowable  usage cases (#6611).  Fixes: #6587 Optimize the reception  less allocation  less overhead in general.  Benchmark comparison (i7 4790  Windows 7 x64  Java 8u92)  ![image](https://cloud.githubusercontent.com/assets/1269832/16583761/065268fc-42b8-11e6-86a1-4ac91da80c97.png) This PR adds or updates places where the  Backpressure:  description was missing or outdated.  Unfortunately  GitHub has a hard limit on diff size per file so reviewers have to use their own local diff. This PR reduces the overhead with  collect    reduce  and  takeLast  and introduces the  DeferredScalarSubscriber  to support similar unbounded-in single-out scenarios.  Benchmark comparison (i7 4770K  Windows 7 x64  Java 8u92)  ![image](https://cloud.githubusercontent.com/assets/1269832/16669829/ba5541cc-4497-11e6-9827-097ac686bcf2.png)  Relative to each other: (each practically returning the very last value)  ![image](https://cloud.githubusercontent.com/assets/1269832/16669793/a35183fa-4497-11e6-9a93-36f7effe7e3b.png) This PR improves the coverage of  rx.Observable  methods plus  - fixes a javadoc issue  - fixes an enum-coverage anomaly in Notification (now it is simply biased towards onNext signals) - removes  equals()  from  TestException  as it caused anomalies with deduplication inside  CompositeException  - fixes 3 PMD rule violations (2 suppressed  1 corrected) -  timestamp  and  timeInterval  now use the  Schedulers.computation()  as the source for the current time instead of  Schedulers.immediate()  which can t be properly hooked. By default  they both return  System.currentTimeMillis() . These PR adds the remaining hooks which weren t even tested with the original RxJavaPlugins plus a full coverage of the RxJavaHooks itself.  This is a mandatory addition and 1.1.7 can t be released without it (i.e.  with an incomplete RxJavaHooks that is). I still forget about these sometimes. Started a syncing process between 1.x and 2.x operators (based on [this diff](https://gist.github.com/akarnokd/4a391527e099412cad87d3dffbfef762)). The first set is the addition of the eager version of  concat  and  concatMap . In addition  all of them get a  XDelayError  overloads as well. This PR adds a few operators and overloads from 1.x -  fromAsync  -  just  - 10 arguments -  distinctUntilChanged(BiPredicate<? super T  ? super T> comparer)  -  skip  timed - default scheduler -  take  timed - default scheduler -  toCompletable   In addition  this PR fixes the API of TestSubscriber by making the initial value primitive  long  and having 0 as no initial request instead of the trickery with  null . Don t worry about not all things tested in this PR  anything extra relative to 1.x will be covered after the sync. - More unit tests ported  -  TestObserver  cleanup and sync with  TestSubscriber   - fix travis to run with Java 7 instead of 8  - added AnimalSniffer  - cleaned up  combineLatest   introduced  combineLatestDelayError   - test names are as in 1.x  please don t complain about the  test  prefix in the method names! - add  groupJoin    join    onTerminateDetach  - fix missing cancellation in  FlowableFlattenIterable  - fix  fromIterable  error handling - added several unit test methods and classes from 1.x This PR fixes the incorrect request call inside  switchMap  when working with sync-fused sources.  Fixes: #6615 This PR fixes the  subscribeOn  operator to allow cancellation before the actual subscription to the source takes place - just like how 1.x works. This PR fixes the incorrect request call inside  switchMap  when working with sync-fused sources.  Fixes: #6615 This PR modifies the  PublishSubject  to fail fast if the child Subscriber can t keep up. Therefore  instead of some other operator failing somewhere downstream  the  MissingBackpressureException  now points to the  PublishSubject  instead.   In addition  there were complaints in #3850 that cross-unsubscription doesn t stop another Subscriber from receiving events if it comes after the unsubscribe() call in the dispatch loop. Since  PublishSubject  now tracks request - which is the main extra overhead - it is trivial to add the necessary eager check for the unsubscribed state.  Benchmark comparison (i7 4790  Windows 7 x64  Java 8u102)  ![image](https://cloud.githubusercontent.com/assets/1269832/17052414/a30acf84-4ffd-11e6-88ae-1fc5d28a6d12.png)  As expected  this adds some overhead although most noticeably for the mid-range only. Short-lived publishing is now slightly faster even.  Interestingly  many benchmarks behave oddly in these 1000s range - we could be hitting some JIT threshold. While in other benchmarks  the warmup iteration numbers keep increasing as JIT does its work but here  it starts out quite nicely then drops 25% and stays that way. I m on windows so JMH -perfasm doesn t work.  If this direction is accepted  I ll update  BehaviorSubject    timer()  and  interval()  do do the same tracking. This fixes the generics warnings in the new  Single.flatMapCompletable  unit tests. This PR refactors the package structure to match the group ID:  io.reactivex.rxjava3 . In addition  the base classes and interfaces now live in  io.reactivex.rxjava3.core .  In addition  the Reactive Streams dependency was bumped to 1.0.3-RC1 to verify the TCK changes. This PR adds a dedicated  concat  implementation that works with the source array. The main benefit is that there is no need to serialize emissions because the source array can t throw (unlike  concatMap  where there could be an onError from the main source while an inner source is running). Plus  there is a new  concatArrayDelayError  version. When the iterator was cast to  Disposable  and disposed  the subsequent  hasNext  would block indefinitely. That interface is not intended to be part of the public API and  Iterator  in general does not support any form of official cancellation (unlike Stream). This PR makes sure that if that dispose is called  it unblocks the iterator.  A separate PR will be posted for 2.x.  Related #6625 When the iterator was cast to  Disposable  and disposed  the subsequent  hasNext  would block indefinitely. That interface is not intended to be part of the public API and  Iterator  in general does not support any form of official cancellation (unlike Stream). This PR makes sure that if that dispose is called  it unblocks the iterator.  Resolves #6625 - rename  finallyDo  (deprecated in 1.x) to  doAfterTerminate  - upgrade sized  buffer()   fix backpressure bug - add post-complete helper methods - fix  toSingle  not complaining about an empty/longer source -  RxJavaPlugins  to reset the base-type lifecycle callbacks as well The  publishNoLeak  and  replayNoLeak  tests tend to fail because the GC/sleep time is not enough sometimes to cleanup memory. This PR adds a main test helper that loops at most a number of times and quits when the GC has apparently done its job. This PR fixes the issue with  refCount  not resetting the connection when the termination triggers cross-cancellation over it.  Fixes #6608  The fix is more involved than #6609 because how 2.x uses two  publish()  implementation internally due to bugfix #6505. The old/classic implementation does not fail #6608 but the newer implementation fails #6608. If the fix is applied unconditionally  the old/classic implementation fails an older unit test verifying an error allows reconnection. Therefore  the PR checks and applies the new code path only if  refCount  isn t talking to the classic publish implementation.  As a reminder #6609 for 3.x has a redesigned  Connectable  with a much more clearer reset semantics and thus the restructuring of the termination handling had no trouble passing the aforementioned error-allows-reconnect unit test. This PR upgrades to:  - Gradle 5.6 - TestNG 7.0.0 - Mockito 3.0.0 - JMH 1.21 - JMH plugin 0.5.0-rc-2 (required by Gradle 5.5+) - License 0.15.0 - Jacoco 0.8.4 - Guava 28  In addition  the  osgi  plugin has been deprecated in Gradle 5 and has been removed in Gradle 6  therefore a separate plugin called  bnd  is required to produce the necessary jar properties. (Also the MockitoJunitRunner has been moved to a new location  hence the package change.)  This Gradle version should support working on a Java 11 runtime when executing  gradlew build .  Note that this may require further  live  testing as the auto-release of snapshots as well as auto-release can t be properly tested offline. - Add  rebatchRequests  which delegates to  observeOn  with the help of an internal  ImmediateThinScheduler  that only executes tasks immediately. Still not planning to expose an immediate scheduler. - Fix  FlowableMapNotification  s type signature  no need to restrict it to return  Publisher<R>  but can go with  R  itself. - Make sure  flatMap  doesn t reorder scalars and elements of the same inner source. - Change parameter ordering on  mergeDelayError(Iterator)  overloads. Change the code in the  SchedulerPoolFactory  to use  System.getProperty  directly. Also fix property names to  rx3.  as now both v2 and v3 could run together.  Fixes #6636 - Rename  zipIterable  to  zip  - Remove  zip(ObservableSource<ObservableSource<T>>)  and  zip(Publisher<Publisher<T>>)  - Change the order of the  tillTheEnd  argument in  concatMapDelayError  and  concatMapEagerDelayError  to be consistent with other operators taking a  boolean  parameter before  prefetch / maxConcurrency .  Related: #6610 It had a bit of a cascading effect. This PR renames the internal  addThrowable  to  tryAddThrowable  and introduces the  tryAddThrowableOrReport  to perform the common reporting to the global error handler. Usage places have been re-evaluated and fixed if necessary.  In addition   null  exceptions have been made more uniform.  Resolves #6611 Related: #4280.  The  Exceptions.propagate  and  Exceptions.throwIfFatal  are too useful to be hidden in an internal package so this PR moves them into the public  io.reactivex.exceptions  package. The terminal atomics related to Throwable containers lives in the  ExceptionHelper  enum. The operator  Observable.concatMapEager  had a bad optimization targeting scalar and callable sources and emitted their values immediately even if it wasn t that particular source s turn for it.  The  Flowable  is not affected  added unit tests for both.  Reported in #4981. When  flatMap  and  zip  fuses its sources  it was possible one of the async source polls on another source which executed boundary-sensitive operators ( map    filter ) on the wrong thread.  For clarity  here is a diagram showing the execution flow of a classical and fused setup:  ![image](https://cloud.githubusercontent.com/assets/1269832/21883621/536a123c-d8b0-11e6-9a7a-b6deb2ffb26b.png)  In the classical flow  everything is push and when flatMap collects the available elements  all side-effects happened inside  map .  In the fused flow  there are no queues and the onNext call is an indication to  poll()  on the sources inside  flatMap  (or zip). If the first source triggers onNext  that source is correctly polled and  map  executes on the right thread. However  when the flatMap continues to collect other available elements  it polls on the other source and executes that  map  still on the first scheduler  despite that source having its own scheduler specified.  The solution is to mark  flatMap  and  zip  s inner consumer as boundary sensitive which prevents the fusion above since  map  is also marked as boundary sensitive.  Related: https://github.com/reactor/reactor-core/issues/342 This PR fixes  Observable.combineLatest  to be consistent with  Flowable.combineLatest  by not subscribing to additional input sources if the operator reached a terminal state due to a valueless source (that completes or errors). In addition  such early termination didn t properly cancel the other sources when  delayErrors == true .  I ve also extended the documentation on the overloads to warn about empty sources that will terminate the operator  even with  combineLatestDelayError   and thus subscription side-effects may not happen.  There is a related issue #4414 where the operator should fully consume each input source no matter what and terminate when all terminate. I m still considering what would be the best way to introduce this.  Reported in #4986 This PR updates the referenced marble diagrams to reflect the actual behavior and options with  sample .  New images:    -  sample(time  emitLast)   ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.emitlast.png)    -  sample(time  scheduler  emitLast)   ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.s.emitlast.png)    -  sample(other)  - the [original image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.o.png) indicated the emission of the last item which was not the case  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.o.nolast.png)    -  sample(other  emitLast)   ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.o.emitlast.png) The  flatMap  implementations always subscribed to the generated inner source even if there was an asynchronous cancel while the function was running. With typical functions  there is only a really tiny window inside function but some users tend to block/sleep in the function and when that returns  the  flatMap  operator is already cancelled.   If the generated inner source emitted an error disregarding its own cancellation signal (the  error()  operators do this)  those errors end up in the  RxJavaPlugins.onError  and crash the app (on Android).  This PR adjusts the  flatMap  implementations to check for the disposed/cancelled state before subscribing to the inner source. For  Observable  and  Flowable   this has practically no extra overhead as the add/remove already checks for the terminal state and can return a boolean for it. The rest require an explicit  isDisposed()  check. The logic inside the  Observable.takeLast(time)  was not using a fixed timestamp to compare against but one that could change between calls  resulting in items wrongly skipped from the accumulated buffer. The PR makes this timestamp limit fixed outside the drain loop.  The  Flowable  variant did not have the issue but both received the unit test verifying the correct behavior.  The same fix for 2.x will be posted separately.  Fixes: #6647 There was a logic error in the size+time bound  window  operator for when to close a window if timers are not restarted when the size-bound is hit.  Due to this bug  two tests were not receiving and thus accounting for empty windows that are happening when the size-bound is hit followed by the periodic time-bound hit.  2.x will be fixed in a separate PR.  Fixes #6651 The logic inside the  Observable.takeLast(time)  was not using a fixed timestamp to compare against but one that could change between calls  resulting in items wrongly skipped from the accumulated buffer. The PR makes this timestamp limit fixed outside the drain loop.  The  Flowable  variant did not have the issue but both received the unit test verifying the correct behavior.  Fixes: #6647 There was a logic error in the size+time bound  window  operator for when to close a window if timers are not restarted when the size-bound is hit.  Due to this bug  two tests were not receiving and thus accounting for empty windows that are happening when the size-bound is hit followed by the periodic time-bound hit.  Fixes #6651 Update the empty newline detection to ignore whitespace in otherwise empty subsequent lines. This PR fixes two issues:  - when the  Observable.groupBy  operator would abandon a newly created group before the group s only item was emitted  causing dataloss. - when the  groupBy  s value selector failed for a new group  thus the new group would never be emitted and report the failure.  It should fix the first test failure of #6663 but may not be the cause for the second. Add (hopefully) all remaining missing marble diagrams to  Single .  Resolves #5788  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatArrayEager.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.mergeDelayError.i.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.mergeDelayError.p.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.mergeDelayError.2.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.mergeDelayError.3.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.mergeDelayError.4.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.unsafeCreate.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.using.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.using.b.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.wrap.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.cache.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.cast.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delaySubscription.t.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delaySubscription.ts.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnEvent.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.blockingGet.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.lift.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.contains.f.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.contains.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.onErrorResumeWith.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.onTerminateDetach.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.retry.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.retry.f2.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.retry.n.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.retry.f.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.retry.nf.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.retryWhen.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.subscribe.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.subscribe.c.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.subscribe.cc.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.subscribe.c2.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.subscribeWith.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.takeUntil.c.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.takeUntil.s.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.takeUntil.p.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.timeout.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.timeout.s.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.timeout.b.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.timeout.sb.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.unsubscribeOn.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.test.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.test.b.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delaySubscription.p.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delaySubscription.o.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delaySubscription.s.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delaySubscription.c.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.dematerialize.png) Fix the case in  window(time)  variants where the timer thread is busy with window emission and the upstream terminates on some other thread  the window emission is interrupted.  ~~So instead of disposing the timer/worker right after the upstream termination  a  DISPOSE  message is queued up. Thus any ongoing drain loop from the timer thread can cleanup gracefully.~~  After some additional considerations  there is no need for  DISPOSE . The drain loop will take care of disposing the timer and the main downstream can simply be terminated.  The 2.x fix will be in a separate PR shortly.  Fixes #6672 When a fuseable source backed by an SpscLinkedArrayQueue is cancelled and cleared concurrently (i.e.  one thread clears while the other cancels the chain)  the  clear()  method could run concurrently and either crash with NPE or end up in an infinite loop due to corrupted queue state.  This PR fixes two kinds of mistakes leading to this scenario:  - Calling  clear()  from  cancel / dispose  when the output is fused. - Calling  clear()  from a fused drain loop when cancellation is detected.  When fused  similar to  poll()   calling  clear()  is the responsibility of the consumer and the producer side is not allowed to call them.  The bug affected the following operators: -  FlowableOnBackpressureBuffer  -  FlowableGroupBy  -  UnicastProcessor  -  UnicastSubject   Fixes #6673 ## Backport of #6676  When a fuseable source backed by an SpscLinkedArrayQueue is cancelled and cleared concurrently (i.e.  one thread clears while the other cancels the chain)  the  clear()  method could run concurrently and either crash with NPE or end up in an infinite loop due to corrupted queue state.  This PR fixes two kinds of mistakes leading to this scenario:  - Calling  clear()  from  cancel / dispose  when the output is fused. - Calling  clear()  from a fused drain loop when cancellation is detected.  When fused  similar to  poll()   calling  clear()  is the responsibility of the consumer and the producer side is not allowed to call them.  The bug affected the following operators: -  FlowableOnBackpressureBuffer  -  FlowableGroupBy  -  UnicastProcessor  -  UnicastSubject   Fixes #6673 Code in the  FlowableGroupByTest  [didn t compile on newer JDKs](https://travis-ci.org/akarnokd/RxJava3_BuildMatrix/jobs/599488054#L546) because of type inference changes between Java 6 and them. In Java 6  this       Flowable<Integer> source = ...     Flowable<X> result = source.groupBy(Functions.identity())   comes out as  X == GroupedFlowable<Object  Integer> . However  newer JDKs will propagate type arguments thus:      Flowable<Integer> source = ...     Flowable<Y> result = source.groupBy(Functions.identity())    Y == GroupedFlowable<Integer  Integer>  and mismatching with the rest of the types.  I chose an explicit  Integer  argument for clarity. Fix the case in  window(time)  variants where the timer thread is busy with window emission and the upstream terminates on some other thread  the window emission is interrupted.  The drain loop will take care of disposing the timer and the main downstream can simply be terminated.  Related #6674  Fixes #6672 This PR makes the  Disposable  returned by the  ExecutorScheduler.scheduleDirect()  report  isDisposed   true  if the task has actually finished  which should now be consistent with the  Worker  behavior of other schedulers.  Reported in #5004. This PR adds additional unit tests for the  parallel()  operators  plus:    - adds conditional fusion to  runOn    filter  and  map  operators   - exposes the  FlowableFlatMap  s internal  Subscriber  to be reused with  ParallelFlowable.flatMap    - uses the  FlowableConcatMap  s internal  Subscriber  to be reused with  ParallelFlowable.concatMap    - fix generics with  collect  and  reduce    - change queue overflow errors to  MissingBackpressureException    - make sure join-like operators don t emit the same upstream  Throwable  to the  RxJavaPlugins.onError  handler if all rails have the same error reference There was another cancel-clear race leading to NPE or infinite loop inside both  observeOn  implementations.  Related: #6676 Enabled some Javadoc validation and found a few mistakes. As far as I can tell  there is no  testUnhandledErrorIsDeliveredToThreadHandler  method or similar to reference there. Backport of #6708  ------  There was another cancel-clear race leading to NPE or infinite loop inside both observeOn implementations.  Related: #6676 After reaching the prefetch limit  the updated  consumed  counter was not written back so the processor stopped requesting more (consumed > limit).  Affects 2.x to. A separate PR will be posted for it.  Resolves #6713 After reaching the prefetch limit  the updated  consumed  counter was not written back so the processor stopped requesting more (consumed > limit).  Resolves #6713 This PR fixes the case when a call to request() prevented cancellation of the arbiter if the call never returned  thus locking out the drain loop from the cancellation call.  The PR makes sure  request()  is only called outside the guarded region.  1.x is not affected because unsubscription and requesting go on separate  channels .  The PR also fixes  FlowableRedo  by serializing the repeat signal  Processor . The  ExecutorScheduler  wrapper did not call the  RxJavaHooks.onScheduledAction()  to decorate actions sent to a custom scheduler. Fix a case when the  GroupedFlowable  is consumed by a  parallel()  in fusion mode causing the source to stop replenishing items from the upstream  hanging the whole sequence.   parallel()  was slightly different from the usual queue consumers because it checks for  isEmpty  before trying to  pull  for an item. This was necessary because the rails may not be ready for more and an eager  pull  to check for emptyness would lose that item. The replenishing was done in  GroupedFlowable.pull  but a call to  GroupedFlowable.isEmpty  would not replenish.  The fix is to have  isEmpty  replenish similar to when  poll  detects emptyness and replenishes.  Reported in https://github.com/reactor/reactor-core/issues/1959 ## Backport of #6719   Fix a case when the GroupedFlowable is consumed by a parallel() in fusion mode causing the source to stop replenishing items from the upstream  hanging the whole sequence.  parallel() was slightly different from the usual queue consumers because it checks for isEmpty before trying to pull for an item. This was necessary because the rails may not be ready for more and an eager pull to check for emptyness would lose that item. The replenishing was done in GroupedFlowable.pull but a call to GroupedFlowable.isEmpty would not replenish.  The fix is to have isEmpty replenish similar to when poll detects emptyness and replenishes.  Reported in reactor/reactor-core#1959 ## Backport of #6700  Update javadoc to reflect the eagerness property of observeOn in Flowable and Observable classes.  Related #6697 - Add missing explanation to  observeOn(Scheduler)  - Remove  <p> s that create javadoc empty-tag warnings. - Update  @see  to point to  delay s with  delayError  parameter. - Explain that  Schedulers.from  is eager too.  Related #6700 - Some  @see  should point to the other party (plain <->  DelayError ). - Add a few  @see  to the nearby operators. - Comments no longer apply in  BlockingXMostRecent  source code. - Add a comment from #6728 to  ActionDisposable .  Replaces #6728 Related #5806 ---- ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.zip.i.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.zip.n.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.zipArray.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.zipWith.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.contains.o.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.unsubscribeOn.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.onTerminateDetach.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.cast.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.lift.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doOnEvent.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delaySubscription.t.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delaySubscription.ts.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delaySubscription.p.png) Related #5788 -----  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.zip.i.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.zip.n.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.zipArray.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.zipWith.png) Use the suggested  verifyNoInteractions  instead of  verifyZeroInteractions . This PR changes the backpressure behavior of  Flowable.groupBy  to signal  MissingBackpressureException  instead of silently hanging if the produced groups are not ready to be accepted by the downstream.   This can happen if one  flatMap s a  groupBy  but there are more groups produced than the concurrency level of  flatMap . Since replenishment is tied to item consumption from the groups  not consuming them can result in none of the groups receiving any further items and the whole operator hangs.  The following changes have been applied:  - Removed the queue from the main operator since it will now try to emit directly and not buffer groups. - The main  Flowable   lacking a queue  no longer supports operator fusion. Tests checking this property have been removed as well. - When a group is drained  consumed items are replenished in batch if possible. Detecting a cancellation will also trigger a replenishment. - When a group is pulled (fusion mode)  now all  pull    isEmpty  and  clear  will trigger replenishment so that other groups can make progress too. - Unit tests have been modified to have large enough bufferSize/prefetch amounts to allow them to pass.  Fixes #6641 The default  Schedulers.from  implementation uses an eager approach to execute tasks on the underlying  Executor  which can lead to excessive thread occupation on its own  even if operators use buffering/prefetch of 1.  This PR introduces a new overload with a fairness option so that tasks are submitted to the  Executor  in a non-overlapping and FIFO manner one by one.  In addition  the scheduler retention tests have been cleaned up and reworked to not wait unnecessarily long for the GC to finish.  Related: #6696  #6697 This PR updates the 1.x  sample(time)  diagram to indicate the last value is emitted when the sequence completes. It is the same (style) as for 2.x:   Default scheduler: ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.emitlast.1x.png)  Custom scheduler: ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.s.emitlast.1x.png)  Related: #4952 This PR adds an  RxJavaPlugins  option  failOnNonBlockingScheduler  that triggers an  IllegalStateException  when the user tries to run a blocking method while the execution is on the  computation()  or  single()   Scheduler :      java Flowable.just(1) .subscribeOn(Schedulers.computation()) .map(v -> Flowable.just( query ).subscribeOn(Schedulers.io()).blockingFirst()) .doOnNext(v -> someAPI(v).subscribeOn(Schedulers.newThread()).blockingSubscribe())  .blockingFirst()       It is an optional setting  default off.  The check is done before going into an await method (and a few other types of blocking). Most blocking operators usually poll the status and try to avoid the actual blocking thus this shouldn t affect synchronous sequences that one extracts a value from.  Detection of a blocking-sensitive scheduler s thread is done by checking the current thread s class for implementing the  NonBlockingThread  marker interface (currently  internal ).  The  RxThreadFactory  has been updated to allow picking a default  Thread  implementation or a custom one for the  newThread() . Note that since #5002 you can create custom schedulers by providing a  ThreadFactory .  This works for RxJava s default schedulers but not for  AndroidSchedulers.mainThread()  where similar blocking should be avoided as well. For them  a plugin-callback action would be more suitable. ~~Question is how that callback should behave (throw  return false  should it be always executed or only when the flag is true).~~  My proposed solution is to have a plugin callback  RxJavaPlugins.setOnBeforeBlocking(BooleanSupplier)  that Android users can define the callback for:     java RxJavaPlugins.setOnBeforeBlocking(() -> Looper.myLooper() == Looper.getMainLooper()) RxJavaPlugins.setFailOnNonBlockingScheduler(true)       This callback is only executed if the  failOnNonBlockingScheduler  is set to true. Make the internal interface  DisposableContainer  public as it can be one safely.  (I ve seen some 3rd party usage in custom containers  this will make them now legit on 3.x.)  **Edit** Also [should resolve](https://travis-ci.org/ReactiveX/RxJava/builds/620175320#L219) the OSGi private reference warning.  Resolves #6742 This PR changes how  CompositeException.getCause  creates a cause exception on demand. In 1.x and 2.x  the code tried to link up the various inner exceptions via their  initCause   which was in on itself fishy as well as could lead to excessive memory usage.  Instead  the new code will present the inner exceptions as part of a formatted message  which in theory  should be still picked up by IDE exception listings and allow navigation:      Multiple exceptions (2) |-- io.reactivex.rxjava3.exceptions.TestException: ex3     at io.reactivex.rxjava3.exceptions.CompositeExceptionTest.nestedMultilineMessage(CompositeExceptionTest.java:341) |-- io.reactivex.rxjava3.exceptions.TestException: ex4     at io.reactivex.rxjava3.exceptions.CompositeExceptionTest.nestedMultilineMessage(CompositeExceptionTest.java:342)   |-- io.reactivex.rxjava3.exceptions.CompositeException: 2 exceptions occurred.        at io.reactivex.rxjava3.exceptions.CompositeExceptionTest.nestedMultilineMessage(CompositeExceptionTest.java:337)     |-- io.reactivex.rxjava3.exceptions.CompositeException.ExceptionOverview:          Multiple exceptions (2)         |-- io.reactivex.rxjava3.exceptions.TestException: ex1             at io.reactivex.rxjava3.exceptions.CompositeExceptionTest.nestedMultilineMessage(CompositeExceptionTest.java:335)         |-- io.reactivex.rxjava3.exceptions.TestException: ex2             at io.reactivex.rxjava3.exceptions.CompositeExceptionTest.nestedMultilineMessage(CompositeExceptionTest.java:336)      ![image](https://user-images.githubusercontent.com/1269832/70315342-a9308600-1819-11ea-81d2-b56694dbd9e8.png)  There are a few formatting conveniences: - If there is only one inner exception  the  CompositeException  s cause will be simply that exception. This can happen when the very same exception is aggregated into the composite and get deduplicated. - If an inner exception s message is multi-lined  the message and cause traces should be indented properly. - Reoccurring causes are not expanded over and over:      Multiple exceptions (2) |-- io.reactivex.rxjava3.exceptions.TestException: ex1     at io.reactivex.rxjava3.exceptions.CompositeExceptionTest.reoccurringException(CompositeExceptionTest.java:316)   |-- io.reactivex.rxjava3.exceptions.TestException: ex0       at io.reactivex.rxjava3.exceptions.CompositeExceptionTest.reoccurringException(CompositeExceptionTest.java:315) |-- io.reactivex.rxjava3.exceptions.TestException: ex2     at io.reactivex.rxjava3.exceptions.CompositeExceptionTest.reoccurringException(CompositeExceptionTest.java:319)   |-- io.reactivex.rxjava3.exceptions.TestException: ex1       at io.reactivex.rxjava3.exceptions.CompositeExceptionTest.reoccurringException(CompositeExceptionTest.java:316)       |-- (cause not expanded again) io.reactivex.rxjava3.exceptions.TestException: ex0      Currently  only the first line of the stacktraces are shown because it can get quite long (and thus memory consuming) to list them all. Maybe a system parameter can be introduced to control the verbosity.  Fixes #6747 Fixed a style mistake and wrong classes mentioned in the  Flowable.observeOn  docs.  In addition  I ve added explanation about it not preserving the request pattern across. When using iterable of sources  the initial array is the wrong type and causes  ArrayStoreException .  Unit tests were added to verify the other implementations.  Fixes #6753 This PR fixes the  Flowable.window  operator (with size and time boundaries) so that  - cancelling the inner windows allows cancelling the upstream once neither the main output nor other windows are being consumed further - ignoring a window still allows cancelling the upstream.  These fixes are necessary similar to how  groupBy  had to be updated in #6740.  The publisher-boundary and start-stop publisher boundary as well as the  Observable  variants will be updated in subsequent PRs due to the sheer number of changes. This PR fixes the  Observable.window  operator (with size and time boundaries) so that  - cancelling the inner windows allows cancelling the upstream once neither the main output nor other windows are being consumed further  - ignoring a window still allows cancelling the upstream.  Follow-up to #6758   The boundary and start-stop publisher boundarywill be updated in subsequent PRs.  In addition  the previous  WindowSubscribeIntercept  has been renamed to match the reactive type naming as well as removed the unnecessary serialization of the emission of window processors. This PR fixes the  window  operator (with boundary and start-end sources) so that  - cancelling the inner windows allows cancelling the upstream once neither the main output nor other windows are being consumed further  - ignoring a window still allows cancelling the upstream.  Follow-up to #6758 and #6761 This PR upgrades RxJava to use and compile with Java 8.  - Build target set to 8 - AnimalSniffer set to 8 - JavaDocs link to the official JDK set to 8 - Implemented operators:   -  Flowable.fromOptional    -  Flowable.fromCompletionStage    -  Flowable.fromStream  - Applied  @SafeVarargs  to many methods - Created marbles  Related #6695  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromOptional.f.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromCompletionStage.f.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromStream.f.png) This adds a dedicated implementation for zipping  Single s (adapted from  MaybeZipX ).  Routing the original  zip  through  Flowable  added the usually unwanted behavior of cancelling the sources if one of them reports a completion after a row has been consumed from all (when converted to  Flowable    SingleObserver.onSuccess  becomes  Subscriber.onNext  +  onComplete ). Since there is only  onSuccess  and  onError  in  Single   there is no need to dispose the sources once all signalled their only  onSuccess .  Related: #5024. This PR reintroduces the  OnErrorNotImplementedException  wrapper from 1.x and applies it to the  subscribe()  methods that don t define an  onError  handler.  The errors are still routed to the  RxJavaPlugins.onError  handler but now wrapped with  OnErrorNotImplementedException .  This should help with cases where the developer forgot to add the handler and distinguish such unhandled errors from other undeliverable errors due to lifecycle limitations. This PR adds an  onAssembly  hook for  ParallelFlowable  operators and adds the missing parameter validation to some parallel operators. - Update  README.md  and indicate Java 8 requirement. - Enable  @Nullable  to be put on type parameters and type uses. - Add links to components in various  package-info.java  documentations  for easier navigation in the JavaDocs summary. Add Java 8 interoperation methods to  Flowable : -  blockingStream  - essentially  blockingIterable  with close support -  concatMapStream  - map and concatenate streams -  flatMapStream  - map and concatenate streams  inherently same as  concatMapStream   Related #6776   Marbles:  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingStream.f.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingStream.fi.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapStream.f.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapStream.fi.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapStream.f.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapStream.fi.png) The interface was missing javadoc on its methods. This PR fixes both  Flowable.replay()  and  Observable.replay()  throwing a  NullPointerException  if the connection is disconnect before the upstream calls  onSubscribe  on the connection being established.   In practice  this requires an async cancellation to happen through  refCount().unsubscribeOn()  for example. The validation tests simulate this by not calling  onSubscribe  until the synchronous connect/disconnect happens.  Reported in #5060. Add  Disposables.fromAutoCloseable  and  Disposables.toAutoCloseable  methods. Improve JavaDocs styling.  Resolves #6772 Resolves #6777 1. When the project is checked out into a directory that is not exactly  */RxJava/  (i.e.   /RxJavaSomething/ ) the source-code locator in the unit tests failed with a  NullPointerException . The locator is now relaxed to expect  /RxJava  prefix. 2. Running the unit tests from IntelliJ 2017.1 EAP  the  ExceptionTests.testStackOverflowWouldOccur  failed with  AssertionError  because the final stack depth was exactly the constant value (800). The check now uses the correct  >=  as the dual of the recursion condition of  < . This PR makes sure the  Scheduler.Worker  is disposed only after    - disposing/cancelling the upstream    - emitting terminal events.  This may help with situations when the worker-dispose interrupts a thread that is blocked and the InterruptedException handler checks for the stream to be disposed so the exception can be safely ignored (and thus not end up in the RxJavaPlugins.onError handler to crash the app).  Related: #4863 Add the following Java 8 operators to various reactive base classes:  | Operator |  Maybe  |  Single  |  Completable  | |---|:---:|:---:|:---:| |  fromOptional  | ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png) | (1) | (2) | |  fromCompletionStage  | ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png) | ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png) | ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png) | |  mapOptional  | ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png) | ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png) | (3) | |  toCompletionStage  | ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png) | ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png) | (4) | |  toCompletionStage(T)  | ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png) | (5) | ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png) |  1. Should it be implemented as  Optional.empty() -> Single.error(new NoSuchElementException()) ? 2. No reason to implement. Always  Completable.complete() . 3. No value to map. 4. No value to emit thus it is better to ask the user for a completion value. 5. Never empty  no reason to implement.  Related #6776   Marbles:  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromOptional.m.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromCompletionStage.s.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromCompletionStage.c.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mapOptional.m.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mapOptional.s.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toCompletionStage.m.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toCompletionStage.mv.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toCompletionStage.s.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toCompletionStage.c.png) This PR clears up some javadocs and widens the  throws  on the various  Operator  interfaces:  - Link to  Integer.MAX_VALUE  and  Long.MAX_VALUE s. - Add links to types and  {@code TheType}  for other appearances. - Wrap event type indicators into  {@code }  tags. - Wrap boolean outcomes into  {@code }  tags. - Wrap null mentions into  {@code }  tags. - Apply nullability annotations. - Fix wording and copy-paste errors. This PR adds the  UndeliverableException  and  ProtocolViolationException . The former wraps exceptions that happen beyond the lifecycle of a flow and the latter is added to distinguish validation bugs.  The  RxJavaPlugins.onError  wraps errors into  UndeliverableException  unless  RxJavaPlugins.isBug()  returns true when the  Throwable  is relayed to the (default) handler.  Having the  UndeliverableException  should help with understanding the source of a crash and by having its own stack trace  help locating the offending positions (for example  a missed  isDisposed()  check in a 3rd party library). Looks like  create()  won t go away unless we get the IDE mark it someway  such as being deprecated.  This PR deprecates  create()  and adds  unsafeCreate  for internal use and deprecate-renames  fromEmitter  to  create(Action1  BackpressureMode) .  There was an earlier attempt at deprecating  create   #4253  but it was not followed up. This PR executes what I suggested in one of the [comments](https://github.com/ReactiveX/RxJava/pull/4253#issuecomment-235913860). This PR adds an ~~ assertAndConsume ~~  assertValuesAndClear  method to  TestSubscriber  to assert on value content and then clear the internal value list. This helps asserting on received values without the need to list all previously seen values in  assertValues .   On a sidenote   getOnNextEvents()  returns the internal list and one can call  clear()  on it. This PR updates  testNoBufferingOrBlockingOfSequence  with    - retry up to 3 times with an exponential backoff as the test is time sensitive and Travis CI load sensitive    - uses  Schedulers.single()  as the helper thread and manages resource cleanup properly    - both  Flowable  and  Observable  variants.  Update: Looks like  XFlatMapTest  is still flaky  added changes here to try fixing it as well. For performance reasons  the  scan  delayed the emission of accumulated items by one which worked well with sources that pushed new items frequently.   Unfortunately  if the source stopped emitting (without completion)  the very last accumulated item was stuck and no way to get it out of  scan . I considered this type of use being rare but apparently I was wrong.  The PR changes  scan  to emit accumulated items  including the initial seed  as soon as there is request for it. The operator now uses a stable-prefetch queue-drain found throughout other operators such as  observeOn .   Remark: sadly  request trickery such as capturing the first  request  call  emitting the seed and then requesting n - 1 doesn t work because if the  request()  call itself happens from another thread and the source is empty  the  onNext  and  onComplete  could run concurrently.  Reported in #5089 This PR allows to fix the same-pool deadlock that may happen with  create()  (formerly  fromEmitter ) and  subscribeOn  as  subscribeOn  by default schedules the requests behind a running emitter and thus the internal request amount may not get updated  leading to unnecessary dataloss.  See #4735.  In the update  if  subscribeOn  detects its upstream is  OnSubscribeCreate   it no longer reschedules requests for it. For other  non-immediate cases  a new overload allows specifying the  requestOn  parameter that should be  false  if there is a  create(Action1  BackpressureStrategy)  in the sequence upstream. This PR adds specialized operators for merging  Single  and  Completable  sources:    -  Single.merge(Observable<Single<T>>)  +  maxConcurrency  overload   -  Single.mergeDelayError(Observable<Single<T>>)  +  maxConcurrency  overload   -  Observable.flatMapSingle(Func1<T  Single<R>>)  +  delayErrors  +  delayErrors  maxConcurrency  overloads   -  Observable.flatMapCompletable(Func1<T  Completable>)  +  delayErrors  +  delayErrors  maxConcurrency  overloads  All of these return  Observable .  This replaces #4988.  *Sidenote: for some time now  contributor(s) from certain party tend to contribute low quality or inadequate code and  disappear  pretty quickly. I can t be sure this is just lazyness or a deliberate and elaborate scheme to extract free work out of me for their own party s benefit but it is annoying as hell.* This PR fixes  Maybe.concatX  subscribing to the next source when the downstream cancelled the  Flowable  sequence from its  onNext . This resulted in executing the subscription side-effects of the source to be immediately cancelled when it called  onSubscribe  on concat s  MaybeObserver .  In addition  tests were added to verify the other types don t have this kind of a problem.  Related #5100. Move  DisposableObserver  to  io.reactivex.observers  + some documentation.  Related: #4082. This PR adds the Javadoc to the  Flowable  plus removes some deprecated or unnecessary operator overloads.  By the sheer amount of documentation   Flowable  can t be reviewed on GitHub. Once the CI passes  I ll merge it and people who wish to review it can immediately start a PR to fix any documentation mistakes. This PR fixes the issue reported on [StackOverflow](http://stackoverflow.com/questions/42279543/exception-is-not-propagated-to-onerror-when-thrown-from-doonsubscribe) where crashing the lambda in  Flowable.doOnSubscribe  calls the  RxJavaPlugins.onError   which crashes the app and prevents calling the  EmptySubscription.error  on Android. (Desktop prints to the console and delivers the error normally.)  The bug was present in the  Flowable    Observable  and  Completable . All 5 base types received the respective unit test to ensure correct behavior. This PR fixes the operators  Flowable.window(time  size)  and  Observable.window(time  size)  to complete the current window if the time elapses before the size limit is reached.  Reported in #5104. This PR performs the changes suggested in #5110.   - Introduce  FlowableSubscriber  with extra textual specification on its relaxed nature  -  Flowable.subscribe(Subscriber)  checks for  FlowableSubscriber  and if not found  it wraps the incoming RS  Subscriber  into a  StrictSubscriber  that follows the RS spec to the letter at any cost.  - Introduce  Flowable.subscribe(FlowableSubscribe)  that most internal operators will use  - Change  AbstractFlowableWithUpstream  to accept  Flowable  as a source  update operators  - Some operators were useful with raw  Publisher  input  these were duplicated on their outer containing type but use the same internal  FlowableSubscriber   - Removed  cheat  from the TCK tests  adjusted timeout on  delay   - Replaced most  implements Subscriber  with  implements FlowableSubscriber   - Replaced most  new Subscriber  with  new FlowableSubscriber  in tests  the rest is required for testing the strictness itself.  -  strict()  is now an identity operator with suggested scheduled removal.  Performance impact estimation  - Most primary use of a  Flowable  should go through  subscribe(FlowableSubscribe)  and thus no overhead change. - Where the API mandated  Publisher  as input  providing a  Flowable  will have an  instanceof  check at subscription time and routed to  subscribe(FlowableSubscriber) if the consumer is part of RxJava 2 itself. This PR adds Javadoc to  Observable  by mainly copying and adjusting  Flowable  s documentation.  In addition  the method set was synced as well and placeholders added for unported 1.x operators.  The drill is the same as before: after CI  I merge this and reviewers can post PRs with necessary fixes. This PR adds javadoc to the  Single  methods  fixes a few API differences. This PR mainly adds  Scheduler:  descriptions to  Completable   removes deprecated operators or unnecessary aliases. In addition  blocking methods now are named  blockingAwait  and  blockingGet . Notable changes: - Replace the use of  Runnable  in the base reactive types to  Action  whose  run  method can throw a checked exception. - Fix javadoc referencing 1.x types no longer available. - The  switchMap  operator has been enhanced to support delaying errors. - Update  concat(Iterable)  to use  concatMapDelayError  because Iterable can t throw just anytime but on the boundary  reducing the per-element overhead. -  FlowableEmitter  has been enhanced with a  serialize()  method that serializes calls to  onXXX  methods. - Factored out  FlowableEmitter.Cancellable  into  io.reactivex.functions  as it will be used by the other base reactive types with their  XEmitter  implementations. - Added  AtomicThrowable  with convenience methods that use  ExceptionHelper  s terminal atomics with  Throwable s. This PR factors out the anonymous inner classes from the base reactive types and introduces the appropriate classes and methods in  *Helper  enums. Notable changes: - Implement the  onBackpressureBuffer  with overflow strategy  change the strategy to plain enum. - Additional unit tests from 1.x - Implement  publish(Function)  properly to support latecommers. - Split  FlowableRedo  into  FlowableRetryWhen  and  FlowableRepeatWhen . - Make sure  take(0)  still triggers upstream subscription that is immediately cancelled. Notable changes: - implemented  withLatestFrom  with multiple other sources (both  Flowable  and  Observable ) - added missing  Exceptions.throwIfFatal()  after catching throwables - added  SequentialDisposable  and replaced internal use of  SerialDisposable  with it - added  package-info.java  to public packages - added javadoc to some interfaces and methods - removed  @Experimental  tags and set those methods to  @since 2.0  - added  HalfSerializer  to deal with single onNext and multiple onError/onComplete callers Most varargs places now have  @SafeVarargs  so there is no need for  @SuppressWarnings( unchecked ) . Some non-test classes need still updating though. This PR cleans up the main classes:  - Add missing  @NonNull  annotations - Add missing  @SafeVarargs  annotations - Add validator code that scans the sources to verify the annotations are present - Remove unnecessary  @SuppressWarnings  annotations - Fix a few type arguments.  Related #6766 - Improve validation code and extend them to other classes/sources. - Add  @NonNull  annotations - Add  @SafeVarargs  annotations - Add  @CheckReturnValue  annotations - Add more  @BackpressureSupport  &  @SchedulerSupport  annotations. - Add backpressure and scheduler descriptions in  ParallelFlowable  - Remove now unnecessary  @SuppressWarnings( unchecked )  - Fix wording in some javadocs - Move  toFunction  nullcheck into the caller method so the validation refers to the proper parameter name - Use diamond arguments where possible - Remove unused type arguments. Add the following Java 8 operators to  Observable :  -  fromOptional  -  fromCompletionStage  -  fromStream  -  firstStage  -  firstOrErrorStage  -  singeStage  -  singleOrErrorStage  -  lastStage  -  lastOrErrorStage  -  blockingStream  -  mapOptional  -  collect  -  concatMapStream  /  flatMapStream   In addition  some validators received reporting improvements (such as using   at   so the IDE can jump to the exact line of the issue). Consequently  all local variable misnaming of  UnicastSubject up  and  UnicastProcessor us  have been fixed as well.  Related #6776 Add Java 8 operators to the  ParallelFlowable  class:  -  mapOptional  + 2 -  flatMapStream  + 1 -  collect   Also for symmetry  the  flatMapIterable  operator has also been added.  Cleanups: - Add missing  @since  tags  unify tag location. - Use diamond in parallel classes. - Fix error messages in the parallel-try operators. - Improve validation messages with   at   entries so the IDE can navigate to the problematic line. - Add some unit tests to improve coverage of some existing parallel operators. This PR removes the  Try  and  Optional  classes and (re)introduces  Notification<T> .  There are several ways to implement it. This PR uses the abstract class + private subclasses approach that saves on instance size.  Related discussion: #4365. This PR removes the  BlockingFlowable  and  BlockingObservable  classes and moves the blocking operators into the respective reactive classes and names prefixed with  blocking .  In addition  many of the mentions of  Flowable  has been replaced with  Observable  in  Observable .  Related: #4366. Make  offer  throw a  NullPointerException  immediately instead of turning it into an error signal. In addition  have  MulticastProcessor.offer  throw an  IllegalStateException  if called when the processor is in fusion mode.  Resolves #6794 The underlying  blockingIterable  already supported the custom prefetch overload and this PR exposes it as a new  blockingForEach  overload.  In addition  the Javadocs incorrectly stated  blockingForEach  operated in an unbounded-in fashion. It uses the usual stable-prefetch with 75% re-request amount.  Resolves #6784 - Add missing  Exceptions.throwIfFatal  calls in  catch (Throwable   blocks. - Add validator that checks for the existence of these  throwIfFatal    wrapOrThrow  or  fail  calls. - Fix  AutoCloseableDisposable  to use  wrapOrThrow  like the other  Disposable  wrapper implementations.  Resolves #6796 - Use diamond where possible - Remove type arguments where they can be now inferred under Java 8 - Fix spelling errors - Remove unnecessary  throws  declarations Notable changes: - renamed and added safe  create  support to  Observable    Single  and  Completable  - added some javadoc - added  test()  method to  Single  and  Completable  - factored out  ErrorMode  into  internal.util  (used by various  concat  operators) Notable changes: - use JMH 1.13 - fix javadoc generator exclude pattern - add javadoc to many components - remove  Observers  and  Subscribers  - all their function is available via subscribe() and/or by implementing the abstract  XObserver / XSubscriber  provided - remove  Schedulers.immediate()  - remove  Single.subscribe(Subscriber)    Single.subscribe(Observer)    Completable.subscribe(Subscriber)  and  Completable.subscribe(Observer)  - remove  CompletableSerializedObserver  and  SingleSerializedObserver  and their parent package - implement  Single.takeUntil    Single.flatMapCompletable  - update the time-shift handling in the default  Scheduler.schedulePeriodically()  to match 1.x - fix  Single.subscribeOn  disposable management - renamed  Subject.hasSubscribers  to  Subject.hasObservers Add -  Maybe.flattenStreamAsFlowable  -  Maybe.flattenStreamAsObservable  -  Single.flattenStreamAsFlowable  -  Single.flattenStreamAsObservable   Related #6776  (In addition  adjust the validators to appreciate the new patterns.)  Marbles:  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flattenStreamAsFlowable.m.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flattenStreamAsObservable.m.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flattenStreamAsFlowable.s.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flattenStreamAsObservable.s.png) This PR unifies the Javadoc style of the  Flowable  type: - Mention of  Flowable  has to be  {@code Flowable}  - First mention of a set of types has to be  {@link TheType}  - Subsequent mention of a set of types has to be  {@code TheType}  - Some keywords and method names have to be  {@code methodName}   In addition   JavadocWording  has been modified to detect an additional set of wrong typename use. Improve the JavaDocs of  Completable  by - Using  {@link}  and  {@code}  tags - Adding  @throws  regarding parameter validation - Fix wording of some operators - Use  {@link} s and  {@code}  tags - Fix some wording and copy-paste mistakes - Add  @throws  about argument validation throwing  NullPointerException s and  IllegalArgumentException s JUnit 4.13 deprecated the use of  ExpectedException  in favor of  assertThrows . Those overloads were only applying  subscribeOn  with no other benefits.  Resolves: #6811 Improve the javadocs by: - Adding  {@code}  and  {@link}  tags - Fixed wording and copy-paste mistakes - Added  @throws  for the parameter validation exceptions The outer  onError  did not cancel the inner sources. The  Observable  variant works correctly but both received an unit test to verify the behavior.  2.x will be fixed in a separate PR.  Related #6825 The outer  onError  did not cancel the inner sources. The  Observable  variant works correctly but both received an unit test to verify the behavior.  Fixes: #6825 Improve the Javadoc of  Observable : - Use  {@code  and  {@link}  tags uniformly. - Improve wording of many operators. - Add  @throws  declaration for validation exceptions. - Add missing or incorrect  requireNonNull  usages. - Have  skipLast  and  takeLast  throw  IllegalArgumentException  instead of  IndexOutOfBoundsException . - Improve the various validator tests to detect more cases. - Change argument names from  prefetch  to the more appropriate  bufferSize . - Add missing  @throws  documentation - Fix wording and style of  Flowable  javadocs - Fix documentation style of many files - Improve the validator test to detect more patterns -  skip  now rejects negative amounts with  IllegalArgumentException Remove the  concatMapIterable(Function  int)  overload as there is no buffering involved with the operator.  Resolves #6828. The operator missed a rename with 2.x to match the  combineLatestArray  variant.  Resolves #6820 Related #6832 Annotate type argument use with  @NonNull .  Resolves #6766 Notable changes: - Implement  concatEager  and its variants - Implement  onTerminateDetach  - Implement  distinctUntilChanged(BiPredicate)  - Replace  EmptyDisposable.INSTANCE  with  Disposables.empty()  due to clash with fusion (sending an INSTANCE tells a fusion-enabled source to not expect onNext values yet the test still send those - this was a problem with EmptySubscription.INSTANCE a while back too). Also added javadoc warning about its use - add  ObservableScalarXMap  optimization to  Observable.xMap(Function)  and their operator s  subscribeActual  - Make  ObservableJust   ScalarCallable  and sync-fuseable with  ScalarDisposable  (similar to  Flowable.just() ) - Make  Observable.bufferSize()  public for convenience. - Fix  flatMap  fused  Callable  handling - Renamed  Objects  to  ObjectHelper  to avoid accidental bad imports of  java.util.Objects  of Java 8. - Reword sentences with  modifies  and  instructs . - Reword  the source X  to  the current X . - Reword a couple of other operator sentences.  Related #6819  Resolves #6821 It was always very peculiar to let only checked exceptions resumed.  Resolves #6842 Simplify the wording of  @return  in JavaDocs.  Resolves #6834 Make method argument naming consistent between the base reactive classes  adjust some of the naming for all.  In addition  the null-check was missing from  blockingMostRecent .  Resolves #6832   The utility program has to be run manually to list the inconsistencies. The remaining inconsistency is due to  merge  because its argument is  sources  for  Flowable / Observable  but  source  for  Single / Maybe  nested. Update the  OperatorMatrixGenerator  to add anchors and links to notes about why operators are not present in one or another class.  https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix  Some operators are missing and will be added as part of #6852.  Resolves #6855. This PR adds a test that verifies standard operator methods use base interfaces as their input and lambdas capable of returning base types do as well. Consequently  it fixes two declarations of  Flowable.buffer  having the wrong input type.  Basically  detect the following declarations:     java // direct use of the class  should be Publisher     public void method1(Flowable<?> f)  // lambda returns the class  should return a Publisher     public void method2(Callable<Flowable<?>> c)  // The inner Publisher emits the class  should emit Publisher     public void method3(Supplier<Publisher<Flowable<?>>> c)  // Direct use of the class as array type  should be Publisher[]     public void method4(Flowable<?>[] array)  // Lambda returns an array of the class  should return Publisher[]     public void method5(Callable<Flowable<?>[]> c)  // The inner Publisher emits an array of the class  should emit Publisher[]     public void method6(Callable<Publisher<Flowable<?>[]>> c) Added the last missing  @throws  tag to methods and one missing  @NonNull  annotation.  I included a small program that will list JavaDocs without  @throws  for future use.  Resolves #6829 Add the missing  blockingSubscribe  methods to  Maybe    Single  and  Completable  for symmetry with  Flowable  and  Observable .  Usually we d like to avoid blocking but now that Project Loom (preview) transparently turns latch-based awaiting into suspension inside Virtual Threads  they will act as free interop operators for exiting the reactive world into the continuation world.  Related: #6852  Marbles:  #### Maybe  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.blockingSubscribe.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.blockingSubscribe.c.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.blockingSubscribe.cc.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.blockingSubscribe.cca.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.blockingSubscribe.o.png)  #### Single  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.blockingSubscribe.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.blockingSubscribe.c.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.blockingSubscribe.cc.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.blockingSubscribe.o.png)  #### Completable  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingSubscribe.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingSubscribe.a.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingSubscribe.ac.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingSubscribe.o.png) Add many missing and replace incorrect marble diagrams in  Maybe .  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.create.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.defer.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.error.f.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromAction.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromRunnable.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromCallable.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromFuture.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromFuture.t.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromSingle.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromCompletable.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.i.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.p.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.pn.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeArray.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeArrayDelayError.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeDelayError.i.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeDelayError.p.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeDelayError.pn.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.2.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.3.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.4.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeDelayError.2.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeDelayError.3.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeDelayError.4.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timer.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timer.s.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.sequenceEqual.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.sequenceEqual.f.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.unsafeCreate.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.using.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.using.b.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.wrap.png) Add the  onErrorComplete()  and  onErrorComplete(Predicate)  operators to the remaining base classes.  Also created the missing marble for  Maybe.onErrorComplete  + 1.  Related #6852  #5806   ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.onErrorComplete.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.onErrorComplete.f.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.onErrorComplete.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.onErrorComplete.f.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.onErrorComplete.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.onErrorComplete.f.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.onErrorComplete.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.onErrorComplete.f.png) This PR adds the missing  Completable.onErrorResumeWith  present in the rest of the base classes.  Also marbles for  Maybe.onErrorResumeNext  and  Maybe.onErrorResumeWith  have been updated.  Related #6852  #5806  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onErrorResumeWith.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.onErrorResumeNext.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.onErrorResumeWith.png) retryUntil  was missing from  Single  and  Completable .  Added marble for  Maybe  as well.  Related #6852  #5806  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retryUntil.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.retryUntil.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.retryUntil.png) Add the missing  switchOnNext  and  switchOnNextDelayError  operators  which are essentially delegated to the respective  Flowable::switchMapX  operators with identity mapping.  Related #6852  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.switchOnNext.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.switchOnNextDelayError.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.switchOnNext.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.switchOnNextDelayError.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.switchOnNext.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.switchOnNextDelayError.png) Add the  dematerialize  operator to  Maybe  to be in sync with the other classes.  Related #6852   ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.dematerialize.png) Add a cross section of  from  operators (![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png) [ fromAction ](https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#fromAction) ..  fromSingle ) :  Operator | F | O | M | S | C | -|-|-|-|-|-| <a name= fromAction ></a> fromAction |![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png)|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png)|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png)|![absent](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_off.png) <sup title= Never empty. >([23](#notes-23))</sup>|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png)| <a name= fromCompletable ></a> fromCompletable |![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png)|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png)|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png)|![absent](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_off.png) <sup title= Always error. >([72](#notes-72))</sup>|![absent](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_off.png) <sup title= Use wrap(). >([73](#notes-73))</sup>| <a name= fromMaybe ></a> fromMaybe |![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png)|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png)|![absent](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_off.png) <sup title= Use wrap(). >([73](#notes-73))</sup>|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png)|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png)| <a name= fromObservable ></a> fromObservable |![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png)|![absent](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_off.png) <sup title= Use wrap(). >([73](#notes-73))</sup>|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png)|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png)|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png)| <a name= fromPublisher ></a> fromPublisher |![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png)|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png)|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png)|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png)|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png)| <a name= fromRunnable ></a> fromRunnable |![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png)|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png)|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png)|![absent](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_off.png) <sup title= Never empty. >([23](#notes-23))</sup>|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png)| <a name= fromSingle ></a> fromSingle |![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png)|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png)|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png)|![absent](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_off.png) <sup title= Use wrap(). >([73](#notes-73))</sup>|![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png)|  Related #6852   ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromAction.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromCompletable.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromMaybe.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromObservable.buffer.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromObservable.latest.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromObservable.drop.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromObservable.error.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromObservable.missing.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromRunnable.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromSingle.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.fromAction.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.fromCompletable.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.fromMaybe.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.fromRunnable.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.fromSingle.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromPublisher.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromObservable.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.fromMaybe.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.fromMaybe.v.png) Add  timeInterval  and  timestamp  operators  (4 overloads each). to  Maybe  and  Single .  Related #6852   ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeInterval.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeInterval.s.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timestamp.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timestamp.s.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.timeInterval.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.timeInterval.s.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.timestamp.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.timestamp.s.png) Add  toFuture  to  Maybe  and  Completable .  Related #6852   ![image](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/Maybe.toFuture.png) ![image](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/Completable.toFuture.png) Add  ofType  to  Single  already available to the other non-empty base types.  Related #6852   ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.ofType.png)  In addition  diagrams for  Maybe.filter  and  Maybe.ofType  have been updated:  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.filter.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.ofType.png)  Related: #5806 Add the  doOnLifecycle  operator to the remaining classes.  Related #6852   ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doOnLifecycle.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnLifecycle.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnLifecycle.png) Notable changes: - Introduce  Emitter<T>  as a base interface for  FlowableEmitter  and  ObservableEmitter   use it for the  generate()  operators to be the push surface. - Hide fusion-related methods in  TestSubscriber  and  TestObserver   remove  test()  method overload from the base reactive classes  introduce  SubscriberFusion  and  ObserverFusion  helper in the test source set - Enable fusion on  Observable.range() . - Move  Observer -related tests into the  observers  test package. Add the following operator aliases:  -  Maybe.concatMapCompletable  -  Maybe.concatMapSingle  -  Single.concatMapCompletable  -  Single.concatMap  -  Single.concatMapMaybe   Related #6852   ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatMapCompletable.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatMapSingle.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatMapCompletable.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatMap.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatMapMaybe.png)  In addition  some missing or wrong  Maybe  marbles have been fixed:  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatMap.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapCompletable3.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapSingle3.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapSingleElement.png) Notable changes: - delete  concat  5-9 arguments  use  concat(just(...))  or  concatArray(...)  instead - delete  withLatestFrom  5-8 arguments - rename  merge(Publisher...)  into  mergeArray(Publisher...)  to disambiguate - rename  merge(int  int  Publisher...)  into  mergeArray(int  int  Publisher...)  to disambiguate - delete  merge(int  Publisher...)  overload - rename  mergeDelayError(Publisher...)  into  mergeArrayDelayError(Publisher...)  to disambiguate - rename  mergeDelayError(int  int  Publisher...)  into  mergeArrayDelayError(int  int  Publisher...)  to disambiguate - delete  mergeDelayError(int  Publisher...)  overload - delete  takeLatestBuffer  overloads Add the following concat kind of operators:  -  Maybe.concatArrayEagerDelayError  -  Maybe.concatDelayError(Publisher  int)  -  Single.concatArrayDelayError  -  Single.concatArrayEagerDelayError  -  Single.concatDelayError  + 2 -  Completable.concatArrayDelayError  -  Completable.concatDelayError  + 2  Related #6852   ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatArrayEagerDelayError.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatDelayError.pn.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatArrayDelayError.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatArrayEagerDelayError.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatDelayError.i.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatDelayError.p.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatDelayError.pn.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concatArrayDelayError.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concatDelayError.i.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concatDelayError.p.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concatDelayError.pn.png)  In addition  the  Maybe.concatDelayError(Publisher)  marble has been fixed:  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatDelayError3.i.png) Notable changes: - renamed  amb(sources...)  to  ambArray(sources...)  to be consistent with the naming of other operators with varargs input - Renamed some other varargs operators ot  xArray  to be consistent - Added  RxJavaPlugins.onAssembly()  to operators  note that no other infrastructure (such as  enableAssemblyTracking  was added  companion libraries may later utilize these hooks to inject the necessary wrapper classes. - Extended  RxJavaPlugins.onAssembly()  to support  ConnectableX  operators - Renamed  FlowProcessor  into  FlowableProcessor  to avoid future confusion with JDK 9 s  Flow.Processor  - Removed common value extraction methods from  Subject  and  FlowableProcessor  and left them in the implementations - Made common terminal state checking methods of  Subject  and  FlowableProcessor  as abstract since all subtypes can implement them reasonably - fixed copy-paste errors in javadocs  such as wrong class named  referencing non-existent backpressure Changes: - fix spelling mistakes - more consistent parameter naming scheme based on #1353 (but incomplete  RC2) - fix bugs due to wrong variable naming - compact logic expressions - fix  Completable.doAfterTerminate  not called the right time -  onErrorReturnValue  renamed to  onErrorReturnItem   @DavidMGross once this PR has been merged  it would be great you submitted one that has  //TODO  markers on those lines that need attention. The naming scheme you suggested doesn t come intuitively to me so I may skip many of them without the markers. This PR adds the  subscribeWith  methods to the base reactive types to mainly help with the 1.x to 2.x changeover as 2.x  subscribe(Subscriber)  return void instead of the resource/cancellation/unsubscription type  Disposable . See the javadocs and the unit test for example use.  Related: #4400 The new tests revealed some bugs (nothing major). - updated  Single.cache()  to be lock-free  to allocate less and work properly - added test coverage to some classes - remove unused internal  EmptyObserver  - update  PublishSubject  to support cross-cancellation - update  TestHelper.race  to use the current thread for one of the tasks Single  was missing the  mergeArray  and  mergeArrayDelayError  operators already present in the other classes.  Related #6852  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.mergeArray.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.mergeArrayDelayError.png) The operator was available in all other classes.  Related #6852   ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.sequenceEqual.png) - Remove unused code - Improve coverage of  Single    Completable  and  Observable  - Fix minor bugs in operators Add missing ( ![add](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png) )  startWith  overloads   source \ other | F | O | M | S | C | --|--|--|--|--|--| Flowable | ![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png) | ![absent](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_off.png) | ![add](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png) | ![add](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png) | ![add](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png) Observable | ![absent](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_off.png) | ![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png)| ![add](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png) | ![add](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png) | ![add](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png) Maybe | ![add](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png) | ![add](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png) | ![add](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png) | ![add](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png) | ![add](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png) Single | ![add](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png) | ![add](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png) | ![add](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png) | ![add](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png) | ![add](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png) Completable | ![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png) | ![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png) | ![add](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png) | ![add](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_half.png) | ![present](https://raw.github.com/wiki/ReactiveX/RxJava/images/checkmark_on.png)  Related #6852  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.startWith.m.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.startWith.s.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.startWith.c.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.startWith.m.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.startWith.s.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.startWith.c.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.startWith.p.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.startWith.o.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.startWith.m.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.startWith.s.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.startWith.c.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.startWith.p.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.startWith.o.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.startWith.m.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.startWith.s.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.startWith.c.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.startWith.m.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.startWith.s.png) The operators were already available elsewhere.  Related #6852  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onErrorReturn.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onErrorReturnItem.png)  In addition  the  Maybe  variants have received updated marbles as well:  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.onErrorReturn.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.onErrorReturnItem.png)  Related #5806 Add the final missing method   safeSubscribe  to  Maybe    Single  &  Completable .  Resolves #6852 Many  Single  and  Maybe  operators delegate to  Flowable  operators. This PR makes sure they use the most appropriate ones since there are  Single - and  Maybe -specific operators on  Flowable  for some time now.  Some concatenating non-delayed Single operators now use the  Flowable.concatMapSingleDelayError(Functions.identity()  false)  because an array or  Iterable  of  Single s can t just throw anytime like a  Publisher<Single<T>>  s  Publisher  could  hence a delay-error until boundary mode works the same but without the extra coordination of the more general  Publisher  variant.  Resolves #6865   Completable  didn t have any delegation required changing. Resolves #6872  Also added 2 diagrams missing  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapMaybe.o.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapMaybeDelayError.o.png)  and fixed 1 diagram wrongly exported  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concatArrayDelayError.png) Reenable the  XFlatMapTest.maybeSingle  and make sure all flatMap variants behave the same when the flow is cancelled/disposed while the mapper function is executing  thus the returned inner source doesn t get subscribed to at all.  Resolves #6892  While adding the extra tests  I noticed two  flatMap  variant is missing from  Single :  - A combiner of the original and inner success item:  flatMap(Function<T  Single<U>>  BiFunction<T  U  R>)  - A notification-type mapper:  flatMap(Function<T  Single<R>>  Function<Throwable  Single<R>>)   ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMap.combiner.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMap.notification.png)  Lastly  the same combiner variant for  Maybe  received a marble diagram too:  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMap.combiner.png)  Related #5806 - Add tests - fix mistakes in  TestObserver  - Combine  DisposableHelper  and its inner  Disposed  enum - Compact  NotificationLite  and its inner  Complete  enum - Fix NPE in  ListCompositeDisposable  constructor - Fix  DeferredScalarObserver  fusion and state management - Turned a few empty enums into classes with private constructor: coverage can t cover them 100% otherwise. These empty enums have a constructor in their bytecode which never gets called and thus there s always 10 instructions / 2 method calls missing. - Removed  TestObserver.awaitDone()   one should always await with timeout If a group is cancelled with unconsumed item in its buffer  the operator stopped requesting more thus hanging other groups.  The fix is to count how many items are still in the buffer upon cancellation  and issue a request for them for the parent.  Fixes #6889 If a group is cancelled with unconsumed item in its buffer  the operator stopped requesting more thus hanging other groups. In 3.x the operator was somewhat strenghtened for this case except one case when the cancellation happens outside the drain loop.  The fix is to invoke  drain()  from cancel for it to have the cleanup and replenishment happen.  Fixes #6889 Resolves #5806   ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.ambWith.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.blockingGet.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.blockingGet.v.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.cache.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.compose.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatWith.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.count.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/MAybe.defaultIfEmpty.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delay.p.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delay.t.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delay.tb.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delay.ts.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delay.tsb.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doAfterSuccess.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doAfterTerminate.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doFinally.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doOnDispose.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doOnSubscribe.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doOnTerminate.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapObservable.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapPublisher.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.isEmpty.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeWith.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.repeat.n.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.repeat.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.repeatUntil.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.repeatWhen.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.retry.f.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.retry.g.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.retry.n.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.retry.nf.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.retry.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.retryWhen.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.switchIfEmpty.m.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.switchIfEmpty.s.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.takeUntil.m.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.takeUntil.p.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.m.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.mm.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.p.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.pm.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.t.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.tm.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.ts.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.tsm.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.to.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.toFlowable.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.toObservable.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.toSingle.png) Flowable    Observable    Maybe  and  Single  now have a  concatEagerDelayError   delegating to the appropriate  concatMapEagerDelayError  operator.  In addition   Maybe  and  Single  received an overload  concatEager(Iterable  int)  to expose the  maxConcurrency  option already present in the rest of the types.  Note that  Completable.concatEagerDelayError  is essentially the same as  mergeDelayError  because there are no items to keep emitting in order.  Resolves #6880  The  Flowable  and  Observable  variant of  concatEager  also received fresh marble diagrams. (Related #5813)  #### Flowable  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEager.i.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEager.in.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEager.p.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEager.pn.png)  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEagerDelayError.i.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEagerDelayError.in.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEagerDelayError.p.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEagerDelayError.pn.png)  ----  #### Observable  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEager.i.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEager.in.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEager.o.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEager.on.png)  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEagerDelayError.i.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEagerDelayError.in.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEagerDelayError.o.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEagerDelayError.on.png)  ----  #### Maybe  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEager.in.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEager.pn.png)  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEagerDelayError.i.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEagerDelayError.in.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEagerDelayError.p.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEagerDelayError.pn.png)  ----  #### Single  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatEager.in.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatEager.pn.png)  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatEagerDelayError.i.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatEagerDelayError.in.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatEagerDelayError.p.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatEagerDelayError.pn.png) Cleanup and coverage improvements.  ~~(Still many operators to review in  flowables  and  observables .)~~ This PR fixes  Observable.combineLatest  to dispose the sources outside the serialization loop  just like  Flowable.combineLatest  does. This allows cancellation even if the serialization loop is busy/blocking inside an  onNext  emission.  In addition  a unit test was added to  Flowable.combineLatest  as well.  Reported in #5111. There was an unnecessary  active.lazySet(null)  which prevented cancellation of the inner source under some circumstances.  More specifically  when one thread issued a  cancel   the cancelled flag was set  then another thread in  drain  would loop around  see the  cancelled  flag and clear the reference. Back in the cancelling thread  the  disposeInner  would only see  null  and do nothing.  Observable.switchMap did not have this mistake. Both received unit tests to verify the correct behavior.  2.x will be fixed in a separate PR.  Resolves #6914 Benchmark the overhead of the strict/interop mode.  i5 6440HQ  Windows 10 x64  Java 8u121  ![image](https://cloud.githubusercontent.com/assets/1269832/23092637/ce9f343c-f5cf-11e6-868b-e24ff6fc2b43.png)  The numbers are consistent with my expectations  this mobile processor is roughly equivalent to i7 4770 desktop where the cost model is: 1 atomic increment per item equals to roughly 130 Mops/s upper limit  2 atomic increment per item is roughly 60 Mops/s upper limit. Since the interop mode requires at minimum two atomic increments  54 Mops/s is a reasonable value to get. Disposing a  replay() -based connectable should reset the operator to its fresh state. This was supposed to happen but the relevant code changes were not enabled. The PR fixes this for both  Flowable  and  Observable -based implementations.  The  publish -based connectables work as intended.  Fixes #6920 This PR adds the  sequentialDelayError  operator to  ParallelFlowable  that allows awaiting all  rails  in a parallel flow to terminate normally or with the (composite) exception of the failed rail(s).  To enable this  the  Flowable.parallel()  operator s behavior regarding rail cancellation had to be changed. In v2.0.5 if any of the rails cancelled (maybe due to a failure  maybe due to an end consumer cancelling the entire parallel flow) the input  Flowable  was cancelled.   This PR alters this by requiring all rails to cancel before cancelling the input  Flowable . The change permits one or multiple rails to fail and let others progress in case the new  sequentialDelayError  is applied as a terminal operator. The original  sequential()  operator still cancels all rails if one of them fails (triggering the cancellation of the input  Flowable ).  Note that this change may still drop and never process elements in the internal queues of the operators in the parallel flow (because the parallel processing is not implemented with work-stealing that could pick up elements from a dead queue). In order to get as many elements processed as possible  it is recommended to reduce the default prefetch on the  runOn  operator to a reasonable tradeoff value (between throughput and fault tolerance).  **Edit**  Updated the PR to make sure  parallel()  ignores cancelled rails when it dispatches items.  Related: #5108. Queued up scalar values were not counted as completed  thus the subsequent sources where not subscribed to to fill up the allowed concurrency level.  Fixes #6945 These tests tend to fail more often with JDK 9 Target 9 builds (but all the others are fine).  Note that an overarching flakyness plugin could hide many of the legitimately incorrect behavior tested via races. Fatal exceptions may be lost with scheduled direct & scheduled periodic direct tasks because  FutureTask  simply treats them as exceptional outcomes. For regular tasks  [ScheduledRunnable](https://github.com/ReactiveX/RxJava/blob/3.x/src/main/java/io/reactivex/rxjava3/internal/schedulers/ScheduledRunnable.java#L67) already avoids rethrowing fatal errors as it would go nowhere.  This PR adds this behavior to the direct runnable tasks.  Resolves #6954 Adds the new system property  rx3.scheduler.drift-tolerance-unit  to allow specifying a more fine-grained tolerance amount.  Resolves #6968 When a group is evicted  the group is synchronously  onComplete d during an  onNext . If a cancellation happened during this time (for example  when a  publish  cancels its upstream because its output completes)  the cancellation would unconditionally decrement the group counter even though the  groups  map had no longer the group (because it was evicted before). Then once the eviction logic finishes  it decremented the group counter again  leading to invalid internal state and hangs.  The fix is to only decrement if there was a group actually removed from the map.  Fixes #6974 This PR fixes three additional race conditions from https://github.com/ReactiveX/RxJava/issues/6974#issuecomment-626319431  1. When a cancellation arrived asynchronously to a group  the drain loop quit and left unconsumed items in the queue and thus prevented the replenishment from the main upstream. **Fix:** change the drain loop to always clean & replenish upon seeing a canceled state.  2. When a cancellation was detected just after the drain loop has polled from the queue  that polled item was ignored and not replenished. **Fix:** Include the non-empty polled item in the replenishment count upon cancellation.  3. When a cancellation happened concurrently with an eviction  both could end up decrementing the group counter into an invalid (negative) number  preventing the operator to function properly. **Fix:** make sure group removal accounting happens at most once.  Fixes: #6974 This PR disables the async fusion capability of the groups emitted by  Flowable.groupBy  as it appears to lead to hangs due to cancellation and/or lack of requests in certain async scenarios.  By disabling fusion  the groups will manage the items they queue and cancellation will (hopefully) properly trigger replenishment requests for the unclaimed items.  This is more of a workaround than a comprehensible fix for the underlying issues. The main problem is that with  groupBy  and backpressure  each group itself and the items passing through them now count as **resources** and Reactive Streams can t cope well with items requiring their own lifecycle.  Related: #6982 This PR fixes the two cases from https://github.com/ReactiveX/RxJava/issues/6982#issuecomment-630290658  ### Case 1: completions missed  When the upstream completed and some groups were waiting in the eviction queue  the eviction queue was cleared without completing those groups. Since they were no longer in the main map  those groups never completed and downstream operators relying on all groups completing (i.e.  flatMap) would never complete.  The fix is to call  completeEvictions  upon upstream termination.  ### Case 2: no replenisment on evicted groups  When an eviction happens  the groups get completed. However  unlike with the non-evicting case  a group completion no longer implies the upstream has completed. Consequently  the evicted groups emitted their items but never issued a replenishment for them  hanging the still-alive main operator.  The fix is to replenish emitted (and polled) counts whenever the group detects a completion. (Errors still imply the main operator has terminated so no need to replenish then.)   Resolves #6982 These tests can fail with  MissingBackpressureException  because groups may not complete fast enough so  flatMap  can request more groups in time. This doesn t happen consistently but could fail the test on CI. The workaround is to allow any termination  not just normal completion. The reasoning is that the aim of the tests were to verify the operator doesn t hang.  The underlying complication is that whenever there is an item replenishment  any subsequent item can result in a fresh group being created. If the concurrency level of  flatMap  is not high enough  this will result in a MBE and the sequence terminates. This PR adds coverage to some low-coverage classes and removes unused code.   In addition  the  XFlatMapTest  now retries each test up to 3 times with exponential backoff since they are the most sensitive to Travis CI fluctuations. - open up  verifyPositive  as protected for validation convenience in subclasses - improve size and state handling of  DeferredScalarSubscription  - enable async-fusion on  AsyncSubject  and  AsyncProcessor   compact the classes - **behavior change**  AsyncX.hasValue()  returns false until the terminal state has been reached - compact the classes  PublishSubject    PublishProcessor    BehaviorSubject    BehaviorProcessor    ReplaySubject  and  ReplayProcessor  - enable async-fusion on  UnicastSubject   compact the class - rename  BaseXQueueDisposable  to  BasicXQueueDisposable  to match  BasicXQueueSubscription  - introduce  DeferredScalarDisposable   refactor  DeferredScalarObserver  - adjust tests that asserted on the former parameter names - subjects and processors can now be created with newing up their constructor:  new PublishSubject<>()   there is no mandatory shared state between the  Observer  part and the  Observable  part because both are now stateless on their own. This PR rewords the Javadoc of  Flowable.flatMap()  overloads to correctly express their behavior regarding backpressure towards their upstream. In 2.x  only  merge()  operators are unbounded-in by default   flatMap s are by default bounded by  bufferSize()  or the  maxConcurrency  parameter.  In addition  one of the  flatMap  overload still had  resultSelector  instead of the common  combiner  parameter name. As far as I know  there are no language-specific libraries targeting 2.x yet where in the language the actual parameter names are also part of the signature and changing them counts as an incompatible change.  Related #5126. This PR fixes the lack of eager cancellation when flatmapping sources and not stopping the upstream if the inner source fails.  Unit tests were added to verify  Single  (in case it receives a dedicated implementation one day as currently it delegates to  Flowable )   Flowable  and  Observable .  Reported in #5132. Adjust the  repeatWhen  and  retryWhen  signatures to accept  Publisher<?>  on  Single  and  Completable   matching  Flowable  s signature.  Reported in #5135. This PR adds the method  withTag  to the  TestBaseConsumer  that allows setting a textual tag which is then appended to the assertion failure s message:      Failure message (latch = 1  values = 0  errors = 0  completions = 0  tag = x: 5  y: 7)      Use case  for example  is to add the parameters of the current flow to help identify what settings caused the failure. This comes up with unit tests that have some form of (nested) loop(s) to verify multiple parameter ranges. (It is often much easier than trying to work out JUnit rules and such.) The timed versions of  Flowable.replay()    ReplayProcessor    Observable.replay()  and  ReplaySubject  all replay outdated items to new subscribers and through the  getValues()  and  size()  state-peeking methods  similar to issue #3917 resolved via #4023.  The fix includes a node-walk for new subscribers that skips old entries. Some unit tests weren t logically considering the emission pattern (i.e.  items timed out shouldn t appear) and have been fixed as well.  Reported in #5139. The timed  replay()  operator didn t terminate a late subscriber if all the items timed out in the meantime.  Related: #5139. Java 9 has changed its overload resolution algorithm and things that resolved unambiguously in Java 8 no longer resolve:     java Flowable<? extends T> source = ...  source.subscribe(new FlowableSubscriber<T>() { ... })       With the code above  javac 8  Eclipse and IntelliJ 2017 EAP picks  Flowable.subscribe(FlowableSubscriber<? super T> s)  as expected. However  javac 9 finds it ambiguous with  Flowable.subscribe(Subscriber<? super T> s)  despite IntelliJ 2017 EAP not indicating any error and still jumping to the right method via CTRL+Click.  The problem may come from the  ? extends T  part of the declaration. Having just  Flowable<T>  compiles properly with javac9.  Luckily  we don t need  ? extends T  and this PR changes the internal signatures of the affected components. Fix the case when an (async) fused  filter - map - filter  chain does not handle the null indicator in its conditional path inside  map .  Fixes #7039 Disposing the main output of the  Observable.window  operator did not properly propagate the dispose call under certain circumstances  such as no current active window or the window(s) were abandoned immediately.  Fixes #7048 -  onErrorResumeNext  marble now indicates the error and function-callback nature:  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeNext.v3.png)  -  onErrorResumeWith  marble now has the correct name (and retains the original onErrorResumeNext style):  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeWith.v3.png)  - Address now deprecated API usage of Mockito. - Few other style corrections.  Fixes #7050 This PR enhances the timeout detection and reporting of the  TestSubscriber / TestObserver  base class  BaseTestConsumer :     -  awaitCount(int atLeast [  Runnable waitStrategy [  timeout]]) : wait until at least the given amount of onNext events have been observed or the upstream terminated.   - Enhance  awaitX  methods to set a  timeout  flag.   - Show the  timeout!  string in the assertion failures set by the  awaitX  methods.   - Show the  disposed!  string in the assertion failures if the consumer has been cancelled/disposed.   -  assertTimeout  and  assertNoTimeout  to assert explicitly after an  awaitX  method.   -  isTimeout  and  clearTimeout  to check and clear the flag status.  In addition  the internal array that collects the items has been replaced with a new custom  List  implementation:  VolatileSizeArrayList  that makes sure  size()  is a volatile read and happens before the committing the size in another thread due to  add() . (In theory  one shouldn t cast  values()  unconditionally to  ArrayList  anyway.) The  ConsumerSingleObserver  didn t report  isDisposed  consistently with its state.  Reported in #5160. The  LambdaObserver  didn t cancel the upstream when its  onSubscribe  and  onNext  callbacks crashed. Also reported on the mailing list:  > Dave Smith: When I am using an operator in Observable that calls subscribe (forEach as a example) and the onNext function throws an Exception the underlying class (LambdaObserver) marks the subscription disposed but does not notify upstream that is is disposed. What is the reason for this?  The  LambdaSubscriber  was working correctly. Both received unit tests to ensure the correct behavior. - Fix the wording across the base types. - Add missing error handling section. - Point to  fromAction  in  fromRunnable  docs. There was a missing  upstream.cancel()  for when the overflow happens.  Fixes #7081 There was a missing upstream.cancel() for when the overflow happens.  Fixes #7081 In  concatMap   there is a shortcut for when the mapped  Flowable  turns out to be a scalar value and thus the full subscription process can be skipped. This used a so-called weak subscription that expected non-concurrent requesting to emits its single value.  Unfortunately  there is a race condition for when the downstream requests exactly when this weak subscription is activated  resulting in either double emission or no emission at all. The fix is to do the proper  compareAndSet  to ensure the emission happens exactly once.  Discovered while running the build matrix and a test failed with:      io.reactivex.rxjava3.internal.operators.flowable.FlowableConcatMapSchedulerTest > boundaryFusionDelayError FAILED     java.lang.AssertionError: Error(s) present: [io.reactivex.rxjava3.exceptions.MissingBackpressureException: Queue is full?!] (latch = 0  values = 1  errors = 1  completions = 0)         at io.reactivex.rxjava3.observers.BaseTestConsumer.fail(BaseTestConsumer.java:125)         at io.reactivex.rxjava3.observers.BaseTestConsumer.assertNoErrors(BaseTestConsumer.java:212)         at io.reactivex.rxjava3.observers.BaseTestConsumer.assertResult(BaseTestConsumer.java:525)         at io.reactivex.rxjava3.internal.operators.flowable.FlowableConcatMapSchedulerTest.boundaryFusionDelayError(FlowableConcatMapSchedulerTest.java:94)         Caused by:         io.reactivex.rxjava3.exceptions.MissingBackpressureException: Queue is full?!             at io.reactivex.rxjava3.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.onNext(FlowableObserveOn.java:114)             at io.reactivex.rxjava3.internal.operators.flowable.FlowableConcatMapScheduler$ConcatMapDelayed.innerNext(FlowableConcatMapScheduler.java:396)             at io.reactivex.rxjava3.internal.operators.flowable.FlowableConcatMap$ConcatMapInner.onNext(FlowableConcatMap.java:559)             at io.reactivex.rxjava3.internal.operators.flowable.FlowableConcatMap$WeakScalarSubscription.request(FlowableConcatMap.java:343)             at io.reactivex.rxjava3.internal.subscriptions.SubscriptionArbiter.setSubscription(SubscriptionArbiter.java:99)             at io.reactivex.rxjava3.internal.operators.flowable.FlowableConcatMapScheduler$ConcatMapDelayed.run(FlowableConcatMapScheduler.java:531)             at io.reactivex.rxjava3.internal.schedulers.ImmediateThinScheduler$ImmediateThinWorker.schedule(ImmediateThinScheduler.java:89)             at io.reactivex.rxjava3.internal.operators.flowable.FlowableConcatMapScheduler$ConcatMapDelayed.schedule(FlowableConcatMapScheduler.java:431)             at io.reactivex.rxjava3.internal.operators.flowable.FlowableConcatMapScheduler$BaseConcatMapSubscriber.onNext(FlowableConcatMapScheduler.java:156)             at io.reactivex.rxjava3.internal.operators.flowable.FlowableMap$MapSubscriber.onNext(FlowableMap.java:69)             at io.reactivex.rxjava3.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runSync(FlowableObserveOn.java:337)             at io.reactivex.rxjava3.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run(FlowableObserveOn.java:174)             at io.reactivex.rxjava3.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:65)             at io.reactivex.rxjava3.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:56)             at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)             at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)             at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)             at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)             at java.base/java.lang.Thread.run(Thread.java:832) This PR fixes some private field accessor problems introduced by #5174 as well as a couple of generics warnings.  Note that in IntelliJ  there is a J2ME inspection for private access checks between parent and inner classes. In  concatMap   there is a shortcut for when the mapped  Flowable  turns out to be a scalar value and thus the full subscription process can be skipped. This used a so-called weak subscription that expected non-concurrent requesting to emits its single value.  Unfortunately  there is a race condition for when the downstream requests exactly when this weak subscription is activated  resulting in either double emission or no emission at all. The fix is to do the proper  compareAndSet  to ensure the emission happens exactly once.  Backport of #7089 Improves the wording the  scan  operators. GitHub Action  actions/checkout@v2  downloads the files to a directory that doesn t appear to include the   rxjava  name anymore and makes the source code tests unable to read the files.  This changes the locator to try for  src/main/java  in each parent directory relative to where the class files are located via  getResource .  This is a preparation in case we have to bail from Travis CI. They now have a pricing model that in theory would be free for open source projects still but who knows in practice as there are hops apparently to get projects recognized as such. Following up on a [Gitter.im report](https://gitter.im/ReactiveX/RxJava?at=5fc4fc11226043667c24e3b6)  the  onComplete / onError  methods of the  using  operators were calling cancel/dispose on the upstream even though there is no reason to do such a thing and is also not allowed by Reactive Streams rule [2.3](https://github.com/reactive-streams/reactive-streams-jvm#2.3).  The original code s side-effect was that given a nested  using  pair  an  onComplete / onError  of the inner sequence would trigger a cancellation and resource release in the outer before/while the  onComplete / onError  signals propagate downstream and return back on a non-eager setting. This PR updates  Observable.replay()  and  Flowable.replay()  **for 2.x** to not leak items between reconnections when run with  .refCount() . The  replay()  operator is designed to hold onto the buffer even after its completion so late subscribers can still receive the cached data. Only a new  connect()  clears this data which may or may not happen. Since  refCount  ensures that there won t be any latecommers to an already completed connection (because it also drops its current subscribers on termination or when reaching zero)  the  replay()  can be reset to an empty state.  Related: #5172  #5181. - Add javadoc to  AsyncEmitter.BackpressureMode  (#4199) - Deprecate  Observable.fromAsync   add  Observable.fromEmitter  instead (#4255) - Add  Completable.fromEmitter()  (#4356) - Add missing placeholder  @since  tags - Fix some generics error  RxJavaHooks  - Add race helper to  TestUtil  - Fix javadoc warnings This PR improves the error messages reported in the  TestObserver  and  TestSubscriber :  -  assertValue(Predicate)  now shows the value that didn t pass the predicate -  assertValueAt(index  T) :   - If the index is out of range  the message includes the valid range   - the message now includes the index argument where the failure happened -  assertValueAt(index  Predicate) :   - If the index is out of range  the message includes the valid range   - shows the value at index that didn t pass the predicate   - the message now includes the index argument where the failure happened -  assertError(Predicate)  is now worded to indicate the exception did not pass the predicate  In addition  the verification tests for the error messages were not actually testing the error message with  assertThrows  and have been updated.  Resolves #7125 This PR adds an unit test that scans the compiled .class files for anonymous inner classes naming (i.e.  dollar sign followed by a number). Since all the main  test and perf classes end up in the same place  the test has exceptions for file names containing  Perf  or  Test .  The PR also fixes a few Checkstyle warnings from #5177 and fixes a couple classes from tests that don t have the word  Test  in their name and thus were detected. Improve the styling and wording of  ConnectableObservable  and  ConnectableFlowable . - Improve coverage of internal classes - Turn more empty enums into classes with private constructors - Fix  Single.subscribeOn  and  Completable.subscribeOn  disposable management. - Create a compact  FutureSubscriber  and  FutureObserver  classes  drop their former enums - Deprecate  Disposables.from  methods  add  Disposables.fromX  methods where X = argument type - Fix error management in  Completable.mergeX  operators. - Remove unused methods from internal classes Update the marble diagrams in  Flowable  and  Observable   indicating cancellation of the non-winners.  Resolves #6995  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.amb.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.ambArray.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.ambWith.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.amb.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.ambArray.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.ambWith.png) The Javadocs of  take  still referenced the original  limit  operator. Updates the 3 overloads of  Schedulers.from  to describe (in a concise manner) the cases when the  Executor  would throw a  RejectedExecutionException . Such exceptions can t be reasonably handled from within RxJava.  There are typically two cases when such exception would occur:  1) **The underlying Executor is shut down.**   Operators such as  observeOn  guarantee worker-confinement when calling  onNext    onError  and  onComplete . A failure to schedule would at best bypass this confinement  notifying the downstream on the current thread  at worst cause overlapping execution downstream.  The recommended workaround is to cancel all flows using the particular  Scheduler  after which the Executor can be shut down safely.  2) **The underlying Executor temporarily rejects more work.**  Such temporary rejections are often used in traditional  Executor  usages to drop work or pause the submission of work. In RxJava though  there is often no 1:1 correspondence to signals ( onNext    onError  or  onComplete ). Some work may be correlated to several  onNext s  other work may be due to downstream requests. Dropping any such work may lead to inconsistent flow state or livelocks.  The recommended workaround is to express limits on the execution via backpressure (e.g.   Flowable s).      Resolves #7149 - Simplify empty/non-empty cases. - Fix cancellation order and wrong fall-through. - Add deterministic test to cover the reduction cases. The  TestScheduler  is a bit inconsistent regarding the use of  RxJavaPlugins.onSchedule . It extends  Scheduler  so the  scheduleDirect  methods do invoke the hook whereas the worker s  schedule  methods don t.  This PR adds a constructor flag to enable the use of the hook in the worker s  schedule  methods as well. This addition should avoid issues with existing tests not expecting the hook to be invoked all of a sudden.  Resolves #7119 This PR adds the  boolean offer(T item)  method to  PublishProcessor  and  BehaviorProcessor  to prevent  MissingBackpressureException  when one of the  Subscriber s is not ready to receive element by indicating a false return value. The sender can then retry the offer with any wait strategy it choses.  In addition  this PR adds Reactive-Streams Publisher TCK checks to verify  AsyncProcessor    BehaviorProcessor    PublishProcessor    ReplayProcessor  and  UnicastProcessor  as being  Publisher s. Unfortunately  the TCK can t verify them as  Processor s because the TCK has certain expectations about how a  Processor  should behave (namely: expects fail-fast  refCount-like nature). This PR adds front fusion support to -  Flowable.concatMapCompletable  -  Flowable.concatMapMaybe  -  Flowable.concatMapSingle  -  Observable.concatMapCompletable  -  Observable.concatMapMaybe  -  Observable.concatMapSingle   The operators have been tidied up by factoring out common code paths.  In addition  the  DeferredScalarSubscription  s fusion-emission had to be fixed. In async fusion mode   onNext(null)  is generally expected from the upstream but  DeferredScalarSubscription  sent the value itself. Now it correctly sends  null . ( DeferredScalarDisposable  already did this correctly).  Resolves #7061 This PR adds a reflection-based parameter validator to check the base reactive classes for proper parameter validation: null checks and argument ranges. The problems detected are fixed as well. This PR fixes the case when  Flowable.flatMap  and  Observable.flatMap  would emit the  ExceptionHelper.TERMINTED  indicator exception to downstream due to emission-cancellation race.  Reported on [StackOverflow](http://stackoverflow.com/questions/42580195/what-is-the-meaning-of-no-further-exceptions). Add the proper links and code blocks to improve style to  io.reactivex.rxjava3.schedulers.Schedulers . This PR reimplements the  Maybe  with more up-to-date algorithms (the original was a copy-paste of some older Single and Completable code it seems) and adds javadoc and tests along the way. Not all operators have been rewritten yet (and no placeholders). Early adopters should refer to the  toX  methods on the base reactive types. The PR also adds the  RxJavaPlugins  hooks to support  Maybe .  In addition  I ve fixed javadoc mistakes in the other base reactive types (referring to the wrong types). Starting from JDK 10  the  FutureTask.toString  can now print the inner callable routine  which if somehow references the parent  FutureTask  again  it leads to  StackOverflowError . This can happen in RxJava because  AbstractDirectTask  and  ScheduledRunnable  store the  Future  object returned by the executor in a reference field that gets accessed by their default  toString  implementation.  The fix is to define custom  toString s that break this cycle. Note that we can t print the underlying  Runnable  either because that could also reference something in a circular manner. In addition  the release of the  runner   Thread  marker has been moved closer to the exit of the wrappers which helps with the state determination and self-cancellation.  To verify the fix works  a new GitHub Action has been added  targeting JDK 11 as the issue does not manifest itself under the main target JDK 8.  Resolves #7172 Parallel operators were missing an  RxJavaPlugins.onSubscribe  hook.  Resolves #7190 This PR adds the  ParallelTransformer  interface to match the other  XTransformer  interfaces  adds  @NonNull  annotations to the  ParallelFlowable  operators and adds the  ParallelFlowable  class to the parameter validator test set. This PR increases the timeout on  CompletableTest  test methods and on  ParallelFlowableTest.parallelismAndPrefetchAsync .  Related: #5154  #5179. This PR adds 2 new overloads to  ParallelFlowable  operators  map    filter  and  doOnNext  to enable per item error handling in case the main function fails with some exception.     java Flowable.range(0  2) .parallel(1) .map(v -> 1 / v  ParallelFailureHandling.SKIP) .sequential() .test() .assertResult(1)       The new  ParallelFailureHandling  has some default enumeration values to handle the common cases. In addition  the  BiFunction  overload allows bounded retries and/or conditional handling of failures.   Related: #5128. The direct scheduling methods of the  ExecutorScheduler  created via  Schedulers.from(Executor  boolean)  did not fully honor the  interruptibleWorker  settings.  Fixes #7201 Task wrappers of the various schedulers and modes (direct & worker) were able to get cancelled via interruption from the same thread they were running.  Related #5203. Fix the copy-paste error of pointing to  flattenAsFlowable  instead of  flattenAsObservable . This PR links in the new images from #5130 for previously misleading marble diagrams of the operators. This PR fixes a missing javadoc entry for  <T>  in  UnicastSubject  and adds a marble diagram to the class itself:  ![Image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/UnicastSubject.v1.png) This PR improves the documentation of the abstract consumer classes such as  DisposableSubscriber    ResourceSubscriber  and their counterparts for the other base reactive types.  It contains a lot of copy-paste so please read through all of the text in case the text was not properly adapted to the abstract class at hand.  Related: #5148. I don t remember why the stacktrace it wasn t printed directly via the PrintStream/PrintWriter  no reason to aggregate the entire string output.  Fixes: #7211 The  window()  operator overload with time and size bound didn t work correctly when some windows were terminated by the timeout and others by the size. This PR fixes:    - the case when the operator restarts the time windows when the size bound is reached    - leaking of the worker    - the item counter not reset to zero when the time bound is reached    - periodic window bound stopped working after the first window.  Related #5104 (again). It was incorrectly referencing  SingleObserver  in one of the sentences.  Resolves: #7271 This PR is the result of running IntelliJ inspections on the code:    - replace  unsubscribe  with  cancel  and  dispose  in the main classes to better match the 2.x terminology   - write out a couple of local variables   - remove unnecessary  return  and  continue  statements   - remove unnecessary variable writes   - remove unnecessary and unused fields   - add  final  to some fields   - fix typos Bad wording:  an instance of a(n) X instance . This PR improves the javadoc of the  io.reactivex.schedulers.Schedulers  utility class plus adds a missing  SchedulerSupport  constant for the  single()  scheduler.  Let me know if something needs further explanation (or some new case needs explanation).  Related: #5145. The  Completable.onErrorResumeNext  did not properly propagate the downstream  unsubscribe()  call to upstream.  Reported in #5224. This PR contains the fix for incorrect call of the  onError  handler within  CallbackCompletableObserver.onComplete()  reported in [5099](https://github.com/ReactiveX/RxJava/issues/5099#issuecomment-289544756) as well as wording fixes to the  ResourceX  javadoc. This PR fixes the  NullPointerException  that can happen because  cancel  nulls out the value and  onNext  simply dereferences that value in  FlowableToList .  Reported in #5246 . The wrong logical expression in the  isEmpty()  method made  flatMapIterable  complete earlier  even if data was available in the current iterable.  Somewhat related: https://github.com/reactor/reactor-core/issues/508 (different logical bug in the same method). This PR enables the generated Javadoc to  {@link }  to JDK classes properly (current 2.0.8 doc [shows them](http://reactivex.io/RxJava/2.x/javadoc/2.0.8/io/reactivex/schedulers/Schedulers.html#io()) as plain text). I m linking to the v7 docs because v6 is ugly.  In addition  I ve fixed the style of the  Schedulers  documentation by separating the **Supported system properties** properly into a new paragraph. Fixes the  Single.subscribe(BiConsumer)  to report  isDisposed  when terminating.  Reported in #5276. This PR fixes the race condition in  BehaviorProcessor  and  BehaviorSubject  when  onComplete()  or  onError()  is called concurrently with  subscribe  and the consumer throws a  NullPointerException  instead of relaying the terminal event.  The fix involves having a separate  terminalEvent  atomic field  CAS-ing in the actual or marker  Throwable  and reading that field in  subscribe . This PR   - fixes a couple of documentation and message copy-paste errors - fixed FlowableFlattenIterable not checking for null returned by  Iterator::next()  - replace  publisher  with the appropriate name This PR fixes  Flowable.flatMapMaybe  and  Flowable.flatMapSingle  not replenishing from the upstream when they complete/error per inner source. This PR changes the  Disposable already set!  and  Subscription already set!  messages on the standard consumer classes ( DisposableSubscriber    DisposableObserver   etc.) to something more meaningful:   It is not allowed to subscribe with a(n)  <class name>  multiple times. Please create a fresh instance of  <class name>  and subscribe that to the target source instead.   Where  <class name>  is a placeholder for the  getClass().getName()  of the subclass of those consumer types. It should clearly state to avoid subscribing with them multiple times as well as printing the full class name to indicate the problem is with the use of the implementor class  and not with the abstract RxJava class.  Inspired by [this StackOverflow](http://stackoverflow.com/questions/43482263/rxjava2-protocolviolationexception-disposable-already-set) question  one of many such questions.  For the internal operators  the original error message stays because when they appear  that is still likely due to an implementation bug (or a misbehaving user-created custom implementation). This PR adds the  Single.unsubscribeOn()  operator.  Related: #5300. - Move  verifyPositive  into  ObjectHelper  - Fix javadoc of  Flowable.subscribe()  and  Observable.subscribe()  mentioning  Subscription  from 1.x -  Maybe : add  amb    concat    concatArray    merge    mergeArray    concatMap    subscribe    subscribeWith    doOnEvent This PR applies the promotions listed in #5243.  Suggested review strategy:  - Check if the  @Experimental  annotation has been removed or turned into  @Beta . - Check if the  <p>History: 2.0.x  matches the original value of the updated  @since 2.0.x . - Fixed bugs in  Flowable.sequenceEqual    Flowable.zip  when errors are delayed   Flowable.onBackpressureBuffer  when errors are delayed - Fixed mentions of  NbpX  in some places - Synchronized unit tests between  Observable  and  Flowable The  Flowable.toObservable()  javadoc was referring to  Publisher  instead of  Observable . Improve the coverage of some classes  plus re-add the unit test that validates the  StrictSubscriber .  Only test changes  no functional changes. This PR applies the API promotions of #5201.  Note that  Single.unsubscribeOn  remainded experimental and  Observable.fromEmitter  was removed.  Where the experimental version was available  it was moved up as  <p>History: 1.x.y - experimental  similar to how 2.x versioning/promotions happen.  Suggested review strategy:  - verify  @Experimental  and  @Beta  annotations are removed from the method and from Javadoc - verify  @since 1.3  is present This PR adds the  tryOnError  method to the various  Emitter  types used in the  create  operators that allows the developer to avoid the  UndeliverableException  in case a cancellation is racing with the emission of an error. The return value indicates a success of the delivery  in case of  false   the developer can decide to log/drop the specific error if that makes sense for him/her. Update/fix to a couple of marble diagrams in  Observable :  -  singleOrError : [reuse existing](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/singleOrError.png) -  combineLatestDelayError : [reuse existing](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatestDelayError.png) -  concatArrayEager : [new diagram](https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-302041653) -  erro r: [new diagrams](https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-302043293) -  fromFuture : [new diagrams](https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-302054241) -  fromIterable : [new diagram](https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-302054967) This PR fixes the case where a  trampoline  scheduler is used with the  interval  or  intervalRange  operator  the periodic emissions can t be cancelled properly. The synchronous and blocking nature of the periodic schedule is that the  Disposable  is never connected with the downstream and the  interval  stays in a drain-sleep loop per emission indefinitely.  This PR changes the operators to use the  Worker  of a trampoline scheduler that is available before the drain-sleep loop thus a downstream cancellation can stop the loop. Any other  async  scheduler will still use the direct periodic scheduling facility.  In addition  the trampoline loop has been fixed to check for the worker  disposed  state in the inner loop. This PR adds null checks to places where it was missing.  In addition  the  XMapNotification  operators now report a composite exception of the original  Throwable  and the error thrown by the function that should return the continuation source.  Also fixed  TestSubscriber / TestObserver  not cancelling the sequence if the fused poll crashed. - enable fusion with  Observable.map  - remove impossible branches in some classes - add more tests to cover tool classes - fix  Observable.range()  entering regular emission if fusion-drain is interrupted - fix  FullArbiter  and  ObservableFullArbiter  not cancelling/disposing the incoming Subscription/Disposable in some cases This PR adds an overload to  subscribeOn  that exposes the existing feature to optionally request on the same scheduler where the subscription happened. This is necessary to avoid same-pool deadlock when the upstream contains  create  logic that blocks the emission thread  preventing any scheduled request to get through and leading to excess buffering or dropping data excessively. By not scheduling the request  it can directly update the emitter s request tracking and let the emitter continue.  Formerly  the existing  subscribeOn  automatically disabled scheduling the requests if the immediate upstream was a  FlowableCreate . However  if there were operators between  create  and  subscribeOn  (as often happening on Android with composing the schedulers at the end of the chain)  the  subscribeOn  operator run in scheduled request mode by default.   This change allows specifying this behavior through the new overload and thus distance between the  create  and  subscribeOn  operators no longer matters.  (Note that 1.x already has this overload.) This PR fixes an issue when in a fused chain of  doOnNext  and  doOnError  the  doOnNext  function fails  the  doOnError  consumer is not called.  Originally reported in Reactor-Core: https://github.com/reactor/reactor-core/issues/664 This PR adds unit tests to verify the  Scheduler.schedulePeriodicallyDirect  and  Scheduler.Worker.schedulePeriodically  works with non-positive period as required by the Javadoc.   The  computation  and  single  schedulers were not working properly and the underlying  ScheduledExecutorService  crashed with  IllegalArgumentException  thus these are now fixed with custom handler for the  period <= 0L  cases.  Related: #5416. As of lately  the Travis CI runs much slower than usual and causes some time-sensitive tests to fail for some reason. This PR tries to figure out why this happens. The FlatMapX tests kept failing because there was a race between the cancellation and the disposing of their inner set: the cancel may have interrupted the test wait and ended up in the inner subscribe before  set.isDisposed()  would become true in the  dispose()  call of the operator that run on the main thread. The change adds/uses a boolean field that gets set first and is checked before the inner are subscribed. The PR fixes both the time+maxSize bound  buffer  operators of  Flowable  and  Observable . The logic didn t properly mutually exclude the timer action and the  onNext  action  resulting in probabilistic emission of the same buffer twice.  Reported in #5426. This PR rewords the javadoc of the  Observable  class a bit and adds a couple of extra clarifying sentences. This PR adds the baseline for changing  Flowable  and  Observable  operators to return  Single    Completable  or  Maybe  but in case the user wants to go back to the original type via  toFlowable  or  toObservable  we switch to a natively  Flowable / Observable  operator (macro-fusion).  Benchmark comparison (i7 4790  Windows 7 x64  Java 8u102):  ![image](https://cloud.githubusercontent.com/assets/1269832/18269896/98ffbf80-742a-11e6-91b7-23b03bec8b8c.png)  No changes were applied to  Observable  yet hence the roughly same result there.  Flowable.reduce()  has been updated plus there is a new  FlowableReduce  instead of  scan().last() . This PR adds just the new methods from #4481 to allow a much cleaner change of return types later on. This PR makes sure the  Disposable  of a  concat  operator reports  true  when the sequence terminates.  Reported in #5439 The  SchedulerPoolFactory  did not act properly on the system properties setup.  Reported on StackOverflow: https://stackoverflow.com/q/44717193/61158 This PR compacts the  blockingX  operators by extending  CountDownLatch  and implementing  SingleObserver    CompletableObserver  and  MaybeObserver  with the necessary blocking await mechanics.  Benchmark comparison (i7 4770  Windows 7 x64  Java 8u102):  ![image](https://cloud.githubusercontent.com/assets/1269832/18291535/868c4d6a-7488-11e6-99f7-43415f79e5e4.png)  In addition  the internal package  subscribers.single  and  subscribers.completable  has been removed and the classes moved into  io.reactivex.internal.observers  package. The old blocking enum helpers were removed as well.  The  BlockingSingleSubscriber  and  BlockingSingleObserver  abstract classes have been renamed to  BlockingBaseX  to avoid name confusion (they have nothing to do with the  Single  type). I asked the Travis support about the slow build times of lately and they suggested I try  sudo:required  to have an isolated build VM instead of the shared container-based one. I ll rerun this PR a couple of times to see the effects. - minor Javadoc corrections - Note: some Maybe operators shifted within the file - add to  Maybe :  concatArrayDelayError    concatArrayEager    concatEager    concatDelayError    mergeArrayDelayError    mergeDelayError    sequenceEqual    timer    using    zip    zipArray  - improve coverage of  Observable    Single  and  Maybe . - Move tests from  ObservableTests  into  ObservableTest  drop the former. This PR fixes most JavaDoc errors discovered from RxJava 3 preview s javadoc generator (doclint enabled).   (I was unable to make gradle in RxJava 2 to report the same errors regardless of source level and underlying Java 8 runtime locally.)  Changes include:  - Fix closing tag of  <dt>  in  <dl> s - Fix  <td>  to  <dt>  in  <dl> s - Replace  >  in  <code>  blocks with  &gt    (as it is forbidden in doclint of Java 8) - Replace  <  in  <code>  blocks with  &lt   - Add source code checker for the previous mistakes - Remove  initialSeed  mentions from  scan  operators that take a  seedSupplier  and remove the deferred example as well - Switch the order of  <code><pre>  to  <pre><code> . - A couple of end-sentence punctuation. This PR  - fixes the wording of  toList()  putting emphasis of the need for finite sources and removes a misleading/incorrect sentence about unstoppability  - corrects a/an spelling errors in  subscribeOn . - removes the mention of  toBlocking  from the  toFuture  javadoc Increase timeouts of tests that started failing due to slower CI. Ths PR replaces #5485 regarding the issue of #5480 because our javadoc validation did not allow that type of wording (i.e.  mentioning  Single  when the method signature is not related to it). This PR upgrades the replaying algorithms of the  ReplayProcessor  to the standard queue-drain and as an added effect  fixes a request-emission race where the internal  NotificationLite.complete  could be emitted to the consumers. This PR adjusts #5494 by converting the  withLatestFrom  operators into conditional subscribers and adds unit tests that verify a cold source is consumed fully if there is no event(s) from the other source(s).  (Also there was a missing space before the bracked and the new unit test name had the  test  prefix.) This PR fixes the so-called GC Nepotism (see #3794) in  SpscLinkedArrayQueue  by not nulling out the previous buffer s next pointer upon switching buffers in the  peek() / poll()  methods.  In addition  the FlowableRefCountTest.testRefCountAsync has been reworked to be more forgiving towards unexpected delays due to system load (reported in #5506). There was a missing null check on the fusion path in  ObservableFromCallable  which meant the consumer considered the source to be empty. (The  FlowableFromCallable  was okay.)  Discovered on StackOverflow: https://stackoverflow.com/questions/45304226/null-handling-in-rx-java2-flatmap  Unit test mirrored and updated to verify both  Flowable  and  Observable  versions. This PR updates the marbles of the following  Observable  operators:  -  just  ([image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.item.png)) by @leonardortlima  -  rangeLong  ([image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/rangeLong.png)) by @leonardortlima  -  startWith  ([image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.item.png)) by @leonardortlima  -  startWithArray  ([image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWithArray.png)) by @leonardortlima  -  sorted  ([image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sorted.png)) by @leonardortlima   See #5319. The  MaybeFromCallableTest.noErrorLoss  failed occasionally because the  await  didn t throw  InterruptedException  as expected.   The reason for this is that if the main  to.cancel()   and the subsequent  cdl2.countDown()   happened just before  await()  was called  the  await  didn t even look at the thread s interrupt status but returned immediately as there was nothing to wait for.  The fix just removes that  cdl2.countDown  and adds a regular timeout to the inner  await .  *(Detected while verifying RxJava 2 against JDK 9b181.)* This PR fixes the case reported in #5558 where a synchronous first  non-empty source triggered an error completion immediately instead of giving a chance to the other sources to form combinations.  The fix also includes:  - initialization of the  CombineObserver s now happen in the constructor  - the  AtomicReference<Disposable>  of the inner observers are now inlined into  CombineObserver   - cleaned up drain logic - unit tests verifying  FlowableCombineLatest  (no changes required there). This PR fixes the unnecessary  dispose  call towards the main source when the source terminates and reworks the internals to use less allocation and indirection. The error message/variable names in  TestBaseConsumer.assertValueSequence  was reversed: if more items were expected  it said  Fewer  and vice versa. This PR fixes the problem that  ConcurrentHashMap::keySet   when compiled on JDK 8  adds the  KeySetView  type in the bytecode which is not available in JDK 7 and before. The change forces the offending place to use the the standard  Map::keySet  which returns a standard  Set . This PR fixes the wrong queue type in  Observable.concatMapEager  to be the  SpscLinkedArrayQueue  instead of the  SpscArrayQueue  (the latter basically ignored items from the main source when it got full - a remnant from its bounded  Flowable  cousin). Unit tests added that ensure both  Flowable  and  Observable  variants work properly.  Reported in: #5608 This PR adds the  onTerminateDetach  operator to  Single  and  Completable . It was available on  Flowable    Observable  and  Maybe  already.  Plus:  - Fixes the javadoc for  Maybe.onTerminateDetach  - Adds unit tests for verifying terminal events do release references with  Maybe  as well.  Their non-existence came up on [StackOverflow](https://stackoverflow.com/questions/46397082/disposablecompletableobserver-leaking-activity-even-though-im-clearing-composit?noredirect=1#comment79870549_46397082).  **Update**  Turns out the downstream s  actual  references were not cleared in  Maybe  after all. Updated the PR to ensure that in all 3 of them and improved coverage. This PR upgrades the Gradle runtime to 4.2 (which supports Java 9) and gets rid of the  rxjava-nebula  plugin. Its two features  publishing a snapshot and publishing a release has been manually implemented in  build.gradle  based on some [online examples] and [RxAndroid s](https://github.com/ReactiveX/RxAndroid/blob/2.x/rxandroid/build.gradle) variant.  The snapshot publication [works](https://oss.jfrog.org/artifactory/libs-snapshot/io/reactivex/rxjava2/rxjava/2.2.0-SNAPSHOT/) and to test the release  we may have to burn a couple of version tags from 2.1.x.  The PR also renamed the  perf  directory into  jmh  because the replacement JMH plugin expects those files there. This PR adds JavaDoc warnings for  fromPublisher  as people still try to implement a source through it and fail to follow the specification like this:     java // DON T DO THIS! Flowable.fromPublisher((Subscriber<Integer> s) -> s.onNext(1))       Even though  Publisher  is a single abstract method (SAM) type  it is almost never reasonable to write a source with it that doesn t require a per-subscriber state. The example above fails to setup backpressure properly and it didn t call  s.onSubscribe()  for that  causing  NullPointerException  whenever the  Subscription  would be needed (i.e.  for cancellation and requesting) by the downstream operator.   Maybe  doesn t have  fromPublisher . This PR updates the marble diagrams of the 2..10 argument  Observable.just()  and two overloads of  Observable.switchOnNextDelayError .  Images in [Issue 5319](https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-335124895). The inner  Observer  type and the  SequentialDisposable  of the  concatMap  and  concatMapCompletable  can be combined into a single instance  saving on indirection and allocation.  (I ve noticed this when reviewing #5649.) This PR fixes an unsubscribe bug somewhere in the timed  timeout  operator reported in #5657 by implementing it in a algorithmically fresh manner. This PR improves the internal overhead of the  Flowable.timeout  operator (its 2 timed and 2 selector-based versions) to use the adapted [indexed atomic state transition approach](http://akarnokd.blogspot.hu/2017/09/java-9-flow-api-timing-out-events.html).  In addition  there was a race condition and potential event loss in  TestScheduler :  -  peek()  could return  null  if the task was removed from the queue (via disposing it) between the  isEmpty()  check and  peek()  itself.  - In addition  if the task was disposed between the  peek  and  remove   the  remove  could remove the new head of the queue which is no longer what  peek  saw and results in tasks being dropped. This PR should fix the bug that caused the test failure in #5545.  The bug manifested itself when a cancellation was happening the same time a request 1 was being fulfilled. Since the same request accounting was used for cancellation indicator  if the cancel happened between the  onNext()  s  get()  check and  decrementAndGet   this  decrementAndGet  decremented Long.MIN_VALUE unconditionally  which lead to a state that would appear the Subscriber still can receive events. A concurrent  offer   which saves the current array of registered  Subscriber s  then would emit an item and overflow the  Subscriber .  The fix is to use the cancellation-aware  BackpressureHelper.producedCancel()  utility.  Unit test were added to verify the correct behavior on both  PublishProcessor  and  BehaviorProcessor  (the latter uses different cancellation mechanism via a dedicated field). This PR adds a Perf class to measure the overhead of request management inside  PublishProcessor  and a comparison with  PublishSubject .  Note that running JMH with RxJava under Windows is currently not possible because Gradle adds so many of its own jar dependencies that the resulting command line classpath exceeds the 32k limit.  Results with 2.1.5 release (separate gradle project  Windows 7  i7 4790  Java 8u144)  ![image](https://user-images.githubusercontent.com/1269832/31654835-74257c76-b327-11e7-801f-49c46e0321b2.png)  The bounded benchmark indicates a 4x the throughput for some reason I don t understand yet. The  parallel()  supports front-fusion but since the operator is almost always followed by the separate  runOn  operator  the parallel version of the  observeOn  operator  such front-fusion should be considered a  BOUNDARY -type fusion just like with  observeOn .   A  requestFusion  with  BOUNDARY  tells the upstream operator(s) that when fused  their actions would be executed behind an async boundary and possibly on an unwanted thread. Operators  such as  map  and  doOnNext   who are generally expected to be thread-confined  can then refuse to fuse  restoring the traditional queue hopping behavior ( source -> queue -> op -> queue -> op -> queue -> consumer ).  Reported in #5676.  /cc @smaldini & @simonbasle Update several  Observable  marble diagrams. Images can be viewed [here](https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-337563753).  -  zipIterable  -  ambWith  -  blockingForEach  -  blockingIterable  -  blockingLast  -  blockingLast(T)  -  blockingMostRecent  -  blockingNext  -  blockingSingle  -  blockingSingle(T)  -  cacheWithInitialCapacity This PR adds a Reactive-Streams TCK test for  limit()  . Completable.andThen    concat(Iterable)  and  concatArray()  disposed the previous  Disposable  when receiving the new  Disposable  from the next source which could lead to interruption.  concat(Publisher)  already uses  replace  instead of  update .  There is a peculiar interplay between  subscribeOn    observeOn  and the trampoline in  concat  which can trigger such an interruption: the task of the  observeOn  is cancelled with  mayInterruptIfRunning == true  because the  dispose  call chain shuts down the worker of the  observeOn  from the  subscribeOn  s thread.  Reported in #5694 Fixes the same bug as with the 2.x  Completable.andThen  and  Completable.concat .  See #5694 & #5695. Clarify that  flatMapSingle  and  flatMapMaybe  merge in no particular order and fix the copy-paste error from  flatMapCompletable  as they have values to merge  not just waiting.  Related: [StackOverflow question](https://stackoverflow.com/questions/47176437/rxjava-2-observable-flatmapsingle-clarification) This PR adds clarifications to the  BaseTestConsumer.values()  and  BaseTestConsumer.errors()  method in regard to accessing elements while the upstream is still actively emitting events.  Related discussion: #5712 This PR adds logic to distinguish between synchronous and asynchronous dispose calls when  setFuture  is executing. It should prevent interrupting the currently running task body if it requested cancellation indirectly before the  setFuture  was executed by the Thread which scheduled the task.  Fixes #5711 There were missing  .  from sentences in the operator Javadocs detailing certain overloads use custom  Scheduler s. This PR adds the ability to specify the default thread priorities of  computation()    io()    newThread()  and  single()  schedulers via system properties. I ve added the property names to the  Schedulers  javadoc.  Related: #4389. This PR fixes the operators  refCount  (ensure proper call order to onXXX)  disables FindBugs due to out-of-memory kills on Travis and increases the half-time sleep of a flaky unit-test. This PR sets up the build to run TestNG tests as well and adds the Reactive-Streams TCK to allow validating our operators.  Included tests are:  just    fromArray    fromIterable    concat    merge .  Note that the TCK tests for invalid  request()  amount which  according to the spec  should be reported to the running  Subscriber  via  onError . Unfortunately  this is a very expensive requirement (requiring half-serialization all the time) and we are not going to support it in RxJava 2. Negative requests are bugs in operators and should be fixed  we only provide a notification about such situations in the  RxJavaPlugins.onError  for those who want to check for such errors.   Therefore  the  FlowableTCK  has been added with does the required behavior by the TCK and can be used as  FlowableTCK.wrap(flowable)  when returning from the TCK s  createPublisher(long) . This PR adds a marble diagram to  fromPublisher  and updates the marbles of  all  and  zipArray  inside  Observable .  The images can be seen in [this comment](https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-346585222) of #5319. This PR adds an internal interface  SchedulerMultiWorkerSupport  that allows retrieving multiple workers from a  Scheduler  that implements this interface.  The standard  Scheduler.getWorker()  can be invoked as many times as necessary  but specific implementations such as the  computation()   Scheduler  and the [ ParallelScheduler ](https://github.com/akarnokd/RxJava2Extensions#parallelscheduler) is not guaranteed to return workers that are backed by distinct single-threaded thread pools.   This does not effect other scheduler types because:  - they are single threaded ( single() ) or don t use threads at all ( trampoline() ) and  - already hand out distinct workers ( io()    newThread() ).  Such worker reuse can happen when in a highly concurrent application  typical tasks are mixed with parallel tasks and both pull out workers from these  Scheduler s. If this is happens  it is possible there will be duplicate threads used by the parallel operations and thus not utilize the originally intended parallelism level.  By implementing this suggested interface  a batch-retrieval can be supported by the  Scheduler s and they can make sure the caller gets as many distinct thread-pool as possible. If more workers are requested than the  Scheduler  s parallelism  the workers are handed out in round-robin fashion similar to the standard  createWorker() .  Why a callback instead of returning an array?  - even if both require an allocation to set up  there is no need to have all workers visible at once  - simply less memory usage  and - avoids looping twice: once for filling in the array and once for using the elements of the array. Both  switchMap  implementations didn t properly cancel the current inner consumer (but instead cancelled the outer  connection  only).  Reported in #4512. I ve forgotten to create a branch so the first part of todays coverage work [landed in 2.x direct](https://github.com/ReactiveX/RxJava/commit/1145819b658983807e0cede5ba2c7d5ac1117baa) - removed unused methods from various classes - compacted  SpscArrayQueue  - added null checks to  SpscLinkedArrayQueue.offer()  and  MpscLinkedQueue.offer()  - fixed  ResourceObserver  not calling  onStart  - Added direct NotificationLite-emission methods to  AppendOnlyLinkedArrayList   updated  SerializedObserver  and  SerializedSubscriber  to use it directly instead of the former indirection -  TestObserver.isDisposed  now reports true if terminal events were received (#4514) -  ResourceSubscriber  to use  SubscriptionHelper  s deferred Subscription/requesting management - added unit tests to cover  DisposableXObserver s -  SerializedObserver  and  SerializedSubscriber  now have proper unit tests each  This current PR fixes  Single.using  not properly managing the resource and adds unit tests to verify the behavior along with a few extra coverage improvements. This PR adds or updates mable diagrams of  Observable :  - [ blockingFirst ](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingFirst.o.png) - [ blockingFirst  with default](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingFirst.o.default.png) - [ toFuture ](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFuture.o.png) - [ blockingSubscribe  no arguments](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.0.png) - [ blockingSubscribe  with 1 argument](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.1.png) - [ blockingSubscribe  with 2 arguments](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.2.png) - [ blockingSubscribe  with 3 arguments](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.png) - [ collectInto ](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/collectInto.o.png) - [ doOnComplete ](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnComplete.o.png) - [ doOnError ](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnError.o.png) - [ doOnLifecycle ](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnLifecycle.o.png) - [ doOnNext ](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnNext.o.png) - [ doOnDispose ](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnDispose.png)   Related #5319: [comment](https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-347482919). This PR is to improve the wording of a few  package-info.java  JavaDocs and removes two unused imports. This PR adds some missing marbles to  Observable :  - [concatMapCompletable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapCompletable.o.png) - [concatMapDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapDelayError.o.png) - [concatMapEager](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapEager.o.png) - [concatMapEagerDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapEagerDelayError.o.png) - [concatMapIterable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapIterable.o.png) - [doAfterNext](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doAfterNext.o.png) - [doFinally](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)  Tracked in #5319  images in [comment](https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-349595094). This PR improves the JavaDoc of  ConnectableObservable.autoConnect()  and  ConnectableFlowable.autoConnect()  operators and adds the respective marble diagrams:  ![autoConnect](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/autoConnect.o.png)  ![autoConnect](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/autoConnect.f.png) This PR adds a couple of  @see  cross references to  Completable  JavaDoc. This PR adds or updates mable diagrams of  Observable :  - [doOnTerminate](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnTerminate.o.png) - [elementAt](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAt.o.png) - [elementAt](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtDefault.o.png) with default - [elementAtOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtOrError.o.png) - [firstOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstOrError.o.png) - [flatMap](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapDelayError.o.png) with error delayed - [flatMap](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapMaxConcurrency.o.png) with maximum concurrency  Related: https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-350682783 This PR adds the  Subject.refCount()  and  FlowableProcessor.refCount()  that capture the upstream s  Disposable / Subscription  and disposes/cancels them if the number of  Observer s/ Subscriber s decreases to zero. The Reactive-Streams TCK and thus other implementations may expect such behavior from a  Processor  implementation and this wrapper is required to pass the TCK tests.  While implementing the TCK tests  it turned out the  null -handling of the  Subject s and  FlowableProcessor s were not following the Reactive-Streams specification. They have to throw a  NullPointerException  immediately and not turn them into NPEs for the downstream. These classes and the tests have been fixed as well. Their error messages have been uniformed too. This PR adds some more  Maybe  operators: -  ambWith  -  cache  -  concatWith  -  contains  -  count  -  defaultIfEmpty  -  delay  -  switchIfEmpty  -  zipWith   Plus a small cleanup and additional  TestHelper  test support (check double onSubscribe calls  dispose() state management). This PR removes the unnnecessary  cancel / dispose  call from the exact-boundary timed  buffer()  operators in  Observable  and  Flowable  when the upstream completes normally.  Originally appeared in a [StackOverflow question](https://stackoverflow.com/questions/47772415/rxjava2-completing-a-cold-source-flowable-explicitly). This PR improves the Javadoc of the  retryWhen  operators in the 5 base classes  adds example to handling an asynchronous source with delay where an early  onComplete  may cause unexpected terminations otherwise.  Related: #5772. - add  Maybe  operators:  delay    hide    isEmpty    onErrorComplete    onErrorResumeNext    onExceptionResumeNext  - add more fusion interfaces and mark  Maybe.just  and  Maybe.empty  as  ScalarCallable . - added unit test to verify base reactive classes have proper scheduler and backpressure annotations (wherever appropriate) - added unit test to verify the javadoc of the main reactive types have the **Backpressure:** and **Scheduler:** sections in them (via scanning the source files if it can find it possible  works for me) - added unit test to verify that when **Scheduler:** section mentions a method name  it actually matches the method the javadoc is there for (lots of copy-paste errors were found this way) - fix the annotations and documentation errors detected above - the backpressure javadoc section checker for 3 types are currently disabled as I m out of time for tonight. A [StackOverflow](https://stackoverflow.com/q/47982511/61158) question prompted me to look at  BehaviorProcessor  to find it quite lacking of a detailed JavaDoc. This PR adds sentences and examples (I could think of) to it that explain the available features and behavior of this  Processor  implementation.  If the sentences are reviewed  the  BehaviorSubject  will be updated with the applicable information (i.e.  everything minus backpressure related sentences). This PR adds detailed behavior and feature description to the  BehaviorSubject  JavaDoc.  In addition  small mistakes in the  BehaviorProcessor  JavaDoc have also been fixed and both received an extra section:  Error handling  that points at the global error handler for undeliverable errors. Due to this link  the  RxJavaPlugins.onError  JavaDoc has been also expanded. This PR adds some clarifications about how  merge  handles (multiple) errors in a new *Error handling* section in its  <dl>  JavaDoc entry.  There exist several dozen variants of  merge  in the various base classes that could also include such JavaDoc addition. Once the wording has been reviewed  the other places will receive a separate PR.  Related: #5779  #5780 A missing  nulls  word from  Flowable.onTerminateDetach  and  Observable.onTerminateDetach  JavaDoc. The other types have this word already.  Related: #5782. This PR updates the JavaDoc of the  Maybe.doOnSuccess    Maybe.doOnError  and  Maybe.doOnComplete  marble diagrams and adds an explicit sentence about mutually exclusive events.  ![DoOnSuccess](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnSuccess.m.png) ----- ![DoOnError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnError.m.png) ----- ![DoOnComplete](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnComplete.m.png) This PR adds the **Error handling** JavaDoc section to the other  merge  operators throughout the base reactive classes.  Note though that the following  mergeDelayError  methods don t exist yet:  -  Maybe.mergeDelayError(Publisher  int)  -  Single.mergeDelayError(*)  ( *  all variants of their respective  merge  methods are missing)  These can be added in a separate PR and don t require implementing new operators but to configure existing ones with  delayError == true . This PR improves the request accounting overhead in the  retry  and  repeat  operators.  Previously  every individual  onNext  invocation signaled a an item production  which had a lot of overhead since the  SubscriptionArbiter  has to serialize invocations of  setSubscription    request  and  produced . The improved algorithm counts the  onNext  calls in a field and calls  produced  once with the total count before subscribing to the upstream again.  Other small changes: - rename inner class to  RetrySubscriber  (sloppy copy-paste)  - add  isCancelled()  check to  repeatUntil  subscription loop  which was somehow missing. This PR fixes the lack of upstream  cancel()  call when an inner  fused source s  queue.poll()  crashes in a non-delayed error mode.  Unit tests were added to verify  Observable.flatMap    Flowable.flatMapIterable  and  Observable.flatMapIterable  as well.    Fixes #5791 This PR adds 5 marble diagrams to  Observable :  -  flatMapCompletable  (2 overloads) -  forEach  -  forEachWhile  -  hide   Images in https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-355932289 This PR adds and updates marbles of the following  Observable  operators:  - [lastOrError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastOrError.png) - [onErrorReturn](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturn.o.png) - [onErrorReturnItem](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturnItem.o.png) - [onTerminateDetach](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onTerminateDetach.o.png) - [publish(Function)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishFunction.o.png) - [reduce(seed  f)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceSeed.o.png) - [reduceWith](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceWith.o.png) - [repeat()](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatInf.o.png) - [repeat(long)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatCount.o.png) - [repeatUntil](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatUntil.o.png) - [replay()](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.png) - [replay(int)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.n.png)   - [replay(int  long  TimeUnit)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.nt.png) - [replay(int  long  TimeUnit  Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.nts.png) - [replay(int  Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ns.png) - [replay(long  TimeUnit)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.t.png) - [replay(long  TimeUnit  Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ts.png) - [replay(Scheduler)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.s.png)  Images in https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-355986927 . This PR updates the marble diagrams of the 8  Observable.replay()  overload that take a  Function  and various other parameters:  - [no arguments](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.f.png) - [scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fs.png) - [bufferSize](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fn.png) - [bufferSize  scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fns.png) - [time](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ft.png) - [time  scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fts.png) - [bufferSize  time](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fnt.png) - [bufferSize  time  scheduler](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fnts.png)  Images in https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-356286139 . This PR adds  mergeDelayError  overloads to  Maybe  and  Single   the infrastructure was there from the beginning but the  delayErrors == true  settings were not exposed publicly.  -  Maybe.mergeDelayError(Publisher  int)  -  Single.mergeDelayError(Iterable)  -  Single.mergeDelayError(Publisher)  -  Single.mergeDelayError(SingleSource  SingleSource)  -  Single.mergeDelayError(SingleSource  SingleSource  SingleSource)  -  Single.mergeDelayError(SingleSource  SingleSource  SingleSource  SingleSource) This PR adds more detailed JavaDoc descriptions to the various  XSubject  types.  Some of them are missing a marble diagram which will be created (or found) in a separate PR after this PR.  The  package-info.java  has been extended as well. More marbles for  Observable :  - [retry(int)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.n.png) - [retry(BiFunction)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.ne.png) - [retry(Predicate)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.e.png) - [retry(int  Predicate)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.nfe.png) - [retryUntil(BooleanSupplier)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retryUntil.o.png) - [share](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishRefCount.o.png) - [switchMapSingle](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapSingle.o.png) - [switchMapSingleDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapSingleDelayError.o.png)  Images in https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-356560596 . This is the final part of the  Observable  marble fixes and additions as planned in #5319.  - [toList(Callable)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toList.o.c.png) - [toFlowable(BUFFER)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.buffer.png) - [toFlowable(DROP)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.drop.png) - [toFlowable(LATEST)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.latest.png) - [toFlowable(ERROR)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.error.png) - [toFlowable(MISSING)](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.missing.png) - [unsubscribeOn](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/unsubscribeOn.o.png) - Fixed position and spacing of the marbles in the  zipWith  overloads (no image change).  Images in https://github.com/ReactiveX/RxJava/issues/5319#issuecomment-356630375 . The PR fixes the resource management in the  buffer  operator that uses other reactive sources to indicate when a buffer starts and ends. Both  Flowable  and  Observable  implementations had to be fixed.  Fixes: #5809 This PR adds the missing marble diagrams to the various  Subject  and  Processor  implementations:  ### AsyncSubject  ![AsyncSubject](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/AsyncSubject.png)  ### PublishSubject  ![PublishSubject](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/PublishSubject.png)  ### ReplaySubject  ![ReplaySubject1](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplaySubject.u.png) ![ReplaySubject2](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplaySubject.ue.png) ![ReplaySubject3](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplaySubject.n.png) ![ReplaySubject4](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplaySubject.t.png) ![ReplaySubject5](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplaySubject.nt.png)  ### CompletableSubject  ![CompletableSubject](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/CompletableSubject.png)  ### SingleSubject  ![SingleSubject](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/SingleSubject.png)  ### MaybeSubject  ![MaybeSubject](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/MaybeSubject.png)  ### AsyncProcessor  ![AsyncProcessor](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/AsyncProcessor.png)  ### PublishProcessor  ![PublishProcessor](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/PublishProcessor.png)  ### ReplayProcessor  ![ReplayProcessor1](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplayProcessor.u.png) ![ReplayProcessor2](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplayProcessor.ue.png) ![ReplayProcessor3](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplayProcessor.n.png) ![ReplayProcessor4](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplayProcessor.t.png) ![ReplayProcessor5](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplayProcessor.nt.png) The PR adds a  try-catch  around the System property lookup inside the  RxJavaPlugins  in case a security manager prevents reading arbitrary property entries.  This mainly affects the  rxjava.plugin.[index].class  lookup which were introduced due to the 31 character key limit on Android.  However  when running in a container such as Tomcat  a security manager may prevent reading these type of prefixed entries (where  [index]  can t be known upfront)  crashing the initialization.  **Update**:  The  System.getProperties()  can also fail  therefore  retrieving the properties has been factored out into a separate method that returns an empty properties.  Fixes #5819. This PR improves the wording of the  Flowable.share()  and  Observable.share()  operators and fixes a JavaDoc link display mistake:  ![image](https://user-images.githubusercontent.com/1269832/35439076-7a9816c4-0299-11e8-97ca-462238c6489f.png) This PR fixes the  Observable.blockingIterable(int)  marble by using the  blockingIterable  redone earlier.  In addition  the PR adds a marble diagram to  Observable.blockingLatest :  ![blockingLatest](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingLatest.o.png) This PR updates the  Flowable.just  and  Observable.just  JavaDocs to clarify its behavior  namely it re-emits a constant reference and does not compute it. In addition  links to the other typical source operators are added. The redundant sentence about  just  were removed as well. The  Observable.switchMap  had bad logic in its main  onError  handler which didn t dispose the current inner  Observable .  The  Flowable  version didn t have this logic error. Both variants received an unit test to verify the correct behavior.  Fixes #5832. The  SingleSubject  JavaDoc was derived from the  MaybeSubject  JavaDoc and thus some mentions of  onComplete  remained in there. This PR fixes copy-paste errors. The PR clarifies the comparison and retention behavior of the  distinct  and  distinctUntilChanged  operators (in both  Flowable  and  Observable ). This PR improves the JavaDoc of the 4 RxJava main consumer types:  -  Observer  -  SingleObserver  -  MaybeObserver  -  CompletableObserver This PR adds more details to the  Scheduler  and  Worker  API  rewords some older sentences and fixes a few mistakes in others.  In addition  the wording of the  SchedulerRunnableIntrospection  felt a bit clumsy and has been updated as well. This PR explains the properties of the 5 specifc  Emitter  types in more details:  - error handling - resource handling - concurrent use aspects - the difference between  Disposable  and  Cancellable  resource handling - terminal state effects This PR adds specialized overloads to the  concatWith  operator in  Flowable  and  Observable .  If accepted  the marbles will be updated in a separate PR.  Related: #5350. This PR adds specialized overloads to the  mergeWith  operator in  Flowable  and  Observable .  If accepted  the marbles will be updated in a separate PR.  Related: #5350. - more  Maybe  operators:  onTerminateDetach    repeat    retry  - fixed missing  Backpressure:  entries of the javadoc where the base type uses Flowable/Publisher - new base type source parser and check for javadoc mistakes: wrong type mentions  a/an use - fixes of those javadoc mistakes This PR improves the wording and details of the  Maybe.fromCallable  operator s JavaDoc. Add notes to the following operators to state their sources has to be finite. It has been already done to  toList  in #5465.  -  collect  -  collectInto  -  reduce  -  reduceWith  -  toMap  -  toMultimap  -  toSortedList This PR replaces the individual race-test loop counts with global constants and removes the unnecessary custom  Scheduler  value from the invocations of  TestHelper.race() .  The default loop count is now 2500 and should elimitate the +/- 0.1% coverage fluctuations. - Fix missed javadoc mistakes  fix the checker that hid those mistakes in instance methods  javadoc due to a bug - add  Maybe.takeUntil This PR adds the last couple of  Maybe  operators  timeout  and  unsubscribeOn .  @abersnaze Let me know if I missed an operator or you want some overload.  In the subsequent PRs  I ll change the return types of some classical operators to better indicate the cardinality they have ( Single    Completable ). This PR adds about ~100 Reactive-Streams Test Compatibility Kit (TCK) tests of RxJava s most relevant operators and operation modes.  The PR also contains a behavior fix for  unsubscribeOn  that now stops propagating events if the cancelled because it may take arbitrary time for the scheduled cancellation to reach the upstream which generally keeps emitting in the meantime. The definition of multiple external links was wrong in  build.gradle  where the  options.links()  is actually defined as  String...  and multiple calls are not additional. This made the generated JavaDoc not have links to the JDK types. The fix now properly uses the varargs of the method. In addition  somehow the plain  http://  still wouldn t generate the proper links probably because they are redirected to  https://  for which the javadoc tool is not prepared.  In addition  4 dangling  <p>  tags were showing up as warnings and have been removed. This PR expands the documentation of the  Flowable.lift()  operator used for inserting custom operators into flows in a functional and fluent fashion.  The other reactive base classes feature similar  lift()  operators for which the text can be adapted and contributed in a separate PR once the content of this PR is stabilized by review feedback.  Related: #5862 Improve the JavaDoc of the  {Observable | Maybe | Single | Completable}.lift()  operator  adapting the text from #5863. This PR adds the  Flowable.switchMapCompletable  and  Flowable.switchMapCompletableDelayError  operators as requested by #4853.  The associated new marbles are:  ![switchMapCompletable](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapCompletable.f.png)  ![switchMapCompletableDelayError](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapCompletableDelayError.f.png) This PR adds the  Flowable.concatMapCompletable  and  Flowable.concatMapCompletableDelayError  operators as requested by #4853.  The marbles will be updated in a separate PR. This PR adds operators that allow concatenating a mapped sequence of  Maybe s or  Single s  with or without delaying their errors:  -  concatMapMaybe  (+1 overload with prefetch) -  concatMapMaybeDelayError  (+2 overloads with error mode and prefetch) -  concatMapSingle  (+1 overload with prefetch) -  concatMapSingleDelayError  (+2 overloads with error mode and prefetch)  They are in the same PR as the  Single  variant s implementation is practically the  Maybe  implementation minus the  onComplete  case.  Their marbles will be updated in a separate PR.  Originally requested in #4853. This PR adds  Flowable  operators that allow switching between a mapped sequence of  Maybe s or  Single s  with or without delaying their errors:  -  switchMapMaybe  -  switchMapMaybeDelayError  -  switchMapSingle  -  switchMapSingleDelayError   They are in the same PR as the  Single  variant s implementation is practically the  Maybe  implementation minus the  onComplete  case.  Their marbles will be updated in a separate PR.  Originally requested in #4853. This PR ports the various  switchMapX  and  concatMapX  operators from #5870  #5871  #5872 and #5873 to  Observable :  -  concatMapCompletable  (replaced by the common implementation) -  concatMapCompletableDelayError  -  concatMapMaybe  -  concatMapMaybeDelayError  -  concatMapSingle  -  concatMapSingleDelayError  -  switchMapCompletable  -  switchMapCompletableDelayError  -  switchMapMaybe  -  switchMapMaybeDelayError  -  switchMapSingle  (dedicated implementation) -  switchMapSingleDelayError  (dedicated implementation)  This PR concludes the requested set of operators in #4853.  Marbles will be updated/adjusted in a separate PR. - Change the  Callable<Publisher<T>>  parameter of  timeout  to plain  Publisher<T>  to simplify the API surface  use  defer(Callable<Publisher<T>>)  as input instead - change the parameter order of  timeout  from  (long  TimeUnit  Publisher  Scheduler)  to  (long  Timeunit  Scheduler  Publisher)  to better match the general pattern of time-unit-scheduler. -  Observable.timeout  has been updated similarly - Add  FlowableAwaitOnSubscribeTck  to workaround the case when calling  onNext  (indirectly) from  onSubscribe  may be unexpected (plus randomly fails the observeOn TCK test). This PR improves the coverage of RxJava while adjusting some code paths and fixing other types of smaller bugs.  - Fix  Maybe.merge(Publisher)  to define a 1 element buffer only. - Fix  Maybe.mergeDelayError(Publisher)  to use the dedicated  FlowableFlatMapPublisher  similar to the plain  merge() . - In  Flowable.flatMap   checking for empty or cancelled arrays in  removeInner()  can be replaced with a length check. - Make sure in  Flowable.reduce(seed  f)  the terminal events can t be called a second time if the reducer crashes. - Turn the  FlowableReplay.MultiCastPublisher  into a  Flowable  and rename it to  MulticastFlowable . - Fix  FlowableWindowBoundary  not cancelling the upstream on a missing backpressure case  causing  NullPointerException . - Remove unused override of  accept()  in  FlowableWindowBoundary . - Remove the ineffective done flag from  OperatorWindowBoundaryOpenSubscriber . - Replace the timer CASs with the  replace()  call in  FlowableWindowTimed . - Remove the unused  RepeatWhen    ErrorMapperFilter  and  RetryWhen  components from  ObservableInternalHelper . - Make sure the value is cleared at most once in  ObservableReduceSeedSingle . - Simplify  ObservableWindowBoundarySelector  s inner consumer s  onNext  handling. - Simplify  FlowableWindowBoundarySelector  s inner consumer s  onNext  handling. - Inline the finally actions in  InstantPeriodicTask.call() . - Fix  InstantPeriodicTask.setFirst  and  setRest  to return from the loop when the task has been cancelled to prevent excess looping and overwriting the  CANCELLED  indicator. - Inline the finally actions in  ScheduledDirectPeriodicTask.call() . - Slight adjustment of crash propagation in the  SchedulerWhen  constructor. - In  BehaviorProcessor   checking for empty or cancelled arrays in  remove()  can be replaced with a length check. - In  BehaviorSubject   checking for empty or cancelled arrays in  remove()  can be replaced with a length check. - fix some javadoc typos - replace javadoc mentioning of  unsubscribe  with either  cancel  or  dispose  - some minor algorithm reorganizations based on IntelliJ analysis - remove the mention of  Nbp  from the code and documentation (it refers to an earlier naming scheme for Observables and Observers) This PR contains some cleanup  javadoc fixes as well as the API changes for 1.2: ### Promote beta to standard -  rx.Observable.create(SyncOnSubscribe<S  T>)  -  rx.Observable.doOnRequest(Action1<Long>)  -  rx.Observable.flatMap(Func1<? super T  ? extends Observable<? extends R>>  Func1<? super Throwable  ? extends Observable<? extends R>>  Func0<? extends Observable<? extends R>>  int)  -  rx.Observable.flatMap(Func1<? super T  ? extends Observable<? extends R>>  int)  -  rx.Observable.flatMap(Func1<? super T  ? extends Observable<? extends U>>  Func2<? super T  ? super U  ? extends R>  int)  -  rx.Observable.flatMapIterable(Func1<? super T  ? extends Iterable<? extends R>>  int)  -  rx.Observable.flatMapIterable(Func1<? super T  ? extends Iterable<? extends U>>  Func2<? super T  ? super U  ? extends R>  int)  -  rx.Observable.fromCallable(Callable<? extends T>)  -  rx.Observable.toSingle()  - _ _ -  rx.Single.fromCallable(Callable<? extends T>)  - _ _ -  rx.SingleSubscriber<T>  - _ _ -  rx.observables.ConnectableObservable.autoConnect()  -  rx.observables.ConnectableObservable.autoConnect(int  Action1<? super Subscription>)  -  rx.observables.ConnectableObservable.autoConnect(int)  - _ _ -  rx.observables.SyncOnSubscribe<S  T>  - _ _ -  rx.subjects.AsyncSubject.getThrowable()  -  rx.subjects.AsyncSubject.getValue()  -  rx.subjects.AsyncSubject.hasCompleted()  -  rx.subjects.AsyncSubject.hasThrowable()  -  rx.subjects.AsyncSubject.hasValue()  - _ _ -  rx.subjects.BehaviorSubject.getThrowable()  -  rx.subjects.BehaviorSubject.getValue()  -  rx.subjects.BehaviorSubject.getValues()  -  rx.subjects.BehaviorSubject.getValues(T[])  -  rx.subjects.BehaviorSubject.hasCompleted()  -  rx.subjects.BehaviorSubject.hasThrowable()  -  rx.subjects.BehaviorSubject.hasValue()  - _ _ -  rx.subjects.PublishSubject.getThrowable()  -  rx.subjects.PublishSubject.hasCompleted()  -  rx.subjects.PublishSubject.hasThrowable()  - _ _ -  rx.subjects.ReplaySubject.getThrowable()  -  rx.subjects.ReplaySubject.getValue()  -  rx.subjects.ReplaySubject.getValues()  -  rx.subjects.ReplaySubject.getValues(T[])  -  rx.subjects.ReplaySubject.hasAnyValue()  -  rx.subjects.ReplaySubject.hasCompleted()  -  rx.subjects.ReplaySubject.hasThrowable()  -  rx.subjects.ReplaySubject.hasValue()  -  rx.subjects.ReplaySubject.size()  ### Promote experimental to standard  None. ### Promote to beta -  rx.BackpressureOverflow  -  rx.Observable.concatDelayError(Iterable<? extends Observable<? extends T>>)  -  rx.Observable.concatDelayError(Observable<? extends Observable<? extends T>>)  -  rx.Observable.concatEager(Iterable<? extends Observable<? extends T>>  int)  -  rx.Observable.concatEager(Iterable<? extends Observable<? extends T>>)  -  rx.Observable.concatEager(Observable<? extends Observable<? extends T>>  int)  -  rx.Observable.concatEager(Observable<? extends Observable<? extends T>>)  -  rx.Observable.concatEager(Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>)  -  rx.Observable.concatEager(Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>)  -  rx.Observable.concatEager(Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>)  -  rx.Observable.concatEager(Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>)  -  rx.Observable.concatEager(Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>)  -  rx.Observable.concatEager(Observable<? extends T>  Observable<? extends T>  Observable<? extends T>  Observable<? extends T>)  -  rx.Observable.concatEager(Observable<? extends T>  Observable<? extends T>  Observable<? extends T>)  -  rx.Observable.concatEager(Observable<? extends T>  Observable<? extends T>)  -  rx.Observable.concatMapDelayError(Func1<? super T  ? extends Observable<? extends R>>)  -  rx.Observable.concatMapEager(Func1<? super T  ? extends Observable<? extends R>>  int  int)  -  rx.Observable.concatMapEager(Func1<? super T  ? extends Observable<? extends R>>  int)  -  rx.Observable.concatMapEager(Func1<? super T  ? extends Observable<? extends R>>)  -  rx.Observable.delaySubscription(Observable<U>)  -  rx.Observable.distinctUntilChanged(Func2<? super T  ? super T  Boolean>)  -  rx.Observable.mergeDelayError(Observable<? extends Observable<? extends T>>  int)  -  rx.Observable.onBackpressureBuffer(long  Action0  Strategy)  -  rx.Observable.switchMapDelayError(Func1<? super T  ? extends Observable<? extends R>>)  -  rx.Observable.switchOnNextDelayError(Observable<? extends Observable<? extends T>>)  -  rx.Observable.toCompletable()  -  rx.Observable.toSortedList(Func2<? super T  ? super T  Integer>  int)  -  rx.Observable.toSortedList(int)  -  rx.Observable.using(Func0<Resource>  Func1<? super Resource  ? extends Observable<? extends T>>  Action1<? super Resource>  boolean)  - _ _ -  rx.observables.BlockingObservable.subscribe()  -  rx.observables.BlockingObservable.subscribe(Action1<? super T>  Action1<? super Throwable>  Action0)  -  rx.observables.BlockingObservable.subscribe(Action1<? super T>  Action1<? super Throwable>)  -  rx.observables.BlockingObservable.subscribe(Action1<? super T>)  -  rx.observables.BlockingObservable.subscribe(Observer<? super T>)  -  rx.observables.BlockingObservable.subscribe(Subscriber<? super T>)  - _ _ -  rx.Completable  - _ _ -  rx.Single.defer(Callable<Single<T>>)  -  rx.Single.delay(long  TimeUnit  Scheduler)  -  rx.Single.delay(long  TimeUnit)  -  rx.Single.delaySubscription(Observable<?>)  -  rx.Single.doAfterTerminate(Action0)  -  rx.Single.doOnError(Action1<Throwable>)  -  rx.Single.doOnSubscribe(Action0)  -  rx.Single.doOnSuccess(Action1<? super T>)  -  rx.Single.doOnUnsubscribe(Action0)  -  rx.Single.lift(Operator<? extends R  ? super T>)  -  rx.Single.onErrorResumeNext(Func1<Throwable  ? extends Single<? extends T>>)  -  rx.Single.onErrorResumeNext(Single<? extends T>)  -  rx.Single.toBlocking()  -  rx.Single.toCompletable()  -  rx.Single.using(Func0<Resource>  Func1<? super Resource  ? extends Single<? extends T>>  Action1<? super Resource>  boolean)  -  rx.Single.using(Func0<Resource>  Func1<? super Resource  ? extends Single<? extends T>>  Action1<? super Resource>)  - _ _ -  rx.exceptions.CompositeException.CompositeException(Throwable...)  - _ _ -  rx.exceptions.Exceptions.throwOrReport(Throwable  Observer<?>  Object)  -  rx.exceptions.Exceptions.throwOrReport(Throwable  Observer<?>)  -  rx.exceptions.Exceptions.throwOrReport(Throwable  SingleSubscriber<?>)  - _ _ -  rx.singles.BlockingSingle<T>   ### Removed -  rx.Observable.extend(Func1<OnSubscribe<T>  R>)  -  rx.Observable.fromAsync()  - _ _ -  rx.Completable.CompletableSubscriber  -  rx.Completable.CompletableOnSubscribe  -  rx.Completable.CompletableLift  -  rx.Completable.CompletableTransform This PR improves the algorithms of the  Observable.timeout(time)  and  Observable.timeout(selector)  operators to match their  Flowable  counterparts implemented in #5661.  In addition  coverage of the  Flowable  counterparts have been improved by synchronizing the unit tests.  Note that they were the last users of  ObserverFullArbiter  and  FullArbiterObserver  which are now removed.  Closes #5882. This PR fixes the upstream handling in  Observable.window(ObservableSource)  and  Observable.window(Callable<ObservableSource>)  operators to make sure if both the main output and the inner windows have been disposed  the upstream is also disposed.  Fixes #5881.  *Remark:*  There are a couple of  w != null  checks showing up as partially covered. In theory  with the right interleaving   w  can become  null   but unfortunately the usual  TestHelper.race()  testing is unlikely to trigger that case. There would be a higher chance with 3 threads (one disposing  one completing the main and one completing the inner window) but the current CI is effectively 1.5 - 2 cores/threads that tend to not produce a thorough interleaving. This PR fixes the upstream handling in  Flowable.window(Publisher)  and  Flowable.window(Callable<Publisher>)  operators to make sure if both the main output and the inner windows have been cancelled  the upstream is also cancelled.  Related: #5887  #5881.  In addition  the Jacoco code coverage has been updated to 0.8.0 mainly due to the [automatic filtering of difficult-to-impossible code paths](https://github.com/jacoco/jacoco/releases/tag/v0.8.0). This PR improves the coverage of various components and contains the following additional fixes:  - Remove a very unlikely cancellation check in  FlowableConcatMapEager . - Improve backpressure tracking in  FlowablePublishMulticast  to avoid atomic decrement per items emitted (part of  publish(Function) ). - Improve check for empty or terminated state in  FlowablePublishMulticast  by using the array length. -  UnicastProcessor  termination to use a one-step  getAndSet  -  BehaviorSubject  termination to use a one-step  getAndSet  - Remove impossible try-finally in  BehaviorSubject.setCurrent  as the body could never crash. Improve the coverage of various components  fix impossible paths and other fixes. See the comments attached to the code changes. - Make internal naming of components consistent with the base reactive type - move  io.reactivex.internal.subscribers.flowable.*  to  io.reactivex.internal.subscribers  - move  io.reactivex.internal.subscribers.observable.*  to  io.reactivex.internal.observers In the bounded buffers of  ReplaySubject   the head reference may retain one extra item when the trimming happens. Nulling out this reference is not possible at this point because old consumers may be still walking through the underlying linked list of nodes. However  replacing a head with the same next pointer (which is always not null if value is not null) but no value will eventually let the value get GCd. This cleanup doesn t happen on every  onNext  because it doubles the node allocation and thus the overhead.  This PR modifies the code so that terminal events do perform this head swapping and introduces the  ReplaySubject.cleanupBuffer()  method to allow the user to perform the head swapping while the  ReplaySubject  is not yet terminated and the cleanup is needed.  If this type of change is accepted  the  ReplayProcessor  can also be refitted. For the  replay()  operators  the terminal cleanup can be implemented but the on demand cleanup can t as there is no API surface for its internal buffer available. This PR fixes an avoidable dataloss in the following subscriber-swap scenario with the  publish()  and  publish(Function<Flowable  Publisher>) .  When an  onNext  changes the current array of subscribers (an existing consumer cancelled or a new one arrived)  the change detection is delayed and items may get dropped even though a fresh consumer could take those values.  The algorithms were updated to fix this case as well as the emission tracking in  FlowableMulticastProcessor : a global  emitted  value is not good here after all (subscribers joining late would indicate an incorrect aggregate demand and get overflown).  One of the advanced uses of  publish(Function)  is to implement consumption mode changes by having a mode cancel the subscription to the shared  Flowable  and synchronously subscribe a new consumer with a different behavior.   The discovery of this shortcoming was due to a special transformation pattern: apply a transformer if the source is not empty  and in this case  deliver all items of it.     java FlowableTransformer<T  U> transformer = ... source.publish(shared ->    // let s see if there is at least 1 source item    shared.take(1)    // if there is one item  stop this phase and keep the item    .concatMap(first ->        // given the very first item  apply the transformation        // on the  original  sequence by reattaching the first        // item to the rest of the source        transformer.apply(shared.startWith(first))    ) ) .subscribe(/* ... */) Specify in both  Flowable  and  Observable  that a terminal notification item or a regular terminal signal ends the flow.  Fixes: #5261 This is a follow-up PR to #5892 in order to avoid item retention in the head node. For the  ReplayProcessor   the cleanup can be triggered with  cleanupBuffer . For the  replay()  operators  such trigger is not possible. However  the terminal events will perform the cleanup internally at least. Since  Observable  is not backpressured  the  flatMap  of it has to manage the buffering of inner sources so that only a limited number of them are active at the same time. However  when most outstanding inner sources were scalar ( just()  is such a source) but the drain loop was busy  the operator overflow its bounded scalar queue (as it is supposed to be holding at most maxConcurrency scalar items)  causing an  IllegalStateException .  The PR fixes this corner case by making sure the  tryScalarEmit  returns false if it had to queue up the scalar  which in turn prevents the next inner source to be subscribed to until the queued item is cleared. In addition  the terminal state check has to include the buffer holding the remaining inner sources: being done  having an empty scalar queue and having no active inner observers is just not enough.   Flowable.flatMap  is not affected as it uses backpressure to ensure only a limited number of sources or scalars are mapped in.  Originally reported in the chat of this [StackOverflow question](https://stackoverflow.com/q/49151111/61158):       AndroidRuntime: FATAL EXCEPTION: RxCachedThreadScheduler-1  Process: com.hackerli.girl  PID: 6030  java.lang.IllegalStateException: Scalar queue full?!  at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.tryEmitScalar(ObservableFlatMap.java:250)  at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.subscribeInner(ObservableFlatMap.java:146)  at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:475)  at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:323)  at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.onComplete(ObservableFlatMap.java:579)  at io.reactivex.internal.observers.BasicFuseableObserver.onComplete(BasicFuseableObserver.java:119)  at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeOnObserver.onComplete(ObservableSubscribeOn.java:68)  at retrofit2.adapter.rxjava2.BodyObservable$BodyObserver.onComplete(BodyObservable.java:66)  at retrofit2.adapter.rxjava2.CallExecuteObservable.subscribeActual(CallExecuteObservable.java:47) at io.reactivex.Observable.subscribe(Observable.java:11442)  at retrofit2.adapter.rxjava2.BodyObservable.subscribeActual(BodyObservable.java:34)  at io.reactivex.Observable.subscribe(Observable.java:11442)  at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96)  at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:571)  at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66)  at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57)  at java.util.concurrent.FutureTask.run(FutureTask.java:237)  at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:269)  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)  at java.lang.Thread.run(Thread.java:818) This PR adds two benchmarks that measure the synchronous and asynchronous behavior of  Flowable.flatMap  and  Flowable.flatMapCompletable  when both are run with a  Completable  source.  Apart from the  item == 1  case  which is due to lack of scalar optimizations with  flatMapCompletable   the  flatMapCompletable  is faster by a good margin:  ![image](https://user-images.githubusercontent.com/1269832/37175444-de62c1fe-2319-11e8-90ce-1f0b0dbd661b.png)  I d say the asynchronous use is slightly faster in general with  flatMapCompletable :  ![image](https://user-images.githubusercontent.com/1269832/37175490-fa38bd8e-2319-11e8-84ff-e01d1ec18129.png)  -----------  Originally  this PR started out as an attempt to optimize the inner consumer tracking in  flatMapCompletable  when the  maxConcurrency  is non-default by using a special containers for 1..8 instead of the  CompositeDisposable . Unfortunately  this made it slightly slower in general (PR column):  ![image](https://user-images.githubusercontent.com/1269832/37175604-4b4c8bb0-231a-11e8-8f28-a18b364c4d64.png)  The async benchmark is within +/- 3% most of the time  and generally inconclusive.  ![image](https://user-images.githubusercontent.com/1269832/37175638-64e9e806-231a-11e8-8c42-682c53b986e7.png)  An additional test method was added to verify the new tracking classes  which is left as an additional mean to verify  flatMapCompletable  s behavior in general. When a  singleOrError  is followed by  toFlowable()   the assembly process switches the  Flowable->Single  operator into a  Flowable->Flowable  operator implementing the  singleOrError  behavior (saving the back-and-forth type conversion). The backing implementation was shared with  singleElement  and as such  did not properly handle the  orError  case for an empty source. The PR fixes the lack of  NoSuchElementException  in this case.  Fixes #5903.  The  Observable  variant doesn t have such optimization but the test has been converted to make sure  Observable  is verified for this aspect in case the optimization is implemented with it in the future. This PR fixes a couple of logical errors and cleans up some other components as well as improves the coverage of some classes. See the change comments below about the relevant details. Add an unit test that scans the unit test files for common local variable misnaming due to copy-pasting between the types  such as:  -  TestObserver ts  <->  TestSubscriber to  -  PublishSubject pp  <->  PublishProcessor ps   See the new  CheckLocalVariablesInTests  for other patterns described with a regexp. Improve coverage of RxJava internal components. See the change explanation as comments below. This PR adds JMH benchmarks to measure operators mapping onto other types  such as  flatMapCompletable    concatMapSingle   etc. In addition  two new benchmarks were added to measure the  flatMapIterable  performance in additional situations.  #### Baseline results  i7 4770K  Windows 7 x64  Java 8u162  [JMH Compare GUI](https://github.com/akarnokd/jmh-compare-gui/releases/tag/v1.3.2) workspace file: [xmapz_ws.xml](https://gist.github.com/akarnokd/317e2d38128f45c8fbb1ec8ebd20d970)  The first diagram compares the dedicated  plain (same inner type as the outer type) and conversion-based flows:  ![image](https://user-images.githubusercontent.com/1269832/37431058-6df2d0f2-27d4-11e8-9d6a-b9d8a0f34e0b.png)  The switchMap-based  Observable  operators look like they could use some optimizations. Overall   count == 1  is not optimized with the dedicated versions.  From the  Observable  s perspective:  ![image](https://user-images.githubusercontent.com/1269832/37431169-c1f69d46-27d4-11e8-8159-c598e7f50e68.png)  Looks like the  concatMapX  operators could use some optimizations.  The  flatMapIterable  measures are as follows:  ![image](https://user-images.githubusercontent.com/1269832/37431246-00fab8ba-27d5-11e8-94b5-67b94e1869a7.png)  The  Flowable  version seem to be considerably slower  probably not explainable due to backpressure overhead. This PR changes the return type of  last()  to  Single<T>  and updates the relevant locations.  Originally  it was implemented as  takeLast(1).single()  so to reduce impact  all other original uses now have this inlined. This PR changes the return type of  any()  and  all()  to  Single .  I ve also did a small change to  TestObserver  by having it implement the other  XObserver  types. This resulted in one extra method  onSuccess  to be added but now you can subscribe  TestObserver  to  Single    Maybe  and  Completable  without conversion yet still  test()  them with the same convenient API.      java Flowable.range(1  10).any(v -> true).test().assertResult(true) This PR reduces the overhead in the  Observable.concatMapCompletable  operator by:  - adding front-queue fusion to eliminate queue allocations (although this didn t improve the performance beyond a +/- 3% noise)  - moving the  error  and  errorMode  fields into local variables  saving on the mandatory volatile re-read of other fields  - adding a scalar shortcut in case the upstream is known to be 0-1.  #### Benchmark comparison:  i7 4770K  Windows 7 x64  Java 8u162  The PR improves the dedicated case considerably:  ![image](https://user-images.githubusercontent.com/1269832/37437588-44960732-27ee-11e8-9f91-00c3313ac60b.png)  and it is now better across the board compared to a  toFlowable  conversion and the main  concatMap :  ![image](https://user-images.githubusercontent.com/1269832/37437618-7490a244-27ee-11e8-99de-cb20d5828555.png) This PR adds scalar source optimizations to  Observable  operators:  -  concatMapCompletable  -  concatMapSingle  -  concatMapMaybe  -  switchMapCompletable  -  switchMapSingle  -  switchMapMaybe   #### Benchmark  i7 4770K  Windows 7 x64  Java 8u162  The baseline is taken from #5914. The target is to be faster than using the plain  concatMap  or  switchMap  with a  toObservable  conversion. The apparent shortcomings of longer  concatMapMaybe  and  concatMapSingle  will be addressed in a subsequent PR.  ![image](https://user-images.githubusercontent.com/1269832/37457267-c41bb4a4-2841-11e8-87a4-3951514a7f8f.png) This PR makes the following operators return  Single : -  collect  -  collectInto  -  toList  -  toSortedList  -  toMap  -  toMultimap   and changes the documentation to mention  Single  instead as well. (There are some whitespace removals I forgot previously). This PR improves the performance of the  Observable.switchMap  operator by adding fusion support as well as upgrading the  Completable  and  Single  conversion to  Observable  to be fuseable. The PR also fixes an error in the  DeferredScalarDisposable  implementation as the protocol requires calling with  null .  The plain ( Observable.switchMap(Observable) ) conversion has promising performance improvements:  ![image](https://user-images.githubusercontent.com/1269832/37464461-ba6d5c0c-2858-11e8-8aa0-96d53350cfed.png)  The conversion  Observable.switchMap(Maybe.toObservable)  has promising performance improvements:  ![image](https://user-images.githubusercontent.com/1269832/37464488-cf9b1290-2858-11e8-8ac7-462a58f61a13.png)  The conversion  Observable.switchMap(Completable.toObservable)  is also promising  but there is a 11% loss in the scalar case for some reason:  ![image](https://user-images.githubusercontent.com/1269832/37464621-2ad6b1c8-2859-11e8-9a0a-d34c8ff8048b.png)  Finally  the conversion   Observable.switchMap(Single.toObservable)  got a bigger hit for the scalar case  21% loss  but the rest are impressive:  ![image](https://user-images.githubusercontent.com/1269832/37464636-41ea983e-2859-11e8-9258-6c1c85ee8347.png) Text is not allowed between  <dl>  and its child tags.  Fixes #5916. Renamed the operator in the box. For #5788.  ![flatMapPublisher](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMapPublisher.png) This PR fixes the accidental logical mistake in the  cancel / dispose  logic of the new  concatMapSingle  and  concatMapMaybe  operators of both  Flowable  and  Observable  where the internal queue cleanup should happen in a serialized fashion only  which is the state when the work-in-progress counter changes from 0 to 1 ensured by a  ==  check.  Fixes #5927 This PR updates many  Flowable  operators to return  Single    Maybe  or  Completable : -  count()  ->  Single  -  elementAt()  ->  Maybe  -  elementAt(T)  ->  Single  -  first(T)  ->  Single  -  firstElement()  ->  Maybe  -  ignoreElements()  ->  Completable  -  reduce(Callable  BiFunction)  ->  Single  -  reduceWith(U  BiFunction)  ->  Single  -  single(T)  ->  Single  -  singleElement()  ->  Maybe   and deletes  Flowable.toSingle    Flowable.toMaybe  and  Flowable.toCompletable .   Flowble.reduce(BiFunction)  was not yet changed from  Single  to  Maybe  (to allow empty sources to be reduced to empty Maybe).  Related: #4321 This PR adds an **Error handling** section to various  blockingX  operators to specify checked exceptions from their source will be wrapped into  RuntimeException s. Rename-deprecate  Single.toCompletable  to  ignoreElement  to be in line with the same operator in the other classes and also indicate more clearly in the method name that it ignores the element.  In addition  the marbles have been updated on both  Single  and  Maybe  of this operator.  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.ignoreElement.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.ignoreElement.png) This PR fixes a bunch of typos (in many files) and grammar mistakes in  Flowable  (based on Grammarly checks).  The PR also fixes the  JavadocWording  checks to start from the beginning of the method s javadoc as well as checking for cross-line a/an typos. For some reason  when compiling RxJava with Java 9 or 10 and target 8  there is an implicit  Objects.requireNonNull  added by the compiler to  us.new X  which makes AnimalSniffer detect a non-Java 6 API usage. Interestingly  this does not happen with:  - Java 8 target 6   - Java 8 target 8   - Java 9 target 6   - Java 9 target 9   - Java 10 target 6   - Java 10 target 9  - Java 10 target 10  or AnimalSniffer doesn t detect it for non-8 targets somehow. I know that the latest AnimalSniffer doesn t work with (some?) Java 9 class files  but it doesn t explain why the fully supported Java 8 target 8 does not trigger this error but Java 9 target 8 does.  I have reported this anomaly as a potential javac bug.  The build matrices and outcomes for RxJava 2 can be found here: https://travis-ci.org/akarnokd/RxJava2_9/builds The internal queue of  Observable.concatMapSingle  was incorrectly the bounded one from its  Flowable  counterpart  causing it to drop upstream items if the current  Single  was delayed. The right queue for  Observable s is the  SpscLinkedArrayQueue .  Added unit tests to both  concatMapSingle  and  concatMapMaybe  to verify the correct behavior.  Fixes: #5971. This PR fixes a deadlock issue with the  refCount  operator when a subscription leads to a blocking execution while the lock is being held  preventing other subscription or cancellation from executing on other threads.  The bug was discovered as the cause of a reported hang on [the Google groups](https://groups.google.com/forum/#!topic/rxjava/G0axw5PbOF4).  The [code](https://github.com/akarnokd/RxJava2Extensions/blob/master/src/main/java/hu/akarnokd/rxjava2/operators/FlowableRefCountTimeout.java) has been developed in the extensions project where the operator has [more features](https://github.com/akarnokd/RxJava2Extensions#flowabletransformersrefcount). The overloads supporting these features can be added in a separate enhancement PR. The PR cleans up some wording around  Single source  and  Maybe source   plus removes some unnecessary annotations. This PR makes sure errors emitted by the upstream just after the  Flowable.take  has received the specified amount of items get routed to  RxJavaPlugins.onError .   Observable.take()  and  Flowable.limit()  were already doing this. Added unit tests to verify the behavior across the board. This PR adds the  throttleLatest  operator to  Observable  and  Flowable   also known as  conflate  (#4856): it is a combination of  throttleFirst  and  sample  whereby frequent items are sampled but the first item outside the sampling window will be emitted immediately:  ![throttleLatest](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLatest.png)  ![throttleLatest](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLatest.se.png)  Resolves: #4856 Replaces: #5968 The PR improves the wording of the abstract  subscribeActual  method across the base reactive types. This PR deprecates the  getValues()  and  getValues(T[])  methods in  AsyncSubject    BehaviorSubject    AsyncProcessor  and  BehaviorProcessor .  These methods were remnants of an early 2.x API design where  Subject  itself had these methods for the sake of  ReplaySubject   and  SerializedSubject  and thus every other subject type had to implement them. The listed subjects and processors above have at most one value accessible via  getValue()  which can then be assigned to an array index manually if needed. This PR adds some clarifications to the  blockingSubscribe  methods on  Flowable  and  Observable . - Remove  @NonNull  from a primitive type - Make the package-private  PeriodicDirectTask  final - Add  @NonNull  to other fields This PR exposes the additional  refCount  operation modes from #5975:  - Connect only when the specified number of  Subscriber s/ Observer s have subscribed - Disconnect when the given amount of time elapsed since the very last  Subscriber / Observer  cancelled/disposed. - The combination of both.  In addition  the original  refCount  received extra JavaDocs details. Fix  Flowable.switchMap  and  Observable.switchMap  to request for boundary fusion in order to prevent a thread-confined but otherwise fusion-capable sub-sequence from running on the unintended thread.  Fixes: #5990 This PR adds the  MulticastProcessor  from the [extensions project](https://github.com/akarnokd/RxJava2Extensions#multicastprocessor) to be a standard processor option.  This type of processor fills the gap of having a backpressure-coordinating processor type as  PublishProcessor  doesn t coordinate backpressure on its own and  Flowable.publish()  often can t be used because the upstream may not yet exist when the dowstream consumers are setup.  ![MulticastProcessor](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/MulticastProcessor.png)  Example:     java MulticastProcessor<Integer> mp = Flowable.range(1  10)     .subscribeWith(MulticastProcessor.create())   mp.test().assertResult(1  2  3  4  5  6  7  8  9  10)   // --------------------  MulticastProcessor<Integer> mp2 = MulticastProcessor.create(4)  mp2.start()   assertTrue(mp2.offer(1))  assertTrue(mp2.offer(2))  assertTrue(mp2.offer(3))  assertTrue(mp2.offer(4))   assertFalse(mp2.offer(5))   mp2.onComplete()   mp2.test().assertResult(1  2  3  4)       Resolves: #5999 This PR removes the accidental null checks on primitives in two  Observable  methods and adds a trap method to  ObjectHelper  to both highlight and fail the tests in case the null checks are still attempted. The method is marked as deprecated so it will also show up in (Eclipse s) problems window.  Replaces #6012  Resolves #6013 This PR adds JMH benchmarks to measure the overhead of  {Single|Maybe}.flatMap{Publisher|Observable}    {Single|Maybe}.flattenAs{Flowable|Observable}  and  Completable.andThen({Publisher|Observable}) .  ### Results   on i7 4770K  Windows 7 x64  Java 8u172  JMH 1.20 (larger is better):  #### comparing based on the final output type  ![image](https://user-images.githubusercontent.com/1269832/40439189-7effb8b6-5eba-11e8-9581-8bec8d770f40.png)  Observable should be generally lower overhead yet some cases it has more overhead.  #### comparing what to flatten  (**flatMapHide** = without fusion  **flatMap** = reactive source  **flattenAs** = list source)  ![image](https://user-images.githubusercontent.com/1269832/40439286-c07cf2ae-5eba-11e8-9692-4f6836f8b6cd.png)  The **hide** case is expected to have the most overhead  yet the two reactive classes have uneven boosts with a supposedly fuseable cases:  ![image](https://user-images.githubusercontent.com/1269832/40439592-ab3a8388-5ebb-11e8-9e4b-a0b4109452ce.png)  #### comparing based on source type  ![image](https://user-images.githubusercontent.com/1269832/40439448-3e4cfa08-5ebb-11e8-9655-14c4f097a3bc.png)   Single  and  Maybe  should be practically the same here  yet in some cases  Maybe  is quite worse. Also  Completable  should effectively win over the others on each line.   -------  Plenty of optimization opportunities. Fix the dispose behavior of the  Single.takeUntil  and  Maybe.takeUntil  operators.  Tests were also added to the other 3  takeUntil  variants (for  Completable   it is delegated to  amb ).  Fixes: #6018 This PR adds Reactive Streams TCK tests to:  -  MulticastProcessor  (both externally and internally refcounted  -  Single.flatMapPublisher  -  Maybe.flatMapPublisher  -  Completable.andThen(Publisher) This PR increases the timeout of the Reactive Streams TCK tests targeting  BehaviorProcessor  and  interval()  from 25ms to 50ms to have some slack on Travis-CI. This PR implements the following operators directly instead of conversions between base types:  -  Single.flatMapObservable  -  Maybe.flatMapObservable  -  Maybe.flatMapPublisher  -  Completable.andThen(Observable)  -  Completable.andThen(Publisher)   The  Single.flatMapPublisher  was reimplemented in #6021 already. This PR upgrades the  Observable.takeUntil  to a newer algorithm (the  Flowable  version is up-to-date).  Some unit test remnants from the v1 era were upgraded too as the new algorithm no longer disposes the source or other if they terminate on their own (the Reactive Streams specification doesn t allow that anyway). The JMH plugin 0.4.4 has some shortcomings that prevent the execution of unit tests on Windows 10 (and on some very restricted Linuxes). Version 0.4.5 has been fixed in this regard but it also requires Gradle 4.3.x. Unfortunately  there are no newer versions to the JMH plugin so this is likely as far as we can go with versions.  I ve also added a new benchmark to measure the overhead in  takeUntil . Here are the results:  i7 4790  Windows 10 x64  Java 8u172  JMH 1.20:      Benchmark                        Mode  Cnt         Score       Error  Units TakeUntilPerf.flowable          thrpt    5    341933 112   13328 573  ops/s TakeUntilPerf.flowable:items    thrpt    5  21128765 548  677544 832  ops/s TakeUntilPerf.observable        thrpt    5    366931 108    8202 644  ops/s TakeUntilPerf.observable:items  thrpt    5  10733841 643  112853 358  ops/s      The  observable  here uses an older algorithms & structure and is generally relaying half the items under the same time amonut than the  flowable  version. PR #6028  can then be evaluated with this benchmark. Add two missing  &gt   tags to avoid the javadoc tool warnings. Normally  overriding a method will reuse the JavaDoc unless specified directly on the new method. Unfortunately  when the base type is part of a javadoc exclude  such as everything below  **/internal   the documentation is not copied and public facing methods have no HTML documentation:  ![image](https://user-images.githubusercontent.com/1269832/40828381-b8cdd07e-6580-11e8-84cf-783f1cf892f9.png)  This PR copies the javadoc of the internal  DisposableContainer  onto  CompositeDisposable  so it shows up properly:  ![image](https://user-images.githubusercontent.com/1269832/40828451-ea8c4122-6580-11e8-8ad9-e2cd606d6a39.png)   The IDEs still show the documentation correctly. This PR updates many  Observable  operators to return  Single    Maybe  or  Completable : - count() -> Single - elementAt() -> Maybe - elementAt(T) -> Single - first(T) -> Single - firstElement() -> Maybe - ignoreElements() -> Completable - lastElement() -> Maybe - reduce(BiFunction) -> Maybe - reduce(Callable  BiFunction) -> Single - reduceWith(U  BiFunction) -> Single - single(T) -> Single - singleElement() -> Maybe  and deletes Observable.toSingle  Observable.toMaybe and Observable.toCompletable.  In addition   Flowable.reduce(BiFunction)  now returns  Maybe<T> .  Related: #4321 Resolved the following diagrams of #5806:  #### amb: missing diagram  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.amb.png)  #### ambArray: missing diagram  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.ambArray.png)  #### concat(Iterable): missing diagram  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.i.png)  #### concat(Publisher): missing diagram  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.p.png)  #### concat(Publisher  int): missing diagram  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.pn.png)  #### concatArray: missing diagram  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatArray.png)  #### concatArrayDelayError: indicate error delayed  1 marble per source  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatArrayDelayError.png)  #### concatArrayEager: missing diagram  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatArrayEager.png)  #### concatDelayError(Iterable): missing diagram  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatDelayError.i.png)  #### concatDelayError(Publisher): missing diagram  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatDelayError.p.png)  #### concatEager(Iterable): missing diagram  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEager.i.png)  #### concatEager(Publisher): missing diagram  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEager.p.png) This PR expands and adapts the JavaDocs of  AsyncProcessor    BehaviorProcessor    PublishProcessor    ReplayProcessor  and  UnicastProcessor  with the details of their already documented  Subject  variants.  In addition  some wording has been fixed with  UnicastSubject  as it was refering to plural  Observer s in some sentences even though it only supports one.  Since the basis of this expansion is copy-paste  please read through the changes carefully to verify the terminology and described behavior matches what s usually expected from  Flowable s/ FlowableProcessor s (i.e.  subjects don t have to deal with backpressure and thus nothing much to elaborate on that in a subject doc). Change the wording on the  blockingForEach()  method to clarify it runs the  Consumer  on the current thread. Since there is no onError callback  the extra sentence about the error behavior was removed. There is an error handling section already that explains it properly. This PR fixes a bug in all 4 specialized  concatMap  implementation that allows  null  to be emitted when the success signal of the inner source races with the dispose signal of the sequence.  Likely fixes: #6059 Add marble to  Maybe.hide() :  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.hide.png) This PR adds the missing dedicated  takeUntil  operator to  Completable .  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.takeuntil.c.png)  Previously  the same effect could be achieved via the  ambWith  but there are two benefits of a dedicated operator: - easier to discover based on the  takeUntil  operator in other types - more direct implementation unlike  ambWith  which is built upon an N-ary  amb  operator with additional overhead.  There was a feature request in #3708 some time ago but apparently the issue got closed off after  Single.takeUntil  was implemented. This PR expands the Javadocs of  Single    Maybe  and  Completable  where the latter also receives an explanation marble:  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.png)  Please let me know if there is any property worthy of mentioning in the class  JavaDocs as well as please look out for copy-paste mistakes. This PR adds the following marble diagrams to  Completable  operators (#5789):  #### amb  ambArray  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.ambArray.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.amb.png)  #### complete  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.complete.png)  #### concatArray  concat  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concatArray.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concat.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concat.p.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concat.pn.png)  #### defer  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.defer.png)  #### error  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.error.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.error.f.png) This PR adds marble diagrams (#5789) to the following operators as well as adds the missing  Completable.fromMaybe  operator ( fromX  of other types were already there  uses existing  Maybe.ignoreElement  s underlying implementation).  #### fromAction  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromAction.png)  #### fromCallable  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromCallable.png)  #### fromFuture  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromFuture.png)  #### fromMaybe  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromMaybe.png)  #### fromObservable  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromObservable.png)  #### fromPublisher  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromPublisher.png)  #### fromSingle  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromSingle.png)  #### mergeArray & mergeArrayDelayError  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeArray.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeArrayDelayError.png)  #### merge  (both  Iterable  and  Publisher  variants)  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.merge.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.merge.p.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.merge.pn.png)  #### mergeDelayError  (both  Iterable  and  Publisher  variants)  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeDelayError.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeDelayError.p.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeDelayError.pn.png)  #### never  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.never.png)  #### timer  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timer.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timer.s.png) This PR adds marble diagrams to various  Completable  operators:  #### wrap  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.wrap.png)  #### using  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.using.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.using.b.png)  #### ambWith  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.ambWith.png)  #### andThen  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.c.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.s.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.m.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.o.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.p.png)  #### as  to  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.as.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.to.png)  #### compose  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.compose.png)  #### cache  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.cache.png)  #### blockingAwait  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingAwait.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingAwait.t.png)  #### blockingGet  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingGet.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingGet.t.png) This PR improves the  Completable.delay()  operator internals  reducing allocation and indirection. This PR add even more missing marbles to  Completable  (tracked by #5789):  #### delay  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delay.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delay.s.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delay.sb.png)  #### doOnX  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnComplete.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnDispose.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnEvent.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnSubscribe.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnTerminate.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnError.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doAfterTerminate.png)  #### doFinally  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doFinally.png)  #### onErrorComplete  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onErrorComplete.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onErrorComplete.f.png)  #### onErrorResumeNext  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onErrorResumeNext.png)  #### onTerminateDetach  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onTerminateDetach.png)  #### mergeWith  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeWith.png)  #### concatWith  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concatWith.png)  #### observeOn  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.observeOn.png)  #### hide  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.hide.png) This PR adds a couple of more marble diagrams to  Completable  (#5789):  #### subscribeOn  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribeOn.png)  #### unsubscribeOn  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.unsubscribeOn.png)  #### toSingle  toSingleDefault  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toSingle.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toSingleDefault.png)  #### toFlowable  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toFlowable.png)  #### toMaybe  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toMaybe.png) This PR contains the final set of missing  Completable  marbles (#5789):  #### repeat  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.repeat.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.repeat.n.png)  -------------------------  #### repeatUntil  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.repeatUntil.png)  -------------------------  #### repeatWhen  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.repeatWhen.png)  -------------------------  #### retry  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.n.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.f.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.ff.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.nf.png)  -------------------------  #### retryWhen  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retryWhen.png)  -------------------------  #### startWith  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.startWith.c.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.startWith.o.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.startWith.p.png)  -------------------------  #### timeout  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timeout.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timeout.s.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timeout.c.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timeout.sc.png)  -------------------------  #### create  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.create.png)  -------------------------  #### unsafeCreate  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.unsafeCreate.png)  -------------------------  #### lift  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.lift.png)  -------------------------  #### subscribe  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribe.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribe.f.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribe.ff.png)  -------------------------  #### subscribeWith  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribeWith.png)  -------------------------  #### test  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.test.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.test.b.png) Couple of the  <dt><b>Error handling:</b></dt>  subheaders were missing from various  Completable.mergeX  operators in the JavaDocs. This PR promotes all  @Experimental / @Beta  APIs to standard with version number **2.2**.  (In addition  it also fixes remnant markers from earlier promotions in internal files.)  ### Operators  - ** Flowable **:    -  as    -  blockingSubscribe(...  prefetch)  + 2   -  concatMapCompletable  + 1   -  concatMapCompletableDelayError  + 2   -  concatMapMaybe  + 1   -  concatMapMaybeDelayError  + 2   -  concatMapSingle  + 1   -  concatMapSingleDelayError  + 2   -  concatWith  + 2   -  groupBy(...  evictingMapFactory)    -  limit    -  mergeWith  + 2   -  parallel  + 2   -  subscribe(FlowableSubscriber)    -  subscribeOn(...  requestOn)    -  switchMapCompletable    -  switchMapCompletableDelayError    -  switchMapMaybe    -  switchMapMaybeDelayError    -  switchMapSingle    -  switchMapSingleDelayError    -  throttleLatest  + 3   - ** Observable **:   -  as    -  concatMapCompletable  + 1   -  concatMapCompletableDelayError  + 2   -  concatMapMaybe  + 1   -  concatMapMaybeDelayError  + 2   -  concatMapSingle  + 1   -  concatMapSingleDelayError  + 2   -  concatWith  + 2   -  mergeWith  + 2   -  switchMapCompletable    -  switchMapCompletableDelayError    -  switchMapMaybe    -  switchMapMaybeDelayError    -  switchMapSingle    -  switchMapSingleDelayError    -  throttleLatest  + 3   - ** Maybe **:   -  mergeDelayError(Publisher  int)    -  as    -  switchIfEmpty  - ** Single **:   -  mergeDelayError  + 4   -  as    -  delay(...  delayError)  + 1   -  onTerminateDetach    -  retry(long  Predicate)    -  unsubscribeOn  - ** Completable **:    -  fromMaybe    -  as    -  onTerminateDetach    -  retry(long  Predicate)    -  takeUntil  - ** ConnectableFlowable **:   -  refCount  + 4 - ** ConnectableObservable **:   -  refCount  + 4 - ** ParallelFlowable **:   -  as    -  map(errorHandling)  + 1   -  filter(errorHandling)  + 1   -  doOnNext(errorHandling)  + 1   -  sequentialDelayError  + 1 - ** TestSubscriber / TestObserver ** (** BaseTestConsumer **):   -  assertValueAt    -  assertValuesOnly    -  assertValueSetOnly    -  assertValueSequenceOnly  - ** RxJavaPlugins **:   -  setOnParallelAssembly    -  getOnParallelAssembly    -  onAssembly(ParallelFlowable)  - ** Subject s/ FlowableProcessor s**:   -  BehaviorProcessor.offer    -  PublishProcessor.offer     -  ReplayProcessor.cleanupBuffer    -  ReplaySubject.cleanupBuffer    -  UnicastProcessor.create([...]  delayError)  + 1   -  UnicastSubject.create([...]  delayError)  + 1  ### Interfaces  -  CompletableConverter  -  CompletableEmitter  -  FlowableConverter  -  FlowableEmitter  -  FlowableSubscriber  -  MaybeConverter  -  MaybeEmitter  -  ObservableConverter  -  ObservableEmitter  -  SingleConverter  -  SingleEmitter  -  LambdaConsumerIntrospection  -  ParallelFlowableConverter  -  ParallelTransformer  -  SchedulerRunnableIntrospection   ### Enums  -  ParallelFailureHandling   ### Classes  -  OnErrorNotImplementedException  -  ProtocolViolationException  -  UndeliverableException  -  ParallelFlowable  -  MulticastProcessor   ### Other components  -  SchedulerSupport.SINGLE exception msg across  Reported on [Stackoverflow](http://stackoverflow.com/questions/39622458/flowableemitter-doesnt-signal-error-when-onnext-got-null).  There was no proper null check in the various emitters. I ve also unified the message pattern across all  create()  emitters. This PR adds benchmarks for measuring  just()  and  fromCallable()  when using  subscribeOn    observeOn  and  subscribeOn().observeOn()  with them. # Benchmark baseline - i7 4770K  Windows 7 x64  Java 8u102  JMH 1.13 - throughput ops/s  larger is better ## just  ![image](https://cloud.githubusercontent.com/assets/1269832/18817630/bf4c4c9a-8365-11e6-87ea-13b9e2f5303c.png)  ![image](https://cloud.githubusercontent.com/assets/1269832/18817657/69047e10-8366-11e6-9a63-6b0878e55097.png) ## fromCallable  ![image](https://cloud.githubusercontent.com/assets/1269832/18817631/c850e922-8365-11e6-8e7b-f60c2b9bdbaa.png)  ![image](https://cloud.githubusercontent.com/assets/1269832/18817654/5cfcd46e-8366-11e6-9eb7-50e1b872f377.png) ## just vs. fromCallable  ![image](https://cloud.githubusercontent.com/assets/1269832/18817632/d7109ac0-8365-11e6-9936-e287477965e5.png) This PR adds  Single.flattenAsObservable    Single.flattenAsFlowable    Maybe.flattenAsObservable  and  Maybe.flattenAsFlowable  to map a success value into an  Iterable  sequence and stream it as  Flowable  or  Observable . It is more efficient than  Single.toFlowable().flatMapIterable() . This PR introduces a new abstract internal class  BaseTestConsumer  which now hosts the  assertX  methods of  TestSubscriber  and  TestObserver  which were duplicates before. This PR improves the performance of  flatMapIterable  by inlining the consumption of the generated  Iterable . The performance improvement comes from direct iteration and emission plus removing the overhead of the regular  flatMap  as such source mappings are inherently synchronous. ### Benchmark  i7 4790  Windows 7 x64  Java 8u102  JMH 1.13  ops/s - bigger is better  ![image](https://cloud.githubusercontent.com/assets/1269832/18866111/a5a228b6-849e-11e6-9b53-c59df8f32d59.png)  10x overhead reduction in flattening a single element  Iterable .  ![image](https://cloud.githubusercontent.com/assets/1269832/18866190/187bce50-849f-11e6-9e44-473464457c3c.png)  Half the overhead compared to (an already optimized)  Flowable.flatMapIterable .  ![image](https://cloud.githubusercontent.com/assets/1269832/18866147/d93d6686-849e-11e6-9bdb-7837c55efddc.png)  Nice improvement on the cross-range benchmark (stream 1 million element split into N outer and M inner elements where N \* M = 1 million):  ![image](https://cloud.githubusercontent.com/assets/1269832/18866180/005367d4-849f-11e6-9925-9b9d2a33a618.png)  Also quite better than  Flowable.flatMapIterable . This PR enables operator fusion in  onBackpressureBuffer . The main benefit is that given a non-backpressured source  using  observeOn  now reuses  onBackpressureBuffer  s (un)bounded queue seamlessly. This PR cleans up the tests:  - Reduce stacktrace printouts due to undeliverable errors and turn them into assertions instead. - Rename local variables & arguments of  Subscriber s from  o  and  observer  to the proper  subscriber  - Rename local variables & arguments of  Flowable s from  o  and  observable  to the more appropriate  f  and  flowable  - Add more naming tests to  CheckLocalVariablesInTests  to support the previous two points. This PR improves the structure of the  onErrorResumeNext  operator by inlining the subscription-arbiter and not updating the outstanding request amount one by one. The change reduces the per-item overhead  some indirection cost and the memory cost (+8 bytes for the field  -16/-28 bytes due to the inlined header+field)  In addition  the null-check has been inlined into the resume function call so that the crash will now include the original exception as well as the NPE in a  CompositeException   just like almost all other cases throughout RxJava. This PR improves the internals of the  Completable.onErrorResumeNext  operator:  - Inline the  Disposable  management. - Reuse the same instance for observing the fallback  CompletableSource . - Report null return of the  errorMapper  the same way as a crash via  CompositeException . - The exceptions in the composite should be in the order **original** -> **mapper exception**. This PR cleans up the field namings and some local variable namings:  - Use  upstream  for the connection  Disposable  or  Subscription  instead of  d    s   etc.  including  AtomicReference<*>  declarations. - Use  downstream  for the consumer field name in operators instead of  actual  for example. - Fix one-two letter abbreviated naming to match the type  such as  Disposable s  ->  Disposable d   etc.  The  CheckLocalVariablesInTests  has been extended with the relevant regexp checks. This PR exposes the existing  delayError  capability of the  concatMapEager  operator as  concatArrayEagerDelayError  for both  Flowable  and  Observable .  In addition  the  concatArrayEager  and these new methods receive marble diagrams:  #### Observable  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEager.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEager.nn.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEagerDelayError.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEagerDelayError.nn.png)  #### Flowable  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEager.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEager.nn.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEagerDelayError.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEagerDelayError.nn.png)  Resolves: #6082   *(Sidenote: one of the validators had to be adjusted due to false positive it produced.)* This PR fixes the lack of boundary fusion marker in the  concatMap  and  publish  operators that can break the thread-confinement expectation when using  observeOn  upstream and a thread-sensitive operator:     java source.observeOn(scheduler)     .map(/* some thread-sensitive operation */)     .publish() // or concatMap      By default  these operators may call  poll  from any of the participating threads which would otherwise dequeue  observeOn  and execute  map  on that thread.  The fix adds the necessary flag to both operator s  onSubscribe  logic. For a temporary workaround  one should use  hide()  before such operators to make sure fusion doesn t happen.  Fixes: #6144 This PR cleans up some source code style inconsistencies:  - Rename some atomic-subscription fields to  upstream  (left out from #6129). - Make sure  @Test  methods are separated by at most one empty newline - Make sure a closing curly brace and an annotation is only followed by one empty newline. - Add a test that checks for the above. Clarify that  {TestObserver|TestSubscriber}.assertValueSet  checks for all received items to be in the provided set  but that set can contain additional elements that could have been received. Unit tests have been added to demonstrate the expected behavior.  Resolves: #6151. Fix the marble diagram of the event-mapping [ Maybe.flatMap ](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Maybe.html#flatMap-io.reactivex.functions.Function-io.reactivex.functions.Function-java.util.concurrent.Callable-) operator:  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMap.mmm.png)  Tracked in: #5806 Flowable.fromCallable  is one of [the oldest](https://github.com/ReactiveX/RxJava/commits/2.x/src/main/java/io/reactivex/internal/operators/flowable/FlowableFromCallable.java) 2.x operators and was overlooked when the handling of beyond-cancellation error delivery  aka the undeliverable exception handling was implemented across RxJava. This PR resolves this shortcoming by making it consistent with its sibling implementations.  Resolves: #6156 Some operators may call  dispose() / cancel  from  onError / onComplete  which could trigger a permature call to  worker.dispose()  that was about to happen anyway. This PR prevents this by moving the operator into its disposed/cancelled state before signaling the terminal event  thus a downstream  cancel() / dispose()  call won t trigger this premature cleanup.  Such premature cleanups may cause unwanted  Schedulers.io()  reuse in some scenarios.  Related: #6146 This PR adds detailed error message to the  UndeliverableException  and  OnErrorNotImplementedException  as they are the most common exception-related questions around.  #### UndeliverableException  > The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with. Further reading: https://github.com/ReactiveX/RxJava/wiki/What s-different-in-2.0#error-handling |  <original exception message>   #### OnErrorNotImplementedException  > The onError handler in the subscribe() method is not provided. Please specify it to avoid this type of exception. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling |  <original exception message> Remove 2+ empty lines from the sources. This PR modifies the  refCount  operator (in both  Flowable  and  Observable  types) to avoid certain termination-reconnection races.  The original race could happen when the refCounted source terminated at the same time as new observers arrived  leaving those new observers hanging as they practically joined a dying connection and got possibly undercut by the  dispose  call.  The change involve a new internal interface  ResettableConnection  that will allow resetting the connection object inside the connectable source if it is equal to the connection object known by the initiator of the original  connect  call.  Fixes #6185 This PR fixes the marble diagrams of  Flowable.toFuture  and  Observable.toFuture  to indicate:  - multi-valued sources signal  IndexOutOfBoundsException  - Source has to be finite for the  Future  to terminate.  ![image](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/Flowable.toFuture.png) ![image](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/toFuture.o.png)   Resolves #6198  (also fixes the diagram for #5813). Set plugin error tracking in some tests to avoid printing out  UndeliverableExceptions  (sometimes repeatedly in race tests) and assert the specific exception(s) instead. Remove the unnecessary  s  from the JavaDocs of  ConnectableObservable.autoConnect . Cleanup the drain logic of  Observable.flatMap  by removing unnecessary loops and fixing the index management in case of a fused failure in one of the sources triggering another round over the same source unnecessarily.  Resolves: #6231 With  UndeliverableException  and  OnErrorNotImplementedException   the wrapped exception may not have a message and the top line simply contains an unhelpful  null :      io.reactivex.exceptions.UndeliverableException: The exception could not be delivered to the              consumer because it has already canceled/disposed the flow or the exception              has nowhere to go to begin with. Further reading:              https://github.com/ReactiveX/RxJava/wiki/What s-different-in-2.0#error-handling | null         at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)         at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter             .onError(ObservableCreate.java:73)         at io.reactivex.internal.operators.observable.ObservableCreate             .subscribeActual(ObservableCreate.java:43)         at io.reactivex.Observable.subscribe(Observable.java:12090)      Caused by: java.io.InterruptedIOException   This PR adds the full  toString()  value of the wrapped exception to the main line. This is also more useful when the user posting the stacktrace doesn t provide the  Caused by:  part for some reason. Expand  fix and move the tests of #6242 into a dedicated test file. Use processors to trigger the  MissingBackpressureException  case instead of the timer  which could fire prematurely and stop the sequence before the first item was sent by the  BehaviorProcessor .  Also small improvements to the code coverage of  FlowableSample .  Fixes #6253. - Add missing spaces after commas and semicolons - Add or fix first sentences without commas in javadocs - Add marbles to the new  Completable.delaySubscription  operator. - Fix the method name referenced in the  ConditionalSubscriber  javadoc.  ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delaySubscription.t.png) ![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delaySubscription.ts.png) This PR extends the  SubscriptionArbiter  to optionally allow or disallow cancelling the current  Subscription  if it is replaced by a new one. Some operators do not need to cancel the current  Subscription :  concat    concatMap    repeat    repeatWhen    retry  and  retryWhen .   In addition  repeatWhen  and  retryWhen  were cancelling when the handler sequence itself terminated. The code has been updated to disconnect the upstream upon the completion/failure but before signaling the handler.  The Reactive Streams specification also disallows synchronous cancellation after the terminal event anyway.  Others may actually need to cancel  such as  Timeout .    Observable s don t have a specific arbiter  they use the  DisposableHelper  methods and the relevant ones were changed to  replace()  instead of the disposing  set  call.  Some tests actually checking if the dispose/cancel happens and had to be updated.  The  Flowable.delaySubscription(Publisher)  also used  SubscriptionArbiter  but it was unnecessary. The code has been replaced with a more apt deferred requesting scheme as the downstream requests need to be delayed until the main subscription happens  the other publisher is always consumed unbounded.  Resolves: #6259 This PR makes sure the  doOnDispose    doOnCancel  and  doOnLifecycle  execute their cancellation handler once.  Resolves: #6268. This PR rewrites the  Observable.cache  and  Flowable.cache  operators to allocate less and be more up-to-date algorithmically.  I ve also added comments to help understand its inner workings in case someone is interested.  Resolves: #6270 This PR adds the  materialize  operator to  Maybe    Single  and  Completable  to turn their signals into the corresponding  Notification  object. This operator has been available for  Observable s (and  Flowable s) from the beginning of the Rx API. The methods return  Single<Notification<T>> .  To complement  the  dematerialize  operator is only defined for  Single  and results in a  Maybe .  If accepted  I ll draw the correct marble diagrams for them in a separate PR.  Resolves: #6272 This PR adds the  dematerialize(Function<T  Notification<R>> selector)  overload to allow type-safe dematerialization of  Notification  signals. The pre-existing  dematerialize()  forced the return type and assumed the items of the source are  Notification  objects  which could not be enforced via the type system. This selector variant establishes the type link from  T  to  Notification<R>  to  R  (where R == T is allowed).  The intended use is     java Observable<Notification<T>> source = ...  Observable<T> result = source.dematerialize(notification -> notification)       aka identity mapping.  The pre-existing  dematerialize()  methods are marked as deprecated now.  *(Also the actual operator were missing from the examples in the respective Javadocs).* If the  Observable.flatMap  operator run in limited concurrency mode and multiple sources completed at the same time while the operator was in its drain loop  the operator only started with one new inner source instead of trying to run replace all the completed inner sources with new ones.  The solution is to count the completed sources and replenish them in a loop.  *(The  Flowable  variant works properly because it uses backpressure and inner source counting already to replenish those completed inner sources. The  Observable  doesn t have backpressure so it has to emulate it via the work-in-progress counting and the secondary queue for available inner sources.)*  Fixes: #6282 This PR fixes the case when an observer/subscriber disposes/cancels immediately upon subscribing to a  refCount  operator before it establishes the connection and ends up with a disposed but non-reset connection  preventing further interactions with the connectable source.  The fix is to detect this case and reset the connection when the  connect()  method signals the dispose handler.  Both  ConnectableFlowable.refCount  and  ConnectableFlowable.refCount  is affected.  Fixes: #6296 In javadoc  backtick has no meaning and caused javadoc compilation errors:  https://travis-ci.org/akarnokd/RxJava2_9/jobs/469904725#L516 This PR fixes a race condition in the  ObservableRepeatWhen  operator for the case when the repeat signal is not 1-for-1 and a new subscription may race with the clearing of the previous disposable because  active  is set to  false  too early. The fix is to swap the two operations.    Observable.retryWhen  and the  Flowable  versions do not have this bug. Unit tests were added to all 4 operators to verify the correct behavior regardless.  Fixes: #6358 Due to a bug in the  Flowable.publish  operator  it is not requesting more if there was a change in the subscriber array during an emission run in the non-fused operation mode.  Fixes: #6363 By default  the  Schedulers.from  uses a trampoline to ensure worker tasks are executed FIFO and non-overlappingly on any potentially multi-threaded  Executor . This old setup didn t allow task interruption due to this disconnect between the trampoline task and the operator task. (In contrast  the standard schedulers use single threaded executors and their  Future  is linked and interruptible when the operator task is cancelled).  This PR add an interruptible mode to the  Schedulers.from  via a paramerer in a new overload and some internal dispatching based on this mode selector. Existing  Schedulers.from(Executor)  users should still behave the same.  Resolves: #6368 This PR fixes a memory leak caused by node retention in the bounded  replay()  implementations. When the consumer disposed/canceled the flow  the  index  field was not cleared. In certain situations  such out-of-comission consumers were still reachable via thread local stack and through it  the node they were last refencing. Further items through it would then keep referencing an ever increasing number of linked nodes  causing OOME eventually.  The fix is to clear the  index  field upon dispose/cancellation. The subject/processor variants were working properly. Tests were added to verify them though as well.  Issue discovered on StackOverflow: https://stackoverflow.com/q/54191190/61158,
0,0,0,0,0,0,Volkan Yazıcı, 4453,0,0,0,0,1,1, Wrap InterruptedException with an unchecked exception in TestSubscriber#awaitValueCount()., In its current form   awaitValueCount()  is the only  TestSubscriber#await* method that throws a checked exception (that is   InterruptedException )  whereas the others wrap it with a  IllegalStateException . This spreads a try-catch disease throughout the entire code base where  awaitValueCount()  is used. One can argue that why not just declaring the exception in the caller method footprint: Because you might be implementing an interface (e.g.  Runnable ) which does not allow any exceptions in its footprint. This patch wraps the  InterruptedException  with an unchecked exception in  TestSubscriber#awaitValueCount() .,
0,0,0,0,1,0,James Barr, 5121,0,0,0,0,1,1, 2.x: fix Observable.zip to dispose eagerly, This PR fixes  Observable.zip  to dispose the sources outside the serialization loop  just like  Flowable.zip  does. This allows cancellation even if the serialization loop is busy/blocking inside an  onNext  emission.  In addition  a unit test was added to  Observable.zip  as well.  Reported in #5111.,
0,0,0,0,0,0,Adrian Pascu, 4729 3714,0,0,0,0,1,0, Merge FlowableEmitter.BackpressureMode into BackpressureStrategy 1.x: Add maxConcurrent parameter to concatMapEager, This is the implementation of #4727 Relevant issue #3710,
0,0,0,0,1,0,Dmitry Volkov, 6786 6787 6788 6789,1,0,1,1,1,1, Diamond operators in unit tests  observable package Diamond operators in unit tests  flowable package Diamond operators in tests Diamond operators in tests  small packages, Hello  in this pull request i ve changed all IDE marked explicit types with diamond operator. Affected package is internal/operators/observable. There is one test fail in CompletableTest.repeatNormal   but diamond is not the cause  there is last stack entry:  java.lang.AssertionError: expected:<6> but was:<5> 	at org.junit.Assert.fail(Assert.java:88)  This PR is part of  #6767 issue resolving. Hello  in this pull request i ve changed all IDE marked explicit types with diamond operator. Affected package is internal/operators/flowable.   There is one test fail in CompletableTest.repeatNormal   but diamond is not the cause  there is last stack entry:  java.lang.AssertionError: expected:<6> but was:<5> 	at org.junit.Assert.fail(Assert.java:88)  This PR is part of  #6767 issue resolving. Hello  in this pull request i ve changed all IDE marked explicit types with diamond operator. Affected packages is internal/   internal/operators/. There is one test fail in CompletableTest.repeatNormal   but diamond is not the cause  there is last stack entry:  java.lang.AssertionError: expected:<6> but was:<5> 	at org.junit.Assert.fail(Assert.java:88)  This PR is part of  #6767 issue resolving. Hello  in this pull request i ve changed all IDE marked explicit types with diamond operator. Affected packages is in tests root.  There is one test fail in CompletableTest.repeatNormal   but diamond is not the cause  there is last stack entry:  java.lang.AssertionError: expected:<6> but was:<5> 	at org.junit.Assert.fail(Assert.java:88)  This PR is part of  #6767 issue resolving.,
0,0,0,0,0,0,Michael Nitschinger, 1224 1613,0,1,1,0,1,1, Implement shorter toBlocking as shorter alias for toBlockingObservable. Moving Netflix to ReactiveX, Fixes #1220 I fixed the README by hand and then did a replace search for Netflix/RxJava to ReactiveX/RxJava to replace github wiki and issue occurences.  I did a eyeball sanity check so I hope things are good. My gut feeling says there are many more com.netflix occurences somewhere else  but it s a start to get it all back to  normal .,
0,0,0,0,1,1,Mark Sholte, 6754,0,0,0,0,1,1, 2.x: Zip  CombineLatest  and Amb operators throw when supplied with ObservableSource implementation that doesn t subclass Observable, Fixes #6753,
0,0,0,0,1,0,Nathan Kooij, 5434,0,0,1,0,1,1, 2.x: fix time bounded replaySubject getValue() inconsistency with getValues() on old items, See https://github.com/ReactiveX/RxJava/issues/5433.,
0,0,0,0,0,0,dromato, 3500,0,0,1,0,1,1, Some code clean ups., Nothing that could change logic or application flow  just minor refactors to be consistent with good practices and clean code. To sum up changes: - Simplified some conditions - Changed small l to L in long number  as l tends to look like 1 and might confuse - Removed  return  statements where those are not necessary (last instruction in function) - Inlined returns where there were no need for creating new variable (easier to read) - Deleted unnecessary colons,
0,0,1,0,1,1,Joachim Hofer, 228 229 246 248 249 257 331 354 355 356 357 373 375 381,0,0,1,0,0,0, Interval Trying to extend the Scheduler interface according to the comments at Scheduling actions periodically Implemented Sample Operation Timestamp operation Improved scan  reduce  aggregate Adding super/extends so that Observable is covariant Count  Sum  Average implementations implemented skipWhile and skipWhileWithIndex (#80) Added interval methods to Observable  where they were still missing Implemented  First  and  FirstOrDefault  operations a few warnings  javadoc  and one missing scheduler parameter Implemented  distinct  operator Implemented  mapWithIndex, I have attempted to implement the  Interval  operator (#55) here. As far as I can see  it seems to work. This is based on the quite fresh work on schedulers.  It doesn t work with the  currentThread  or  newThread  schedulers  I guess due to the simple  SleepingAction . It does work with a  ScheduledExecutorService   though.  For testing this conveniently  I also wrote a test scheduler with adjustable time.  Looking forward to any review comments. I ve tried to extend the  Scheduler  interface according to the discussion at issue #19. If I understand this correctly  most of it can be done via the  AbstractScheduler .  I hope this helps. Please have a look. As proposed earlier by @mairbek in https://github.com/Netflix/RxJava/pull/228#issuecomment-16254526  I extended the  Scheduler  by yet another method  schedulePeriodically . This has a default implementation that works via recursion. I tried it out with all existing schedulers  and it seems to work fine. I also wrote a unit test for it using the  TestScheduler .  I switched scheduled executor services to use their fixed rate scheduling instead of the recursive default implementation. And I also switched the  OperationInterval  implementation to use periodic scheduling. Now that  OperationInterval  is in   OperationSample  (see  #74) was kind of straightforward. I also added a unit test against sampling  and allowed for specifying a scheduler used by the sample operation. Straightforward implementation of issue #93  based on  OperationMap  (without the scheduler version  as  map  doesn t take a scheduler yet either). scan  is currently restricted to accumulators of type  Func2<T  T  T>  where  Func2<R  T  R>  would be possible for initial values of type  R . This pull request tries to fix this by generalizing the  scan  implementation. I had to restructure the scan operator a bit for this to stay typesafe. Imho it s more readable now  though.  This indirectly leads to generalized  reduce   too.  Also   aggregate  is added as an alias for  reduce  (see #20). Ok  so this pull request changes a _lot_ of lines. It s mostly generalizing all the  FuncX s to be used like  FuncX[-T1  -T2  ...  -TX  +R]  (contravariant parameters  covariant return type) and all the  Observer s to be used  in a contravariant way . A few of the  Observable  uses are covariant  now  too (mostly  zip ).  This is the pull request for #326.  This doesn t look very good in the code (thanks Java). Also  it doesn t seem to make Scala interop easier at all (at least not yet).  Please take a look. I m not exactly happy with the result. - Maybe I m doing something wrong here? - I ve still got hope that there s an easier way...  The pull request compiles and tests ok for me (except for the Clojure module  but that s another story and not due to my changes). I implemented three easy  operations here simply using  reduce .  Two things were tricky however: 1. How to name the various  overloads  (have to use different names due to identical erasure). I propose  sum    sumLongs    sumFloats    sumDoubles  here (and the same for the averages). 2. How to handle empty source observables when averaging. I propose throwing an  ArithmeticException  here.  Any other opinions? The title says it all already. This was simply missing and forgotten in #55. This PR builds upon the  skipWhile   PR (#355) which makes implementing the two  first  variants extremely easy.  I changed  firstOrDefault  slightly from what Rx.NET does by explicitly requiring a default value as parameter of the function call. I don t know what default value I should return otherwise  except  null  (and imho this would be pretty useless).  This PR addresses issue #44. This is just a quick fix for #368 according to @samuelgruetter s comments.  I also removed a few unnecessary  @SuppressWarnings( unchecked )  and one unnecessary semicolon. This PR implements  distinct   as speficied by #38.   Again  I haven t implemented the .NET methods taking an  IEqualityComparator  (see #374). As requested by @samuelgruetter in #372.,
0,0,0,0,1,0,PunitD, 6175 6305 6311 6314,0,0,0,0,1,1, 2.x: explain null observer/subscriber error reports in detail from RxJavaPlugins Javadoc : Explain explicitly about using Emitter interface methods synchronously Javadoc: explain that distinctUntilChanged requires non-mutating data to work as expected Change javadoc explanation for Mutable List, This PR is related to issue [#6172](https://github.com/ReactiveX/RxJava/issues/6172). With these changes  all reactive types will emit detailed error message when  onSubscribe  hook installed using RxJavaPlugins returns null  observer/subscriber :  **Observable** >  The RxJavaPlugins.onSubscribe hook returned a null Observer. Please check the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins   **Flowable** > The RxJavaPlugins.onSubscribe hook returned a null FlowableSubscriber. Please check the handler provided to RxJavaPlugins.setOnFlowableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins  **Single** > The RxJavaPlugins.onSubscribe hook returned a null SingleObserver. Please check the handler provided to RxJavaPlugins.setOnSingleSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins  **Maybe** > The RxJavaPlugins.onSubscribe hook returned a null MaybeObserver. Please check the handler provided to RxJavaPlugins.setOnMaybeSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins  **Completable** > The RxJavaPlugins.onSubscribe hook returned a null CompletableObserver. Please check the handler provided to RxJavaPlugins.setOnCompletableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins   **Note :**  There was no null check on  observer  returned from  RxJavaPlugins.onSubscribe(this  observer)  method call in  Completable  s subscribe() method.  So  I ve added it in this PR. Is that fine? Add note in Javadoc explicitly explaining about using Emitter interface methods synchronously.  - Add notes for  generate  methods in Observable and Flowable. - Plus  add the similar note to Emitter interface.  Resolves: #6299 - Add note in javadoc for all  distinctUntilChanged()  methods in  Flowable  and  Observable  class explaining about unexpected results to expect when using mutable data sources like **Mutable CharSequence** or **Lists**.  Resolves: #6290 As per [this](https://github.com/ReactiveX/RxJava/pull/6311#discussion_r234462497) discussion  change javadoc for  distinctUntilChanged()  method for Mutable List.,
0,0,0,0,0,0,Víctor Albertos, 4645 4647 4478,0,0,1,0,1,1, 2.x Signal NPE ObservableAmb FlowableAmb 2.x: Merge AmbArray and AmbIterable into Amb for Single  Maybe and Completable types Fix typo Javadocs TestObserver, This PR addresses #4640 This PR addresses #4633 - Merge SingleAmbArray and SingleAmbIterable operators into SingleAmb - Merge MaybeAmbArray and MaybeAmbIterable operators into MaybeAmb - Merge CompletableAmbArray and CompletableAmbIterable operators into CompletableAmb nan,
0,0,0,0,1,0,Aaron He, 3741 5925,0,0,1,0,1,1, Add doOnSubscribe for Single Add @Nullable annotations to Processors, Ref #3740.  I didn t write much unit tests for  doOnSubscribe  because it internally uses  OperatorDoOnSubscribe  which is well covered. Add  @Nullable  annotations to Processors.   Updated our project to use 2.11.1  and discovered there s this PR https://github.com/ReactiveX/RxJava/pull/5890 which added  @Nullable  annotations to Subjects. Thought might as well add  @Nullable  to Processors.,
0,0,0,0,0,0,Vadim Spivak, 1762,0,0,0,0,1,0, Compose generics, nan,
0,0,0,0,1,0,Koji Lin, 5378,0,0,0,0,1,0, 2.x: make SingleMap not allow map function return null, Found code like below can works     Single.just( 1234 ).map(s -> null)               .subscribe(s -> {                   System.out.println(s)                })      Because Single#just not allow null  so prevent mapper return null.,
0,0,0,0,1,0,Shivang Shah, 3820,0,0,1,0,0,0, Making RxPlugins reset() public, Discussions found here: https://github.com/ReactiveX/RxJava/issues/2297,
0,0,0,0,0,0,Jihong Park, 5230 5231 5255 5578 5673 5721,1,0,1,1,1,1, 2.x: Fix wrong comments in Functions.java “Function3” -> “BiFunction” Add TimeUnit null check test case in Timed Add nullPointerException comments and ObjectHelper test code. Add NullPointerException comment 2.x: coverage  add SingleToFlowableTest 2.x : Rename variable name  subject  to  processor  for exact expression, I m using this library in my company(KakaoBank in Korea) and interested in this library.. so I read whole code these days. I feel really thanks for all people who make awesome library and I just wanted to contribute this library. 1. It s about Timed.java test case that is null check TimeUnit parameter. 2. formatting in BasicIntQueueDisposable 3. add testcase blockingIterableNegativeBufferSizeFail for blockingIterable 4. modify BlockingMultiObserver field’s modfier :) Add comments in Single.java Add  SingleToFlowableTest  to cover toFlowable with test. Rename variable name  subject  to  processor  in processor pacakage,
0,0,0,0,0,0,Alexis H. Munsayac, 6453 6469 6483,0,0,1,0,1,1, Fixed typos for comments Remove redundant methods from Sample(Observable) Correction for Maybe.count doc typo, I was looking at the docs and found that some details does not match the given code.  For example:  ![Screenshot from 2019-04-04 10-01-00](https://user-images.githubusercontent.com/4783372/55524641-9da42280-56c0-11e9-8190-e3618418e993.png)  It says  new Completable instance  when  in fact  it returns a Maybe. Resolves: #6468 Resolves #6481,
0,0,0,0,0,0,Michael Wright, 3214,0,0,0,0,1,0, Fix to Notification equals method., The Notification method was missing a check to hasValue and hasThrowable. This allowed for a null value onNext Notification to equal an Object notification. A similar bug for onError Notification events also existed.,
0,0,1,0,1,1,Dave Moten, 4693 4694 874 934 1286 1599 1608 2547 2548 2550 2559 2759 4725 2862 2880 2902 2905 2914 2915 2982 2990 3018 3033 3034 3042 3043 3058 3079 3085 3086 3155 3524 3584 3626 3842 3867 3931 4777 4899 4901 4903 4904 6620 4251 4262 4270 6650 4364 4428 5161 4452 5466 5738 5860 5867 4555 5947 6021 4580 4621,0,1,1,0,1,1, 1.x: improve timer javadoc 2.x - improve timer javadoc Update CompositeSubscriptionTest.java add Observable.startWith(Observable) method and unit test Rename some Operator* classes to OnSubscribe* as per #1270 reuse existing methods Add missing window with time overload Warnings cleanup Subscriber.request should throw exception if negative request made Subscriber.onStart requests should be additive (and check for overflow) OnSubscribeFromIterable - add request overflow check Observable.using should use unsafeSubscribe and enable eager disposal 1.x: remove AsyncEmitter deprecations Cleanup warnings in test source Use singleton reduction functions in count and countLong Prevent ExceptionsTest from hanging when testing stack overflow Use singleton Operators where we can Optimization - use OperatorTakeLastOne for takeLast(1) Observable.ignoreElements - optimize TestSubscriber - add factory methods Improve Subscriber readability TestSubscriber - fix awaitTerminalEventAndUnsubscribeOnTimeout takeLast() javadoc fixes  standardize parameter names (count instead of num) Instantiate EMPTY lazily add backpressure support for defaultIfEmpty() TestSubscriber javadoc cleanup add and improve javadoc in Subscriber fix forEach javadoc break tests as approach timeout so that don t fail on slow machines improve ExecutorSchedulerTest.testOnBackpressureDrop SafeSubscriber - report onCompleted unsubscribe error to RxJavaPlugin fix subscribe() javadoc clarify behaviour of groupBy in javadoc use Exceptions.throwOrError to simplify error handling 1.x: improve ExecutorScheduler worker unsubscription 1.x: improve ExecutorScheduler worker unsubscription some more 1.x: add groupBy overload with evictingMapFactory 1.x: support Observable.test() 2.x: FlowableScanSeed - prevent multiple terminal events 2.x: FlowableScan - prevent multiple terminal emissions 2.x: doAfterNext - prevent post-error calls to consumer 2.x: Observable.scan  no seed - fix post-terminal behaviour 3.x: elementAt  first - constrain upstream requests toMap - prevent multiple terminal events  support backpressure doOnEach - reduce allocations  report to RxJavaHooks toMultimap - prevent post terminal emissions  reduce allocations 3.x: constrain upstream requests from take  remove limit operator 2.x collect - handle post terminal events 2.x: collect - handle post terminal events  - Observable 2.x: add Observable.switchMapSingle and switchMapSingleDelayError enhance generics on onErrorResumeNext and onErrorReturn 2.x: FlowableTimeoutTimed - replace AtomicReference with mutable field 2.x: fix javadoc for ConnectableFlowable and others 2.x: Flowable.groupBy add overload with evicting map factory 2.x: enhance test for groupBy with evicting map factory 1.x: enhance generics doOnError doOnRequest 2.x: fix groupBy cancellation with evicting map factory 2.x: Single.flatMapPublisher full implementation rename AsyncEmitter to Emitter 1.x: NotificationLite - reduce allocations, Javadoc was correct but not very helpful. Had to look further down in the javadoc to the  @return  section to see what value was emitted. Make it clearer what gets emitted (0L). Fix apparent typo  unsubscription of s2 was not checked and should have been. add Observable.startWith(Observable) method and unit test.   I would like to avoid breaking method chaining when want to startWith an Observable rather than just an Iterator or specific values. This is a very minor change as under the covers startWith uses concat anyway but it is significant in terms of code readability and is a natural completion of the startWith api. See discussion in issue #1270.   Numerous classes in the  rx.operator  package are not implementations of  Operator  but are actually implementations of  OnSubscribe . The classes have been renamed in this pull request.  Excuse me not squashing commits  looked complicated after doing a pull from upstream in the middle. This is a little cleanup of methods in Observable.java that could be reusing existing methods. Observable.window  is missing an overload  the one overload to rule them all (couldn t resist).   The missing overload is below and corresponds to the ability to customize every parameter associated with the window with time functionality.   public final Observable<Observable<T>> window(long timespan  long timeshift  TimeUnit unit  int count  Scheduler scheduler) more cleanup: - removed unnecessary imports - added missing generic types - added SuppressWarning annotations As per discussion in #1956 and #2545  making a call to  Subscriber.request(n)  with negative n should throw an  IllegalArgumentException .  Includes unit test. As per discussion in #2544. A subscriber like so provokes a hang from  OnSubscribeFromIterable  due to overflow to negative of requested field:      java     @Override     public void onStart() {         request(2)      }      @Override     public void onNext(Integer t) {         request(Long.MAX_VALUE-1)      }      I ve moved the  getAndAddRequest  method that does the overflow check to a new  rx.internal.operators.Util  class that is also now used by the request overflow check in  OperatorMerge .  Of course there are plenty more of these to be done. I propose to do them bit by bit. See #2604 where it was discovered that  Observable.using  used  subscribe  instead of  unsafeSubscribe  which provoked a race condition leading to an IllegalArgumentException from the merge operator.  This PR uses  unsafeSubscribe  and adds an overload for  using  to optionally dispose of resources eagerly (just before completion or error). The use case for this is a _synchronous_ observable where a downstream operation wants to reuse a resource (but because the observable is synchronous the resource cannot get disposed till the downstream completes).  Unit tests included. discussed in #4580 Made changes to test source to avoid or suppress these warnings: - raw types  - unused imports - unused variables Every call to Observable.count() and countLong() instantiated a new Func2 which I have now made a singleton in the interests of minimizing GC pressure.   Can anyone in the know confirm for me that there is GC benefit from this one because I assume a sophisticated enough compiler could replace the new Func2 call with a singleton during its optimizations.  If this one is worthwhile then there are heaps more of these in  Observable.java  and possibly elsewhere. On my i5 laptop  ExceptionsTest.testStackOverflowIsThrow  hangs. This PR changes the test so that it confirms that significant stack depth occurs and in another test ensures that the fatal  StackOverflowError  is thrown by  subscribe  when it occurs in  onNext .  I also removed some unused code from the original test and some extra subscriptions that didn t seem to serve a particular function. To reduce GC pressure use singleton  Operator s for  Observable.single    distinct    distinctUntilChanged     onBackpressureBuffer     isEmpty . This is an optimization for  takeLast  when called with parameter 1. Using  OperatorTakeLast  carries unnecessary overhead for the  takeLast(1)  case and a decent throughput improvement (x2) for streams of 100 elements or more is seen in the benchmarks below.   takeLast(1)  is used by the following operators which will also demonstrate a throughput improvement: -  last    lastOrDefault  -  reduce  -  collect  -  count    countLong   Benchmarks comparing using the new  OperatorTakeLastOne  and  OperatorTakeLast :      Benchmark                                                        Mode   Samples        Score  Score error    Units r.o.OperatorTakeLastOnePerf.takeLastOneUsingTakeLastOne_Few     thrpt         5  2235516.141   129091.019    ops/s r.o.OperatorTakeLastOnePerf.takeLastOneUsingTakeLastOne_Many    thrpt         5      103.980        9.233    ops/s r.o.OperatorTakeLastOnePerf.takeLastOneUsingTakeLastOne_Some    thrpt         5   984689.481    48560.897    ops/s r.o.OperatorTakeLastOnePerf.takeLastOneUsingTakeLast_Few        thrpt         5  2187421.223    93550.379    ops/s r.o.OperatorTakeLastOnePerf.takeLastOneUsingTakeLast_Many       thrpt         5       54.575        2.054    ops/s r.o.OperatorTakeLastOnePerf.takeLastOneUsingTakeLast_Some       thrpt         5   466892.497     9267.405    ops/s As suggested by @akarnokd  instead of  filter(alwaysFalse)  use a custom operator and a singleton instance of it.  Also snuck in the removal of an unused import from  OperatorTakeLastOneTest.java . Since we use this so much I ve added factory methods so we can infer types.   Instead of       java TestSubscriber<Integer> ts = new TestSubscriber<Integer>()       We can write      java TestSubscriber<Integer> ts = TestSubscriber.create()       I changed the tests in  OnSubscribeRangeTest  to demo the usage. The  Subscriber  class is something I encounter frequently when debug stepping through code and is hard to read. This PR improves the names of variables and makes the  request  method more readable in particular by moving some code off into another method.   I ve also put in a  return  straight after the  addToRequested(n)  call so that we don t need to make an unnecessary test of  producerToRequestFrom != null . Very minor saving I m sure but why not.  Javadoc is still missing and I thought to leave that for another PR (because it will require a bit more thought). The method  TestSubscriber.awaitTerminalEventAndUnsubscribeOnTimeout  did not unsubscribe on timeout. This PR fixes it. This PR includes these changes: - standardized parameter names for  take    takeLast    skip    limit  to use  count  instead of  num  - enhanced the javadoc for  takeLast  so it is clear for all overrides that if the observable contains less than  count  items then all will be emitted. - improved the exception message thrown by  OperatorTakeLast  when  count  <0  Addresses #3027 The singleton  EMPTY  returned by  Observable.empty()  can be instantiated lazily because it is not always required. When looking at implementing backpressure support for  defaultIfEmpty  the obvious strategy is to reuse  switchIfEmpty  and get rid of  OperatorDefaultIfEmpty . That s what this PR does.  There is a little bit of overhead with using  Observable.from(Arrays.asList(defaultValue))  as the alternate observable. Might be nice to have a version of  Observable.just(item)  that supports backpressure to use in its place (you ve mentioned this before @akarnokd). - standardize on  Asserts that  and  Returns  - fix tenses and wordings This PR  - adds missing javadoc to the  Subscriber(Subscriber)  constructor - improves (hopefully!) the javadoc for the constructor  Subscriber(Subscriber boolean)  - adds missing javadoc for  setProducer Observable.forEach  javadoc suffered from a bit of copy-and-paste and neglected to mention the possible throw of  OnErrorNotImplementedException .  Also added a couple of unit tests. These tests were giving me regular failures on my slow laptop: -  OperatorMergeMaxConcurrentTest.testSimpleOneLessAsync  -  BackpressureTests.testOnBackpressureDrop   They both loop repeatedly looking for failure or lockup. If the machine running the tests isn t fast enough then the tests timeout before reaching the desired number of loops. This PR adds a break to the tests when the loop has run for 9 seconds (timeout is 10 seconds). This test fails for me occasionally on my slow laptop when full test suite run because work is scheduled for only 1ms in the future. I ve decreased the probability of this one failing by changing the schedule to 50ms in the future. Discussed in #2464  when an observable emits  onCompleted  but  unsubscribe  in  SafeSubscriber  throws then the error should be reported to the  RxJavaPlugin  error handler and if that fails a stack trace is written to  System.err . fix for javadoc issue #3523 As discussed in #3411  some clarification of the behaviour of  groupBy  looks necessary re its behaviour when the  GroupedObservable  terminates early (for example has  .first()  applied to it). See also  #3581.  I also took the liberty of recommending  ignoreElements  instead of  take(0)  for the section in the javadoc that recommends how to ignore emissions because the  take(0)  approach would have more overhead (every emission from source would prompt the emission of a new  GroupedObservable ) than the  ignoreElements  approach.  Once this is accepted I ll look to submit a PR with  groupByOnce  (mentioned in #3411). This PR simplifies error handling by making use of existing  Exceptions.throwOrError  overloads.  A number of classes are touched by this one PR but I m assuming review will be easy enough that merge can happen soon. I noticed that when a worker built from  Schedulers.from(Executors.newFixedThread(1))  is unsubscribed the use of a  CompositeSubscription  to track task subscriptions means that the tasks may be unsubscribed in any old order ( CompositeSubscription  holds its subscriptions in a  HashSet ).  This means that if the worker is given task A and task B then the race can prevent A from running but allow B to run! I ve included a unit test in this PR that demos it. Fails every time on my machine on the first loop.  This  PR is really for discussion about the problem and possible fixes.  I have included a possible fix which is to track overall subscription using a volatile boolean and check that boolean before running any task. If this was considered the way to go some further simplification would take place in the operator (might not need to check individual task subscriptions).  I haven t checked other schedulers for this sort of problem yet. As per discussion in #3842  there was an outstanding possibility that unsubscription of a  Worker  would not cancel all tasks waiting in the queue. This PR addresses that possibility. I attempted to provoke the condition in a unit test but didn t manage it. Nethertheless I think this change completes the protection desired in #3842.  I do have mixed feelings about the possible double calling of  queue.clear()  (once in the  run()  method and once in the  unsubscribe()  method. Any preferences? I have a long running stream using  groupBy  that over time will accumulate 10s of millions of keys. If I can specify an evicting map to  groupBy  then I ll be able to keep it down to ~10 000 keys.   This PR supports this use case and could be used with Guava s  CacheBuilder  like this:      java Func1<Action1<K>  Map<K  Object>> mapFactory =      action -> CacheBuilder.newBuilder()               .maximumSize(1000)               .expireAfterAccess(12  TimeUnit.HOUR)               .removalListener(key -> action.call(key))               .<K  Object> build().asMap()  observable     .groupBy(keySelector  elementSelector  mapFactory)     ...      I ll enhance this PR with more unit tests if this looks a good direction. The new method chaining  TestSubscriber  in 2.x is too good not to have in 1.x as well (while I wait for 2.x to mature and to make my existing unit tests less verbose).      java Observable   .just(1)   .test()   .assertValue(1)   .assertCompleted()        Observable.test()  returns a  TestSubscriber2  that wraps a  TestSubscriber  and enables method chaining where it can.  I ve added tests to get to 100% test coverage though I ve been pretty slap-dash about testing some of the details (for example I haven t tested that  awaitXXX  really does wait for stuff).  I ve noted it as  @since 1.2.3  but can update to 1.2.2 if you are happy to squeak it into the release. This PR * prevents multiple terminal events being emitted when the scan function throws * prevents processing of a later  onNext  if the previous  onNext  processing resulted in an error emission * increases coverage to 100% of  FlowableScanSeed For scan without seed this PR * prevents multiple terminal events being emitted when the scan function throws * prevents processing of a later  onNext  if the previous  onNext  processing resulted in an error emission * ensures post terminal errors are reported to  RxJavaPlugins  error handler  For scan with seed (forgot this one in the last PR) * ensures post terminal errors are reported to  RxJavaPlugins  error handler This PR * prevents further calls to the consumer if an error has been thrown This PR * ensures that scan function throwing cannot result in two terminal events (error or complete) and that additional error event is reported to  RxJavaPlugins  error handler. * ensures that scan function if throws is not called again As discussed in #6569 this PR constrains upstream requests for the  elementAt  and  first  overloads. Other operators will be covered in other PRs. As per discussion in #4242  if an operator maps an  onNext  emission to an  onError  emission downstream then it needs be defensive about an  onCompleted  being sent from upstream even if upstream has been unsubscribed.  Includes three unit tests that failed on the original code. The fix also has the side effect of enabling gc of  map  when the factory fails ( onError  was called on the child  not  this  so  map  was not set to null). as discussed in #4260  - call  RxJavaHooks.onError  for secondary errors - reduced allocations ( ActionSubscriber  ->  ActionObserver    Operator  ->  OnSubscribe ) - added 5 unit tests - switched to  OnSubscribe  - switched to use  DeferredScalarSubscriberSafe  - previous source failed to handle post terminal emissions  - added 4 unit tests As per discussion in #6569  this PR constrains upstream requests from the  take  operator and removes the  limit  operator.  I ve also added a couple of unit tests for coverage of  elementAt  that I didn t include in #6620. Just looking at moving some recent 1.x bug fixes and tests over to 2.x.  This is my first PR in 2.x so before I proceed adding more tests from 1.x (to this PR) I want to get some feedback on my approach. In particular in the test  testCollectorFailureDoesNotResultInTwoErrorEmissions  is the  Flowable  creation method ok? Post-terminal event handling for  Observable.collect .  Added three unit tests that failed on original logic. This is a new operator discussed in #4853. The issue refers to a goodly number of new operators which I ll do bit by bit as my time allows and to ensure review is not too daunting. Func1<Throwable ...>  parameter should be  Func1<? super Throwable  ...> As per discussion in #5461. The timer fields in the Subscriber classes in [FlowableTimeoutTimed](https://github.com/ReactiveX/RxJava/blob/4c22f969927a98bc35458645d373bcb94b7df622/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java) are  AtomicReference s but this is not required as the fields are accessed synchronously.  The  timer  field in  TimeoutTimedOtherSubscriber  did require an  AtomicReference  because of the dispose call [here](https://github.com/ReactiveX/RxJava/blob/4c22f969927a98bc35458645d373bcb94b7df622/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java#L173) but this call is not required if we just call  worker.dispose() .  No unit test additions.  P.S. 9321 unit tests in RxJava 2.x! An outrageous amount of work  thanks @akarnokd (and other contributors)! Some javadoc fixes for ConnectableFlowable  GroupedFlowable and FlowableAutoConnect As per discussion in #5763  this PR adds an overload for  Flowable.groupBy  that specifies an  evictingMapFactory .   An example of usage taken from the new javadoc:     java Function<Consumer<Object>  Map<Integer  Object>> evictingMapFactory =     notify ->        CacheBuilder          .newBuilder()           .maximumSize(3)          .removalListener(entry -> {                try {                   // emit the value not the key!                   notify.accept(entry.getValue())                } catch (Exception e) {                   throw new RuntimeException(e)                }             })          .<Integer  Object> build()          .asMap()             // Emit 1000 items but ensure that the  // internal map never has more than 3 items in it             Flowable    .range(1  1000)    // note that number of keys is 10    .groupBy(x -> x % 10  x-> x  true  16  evictingMapFactory)    .flatMap(g -> g)    .forEach(System.out::println)       Note that I based this operator on the 1.x version which I think may have a bug that goes as far as the signature of that method. The eviction consumer should not be given a key but rather the value from the map. I ll pursue the 1.x issue after dealing with this. Enhance  FlowableGroupByTest.SingleThreadEvictingHashMap  so that it actually evicts and be a bit defensive by supporting  putAll  and  clear  properly. No change to  src/main/java . want to able to call  doOnError(Action1<Object>)  and similarly enhanced  doOnRequest  while I was about it. Fixes #5933.  When the outer stream is cancelled there may be evicted groups present in the queue to be completed.  I ve added code to complete the evicted groups in the  cancel  method as suggested by @akarnokd. To protect against a race condition where the EvictionAction is called just after the evicted groups are completed in  cancel  I ve added a  cancelled  check to  EvictionAction .   However  I am concerned about a race that I ll place in the comments on the code below. See discussion in #6015.  Resolves: #6015 as per discussion in #4577  renaming  AsyncEmitter  to  Emitter  via deprecation.  There is a catch though.  CompletableEmitter  is correctly named now and depends on  AsyncEmitter  via the method:      java  void setCancellation(AsyncEmitter.Cancellable c)       When can we break the api of that class? A lot of commonly used operators allocated an instance of  NotificationLite  as a field in a subscriber but for no great type-safety benefit. I ve cut these fields by converting all instance methods of  NotificationLite  to static methods and removing the  NotificationLite.instance()  method.  The changes are trivial till you get to the  Subjects  that would pass instances of  NotificationLite  in methods of the  SubjectSubscriptionManager . Still simple changes but reviewing these is a good idea.  RxJava2 goes a bit further in the internals of  NotificationLite . I d like to leave changes to the internals beyond making methods static for another PR if appropriate.,
0,0,0,0,1,1,Vladimir Mironov, 4522 4536,0,0,0,0,1,1, Observable/Flowable/Completable/Single.delay should always call onError on the provided Scheduler Observable.timeout/Flowable.timeout should unsubscribe from underlying subscription on dispose, Fixes #4521 nan,
0,0,0,0,1,0,Ben Christensen, 1 4 5 6 106 107 120 142 146 147 160 177 178 179 180 182 184 187 189 221 224 225 235 240 241 244 247 252 263 264 275 287 288 303 315 343 345 348 349 351 362 363 364 368 369 370 371 377 378 398 400 425 426 466 472 474 476 477 483 486 499 501 502 508 525 526 599 600 602 651 661 670 688 697 698 699 701 703 712 714 723 724 725 730 752 793 796 803 805 826 828 835 839 841 842 852 857 866 878 888 890 891 898 903 904 905 909 910 918 919 924 926 927 942 944 945 962 974 982 984 988 999 1010 1015 1040 1047 1048 1049 1051 1052 1053 1071 1072 1089 1091 1092 1132 1133 1148 1150 1163 1164 1228 1229 1231 1232 1233 1243 1244 1275 1281 1283 1284 1289 1290 1293 1294 1295 1307 1309 1324 1357 1376 1380 1387 1399 1400 1412 1414 1417 1422 1443 1457 1458 1467 1489 1493 1494 1498 1515 1558 1560 1561 1567 1568 1569 1576 1581 1582 1592 1593 1610 1611 1632 1638 1645 1646 1715 1716 1727 1733 1736 1738 1740 1742 1743 1745 1776 1784 1786 1787 1788 1789 1806 1809 1817 1834 1835 1882 1884 1903 1907 1918 1960 2594 3012 3031 3092 4979 4980,0,1,1,1,1,1, Refactoring conventions remove  wrap  functionality Support multiple class types for language adaptors Refactoring Performance optimizations for dynamic function execution. Performance: Reduce synchronization Fixing javadocs RxJava ErrorHandler Plugin Merge of Pull #125 for Issue #87 Operator TakeWhile Operator: forEach Manual merge of mairbek/single Pull #157 Operator: Dematerialize - review and manual merge Review and Refactor of GetIterator Operator GroupBy Pull Request - Review and Refactor Formatting and cleanup Subscriptions utility class and rx.subscriptions package Convert  last  from non-blocking to blocking to match Rx.Net Confusing Javadoc for  toObservable(Future)  methods Handful of Improvements Error Handling Improvements - User Provided Observers/Functions RxJavaObservableExecutionHook Schedulers (merge of pull #199) Schedulers Interface (Merging and Adding to Pull Request 229) Update TestScheduler to match merged Scheduler changes ReplaySubject - Manual Merge of Pull 218 Pre 0.8.0 Release Changes Add flatMap alias to mapMany Observable.toFuture Publish  Replay and Cache Operators Merge BehaviorSubject from Pull 256 Move forEach to BlockingObservable Error handling and validation Fix PublishSubject non-deterministic behavior on concurrent modification Pull 267 - Merge combineLatest Change onError(Exception) to onError(Throwable) - Issue #296 Covariant Support with super/extends and OnSubscribeFunc Remove unnecessary Observable constructor switchDo to switchOnNext Window Operator Fix Observable.window static/instance bug Merge  first  Operator unit tests for covariance additions to tests Operators: Throttle and Debounce Remove covariance of scan/reduce Change zip method signature from Collection to Iterable Operator: Retry Distinct operator UnitTests while working on EventStream use cases Merge  any  Pull Request Removing  comparator  overloads of  distinct Manual Merge of Pull Request #407 PublishSubject ReSubscribe for publish().refCount() Behavior Refactor Unit Tests from Inner Classes to /src/test BugFix: Issue 431 Unsubscribe with Schedulers.newThread BugFix: Reduce an empty observable Don t emit null onComplete when no onNext received in AsyncSubject CompositeSubscription bugfixes DoOn Tweaks BugFix: AsyncSubject ObserveOn Refactor ParallelMerge Operator Fix ObserveOn and add ParallelMerge Scheduler overload Empty subscribe BugFix: Handling of Terminal State for Behavior/Publish Subjects Manual Merge of toMap/toMultiMap Refactor rx.concurrency to rx.schedulers BugFix: Replay Subject ObserveOn Fixes Subjects Refactor - Non-Blocking  Common Abstraction  Performance Subscriptions Rewrite API Design Tweaks Fix SafeObserver handling of onComplete errors Manual Merge of Pull #667 Merge of Pull 657: Average and Sum Repeat Operator Collect Operator Small Tweaks Fix Scheduler Memory Leaks rxjava-computation-expressions Deprecate multiple arity ‘from’ Revert use of CurrentThreadScheduler for Observable.from Simpler computation/io naming for Schedulers Improve Error Handling and Stacktraces When Unsubscribe Fails Organize  Format  Alphabetize and Finalize Observer + Subscriber Add Subscription.isUnsubscribed() Add testMultipleWithSameCause UnitTest Fix CompositeException Return wrapped Subscription Repeat Operator ObserveOn Operator with Backpressure Error Handling: OnErrorNotImplemented and java.lang.Error Range OnSubscribe Test Unsubscribe rxjava-debug Change Lift to use rx.Observable.Operator Update OperationScan to OperatorScan Scheduler.scheduleRecursive Revert Bounded ObserveOn Split SubscribeOn into SubscribeOn/UnsubscribeOn Eliminate rx.util.* dumping grounds Handle illegal errors thrown from plugin Scheduler.Recurse fields should be private Merge: Unsubscribe Completed Inner Observables RxJavaSchedulers Plugin Scheduler Plugin Refactor Remove groupBy with selector. Operator: doOnTerminate BugFix: Zip Never Completes When Zero Observables Localized Operator Error Handling TestSubscriber: Default onError and Terminal Latch Behavior TestSubscriber lastSeenThread MathObservable OperationRetry -> OperatorRetry Manual Merge 940 Migrate from SynchronizedObserver to SerializedObserver TestSubject  TestObserver and TestScheduler Improvements Pivot Operator Tests and Javadoc for Pivot OnErrorFailedException New Implementation of SerializedObserver UnsafeSubscribe Remove Redundant protectivelyWrap Method Merge and Cleanup of #972 Scheduler Simplification Remove ExecutorScheduler - New ComputationScheduler Move rx.joins to rxjava-joins module Manual Merge #967 Scheduler Cleanup Deprecation Cleanup Manual Merge of AsObservable Scheduler.Inner -> Scheduler.Worker Manual Merge of Several PRs Handle Thrown Errors with UnsafeSubscribe Restore ObservableExecutionHook.onCreate Manual Merge of Several PRs collapse imports Manual Merge of Delay PR Fix ReplaySubject Terminal State Race Condition Fix defer for Java 8 type-inference JMH Perf Tests for Schedulers.computation Git Reformats This File Remove Ambiguous Subscribe Overloads with Scheduler Operator Alias: Share Adopt Limit and ForEach Java 8 Naming Conventions Deprecate toBlockingObservable in favor of toBlocking Remove Subscription Wrapper from Observable.subscribe Observable.from(T) using Observable.just(T) Fix Encoding/Formatting Reduce Subscription Object Allocation Reduce Subscription Object Allocation Manual merge of Lock-free  MPSC-queue based Schedulers.from(Executor) Upgrade to JMH 0.7.3 Fix and Update JMH Perf Tests rx.operators -> rx.internal.operators Change  void accept  to  boolean accept testNotificationDelay - Attempt at determinism Hide ChainedSubscription/SubscriptionList from Public API TrampolineScheduler & Unsubscribe MergeWith  ConcatWith  AmbWith Revision of JMH Tests Variety of Fixes Upgrade to JMH 0.9 Update Perf Tests Internal Data Structures Backpressure & 0.20.0-RC1 Merge Fixes Proposal: Subscriber.onStart Concurrency Fixes for RxRingBuffer & Merge Infinite request with Long.MAX_VALUE instead of -1 MergeDelayError & OnErrorFlatMap w/ Merge Remove Pivot Operator Javadocs for cache operator Backpressure Fixes and Docs Manual merge of retryWhen/repeatWhen zipWith non-deterministic testUserSubscriberUsingRequestAsync Support Subject Factory with Multicast mergeMap generics flatMap overloads Remove Variance on Defer groupBy with element selector Compose/Transformer Compose/Transform Covariance from(T) -> just(T) zip(Iterable) -> zipWith(Iterable) Deprecate GroupedObservable.from Decouple Dispose Function for Using doOnSubscribe Deprecate Multicast without Factory Deprecate Superfluous Methods with Scheduler Overload Composite Exception - Circular Reference Handling Composite Exception - Circular Reference Handling Remove ParallelMerge Deprecate ParallelMerge Deprecate Parallel Remove Observable.Parallel GroupBy/GroupByUntil Changes Move To Proper Location Fix TrampolineScheduler NullPointerException Delay Operator with Reactive Pull Backpressure longCount -> countLong EmptyObserver and TestObserver Subject Error Handling SerializedSubject Observable.compose Generics Publish with Backpressure Remove Multicast Remove *withIndex Operators Remove PublishLast/InitialValue GroupedObservable.from/create Remove Unnecessary Utilities Remove Utility Functions from Public API Fix Synchronous OnSubscribe Exception Skips Operators Subject.toSerialized Scan/Reduce with Seed Factory Remove Unused Scheduler.parallelism Fix Scan/Reduce/Collect Factory Ambiguity Fix TestScheduler Handling of Immediate vs Virtual Time Experimental: onBackpressureBlock Revert  Experimental onBackpressureBufferWithCapacity doOnRequest Revert Behavior Change in TestSubscriber.awaitTerminalEvent rx.Single Fix OperatorFlatMapPerf.flatMapIntPassthruAsync Perf Test Single.toObservable Add newline to end of files missing a newline Update Copyright to  RxJava Contributors, nan We no longer need this as we ve merged the interface and abstract classes together and don t need to ensure we have the abstract class. nan - convert to rx.\* package names   - rx.observables   - rx.observables.operations (private package from javadocs)   - rx.util   - rx.lang   - rx.concurrency (placeholder for schedulers) - change Func order to have return type at end => T  R instead of R  T   - this matches the C# and Guava conventions - added Action as Func without return value   - added overload subscribe methods with Action typed arguments - added from() alias methods in Observable - memoize dynamic function constructions so executions are statically typed after a single dynamic lookup instead of dynamic on every execution  https://github.com/Netflix/RxJava/issues/104 Performance changes as part of https://github.com/Netflix/RxJava/issues/104 and is an extension of work done in pull https://github.com/Netflix/RxJava/pull/106.  This code was used to test the performance:      java     public void runCompositionTest(Integer[] values) {         System.out.println( runCompositionTest )           final AtomicInteger onNextSum = new AtomicInteger(0)          final long start = System.nanoTime()           MathFunction m = new MathFunction()          // 50 levels of composition (same function so that s not the cost)         Observable.from(values)                 .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)                 .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)                 .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)                 .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)                 .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)                 .subscribe(new TestObserver(onNextSum  start))      }      Before it took:      Sum: 710082754 Time: 60.605ms      By reducing the nested synchronization (eliminating most of it) it is now running at:      Sum: 710082754 Time: 22.429ms https://github.com/Netflix/RxJava/issues/119 - added correct links to external images - cleaned up some of the text - improved some function memoization that was missed https://github.com/Netflix/RxJava/issues/141 Error Handler Plugin https://github.com/Netflix/RxJava/issues/139 Plugin System Manually merging https://github.com/Netflix/RxJava/pull/125 from @mairbek Issue https://github.com/Netflix/RxJava/issues/45  Related to Pull https://github.com/Netflix/RxJava/pull/131 Merging https://github.com/Netflix/RxJava/pull/157 which had conflicts and needed a manual merge. Manual merge of pull request https://github.com/Netflix/RxJava/pull/174 for issue https://github.com/Netflix/RxJava/issues/37 Review of pull request https://github.com/Netflix/RxJava/pull/169 for issue https://github.com/Netflix/RxJava/issues/50 along with a simple refactoring to reduce code in Observable.java. Refactored version of pull request https://github.com/Netflix/RxJava/pull/176 for issue https://github.com/Netflix/RxJava/issues/51  I would like to avoid delegation if possible since it will mean it needs to be kept in sync with Observable.  This refactored approach allows inheritance without delegation by composing the Observable  inside another operator function. nan https://github.com/Netflix/RxJava/issues/173 Merging pull request https://github.com/Netflix/RxJava/pull/167 which needed manual merging.  Did some other cleanup while in there and added a missing generic  Object  override.  Thank you @mairbek for doing this work. https://github.com/Netflix/RxJava/issues/148 Some improvements made while reviewing code. - add error handling to VideoExample.groovy so it s a better representation of how onError is used - handle errors from Func1 failures when subscribe happens - handle null Subscriptions on  trusted  functions  not just untrusted Improve error handling as per discussion in issue https://github.com/Netflix/RxJava/issues/216  This is by no means exhaustive in the search for places needing this protection but gets the most obvious ones entering via  subscribe  and  forEach .  The intention is to protect against exceptions being thrown and ensure onNext/onError/onCompleted contract compliance. Allow a plugin to intercept invocations of an Observable via its subscribe method.  Use cases: - extra logging or metrics for start  return and error events when subscribing - decorate (or replace) an  onSubscribe  function with additional behavior - decorate an Exception - decorate a Subscription  This is modeled after Hystrix Plugins: http://netflix.github.com/Hystrix/javadoc/index.html?com/netflix/hystrix/strategy/executionhook/HystrixCommandExecutionHook.html  Javadocs will be at http://netflix.github.com/RxJava/javadoc/ Manual merge of https://github.com/Netflix/RxJava/pull/199 by @mairbek plus the following changes: - made some classes non-public so they don t become part of the published API (if we find they have value in the public API we can make them so but once published it s hard to remove them so I d rather keep them implementation details until then) - consolidated ExecutorScheduler and ScheduledExecutorScheduler - made ExecutorScheduler use a system-wide ScheduledExecutorScheduler for handling delayed events when only an Executor is available - made the IOThreadPool use a non-bounded cached thread-pool   Next step from here is to review all operator implementations and add the Scheduler overloads. Merging and adding to pull request https://github.com/Netflix/RxJava/pull/229 from @jmhofer which adds functionality discussed in the Scheduler issue https://github.com/Netflix/RxJava/issues/19  Work done in https://github.com/Netflix/RxJava/pull/229 added the following methods to  Scheduler : -  Subscription schedule(T state  Func2<Scheduler  T  Subscription> action  long delayTime  TimeUnit unit)  -  Subscription schedule(T state  Func2<Scheduler  T  Subscription> action)   These are in fact the primary methods from RxNet (http://msdn.microsoft.com/en-us/library/hh211963(v=vs.103).aspx) and the others are just helper overloads.  It seems beneficial to use these 2 methods for actual implementation logic while all other methods are just decorating and forwarding from AbstractScheduler to these methods.  I propose these changes on top of pull request https://github.com/Netflix/RxJava/pull/229 to achieve this.  I also added unit tests that @mairbek created (https://github.com/Netflix/RxJava/pull/229#issuecomment-16115941).  All unit tests are passing … but we don t yet have enough unit test coverage so I won t be surprised if bugs are found. - I accidentally merged this code before fixing it to match the changes to AbstractScheduler/Scheduler Manual merge of ReplaySubject from pull request https://github.com/Netflix/RxJava/pull/218 - merged DefaultSubject and PublishedSubject which were the same thing (lots more unit tests though from this pull request) - still not sure what the right name is for DefaultSubject/PublishSubject - renamed RepeatSubject to ReplaySubject to match .Net - tweaked unit tests with InOrder while reviewing them to understand behavior - moved UnsubscribeTester into a package private class as I m still undecided on long-term placement of this and the OperatorTester class Some cleanup before releasing. This is to match with what Java 8 is adding to Stream so we support the duality of Iterable/Collection to Observable.  http://download.java.net/lambda/b86/docs/api/java/util/stream/Stream.html#flatMap(java.util.function.Function) nan (Redo of https://github.com/Netflix/RxJava/pull/260 after merging)  Added basic Publish (https://github.com/Netflix/RxJava/issues/15) and Replay (https://github.com/Netflix/RxJava/issues/71) operators to Observable. I have not done any of the overloads (particularly  Replay  which has 10+ in .Net.  I also added a new  Cache  operator as discussed by @johngmyers and I at https://github.com/Netflix/RxJava/pull/209.  Playing with  Replay  and  ConnectableObservable  it does not cater well to the typical use case of needing to just de-dupe calls (cache the responses) so this  Cache  operator can be thought of as an automatic version of  Replay . It comes with the same risk as  toList  if used with infinite or very large sequences as you can not unsubscribe from it. Manual merge of https://github.com/Netflix/RxJava/pull/256   Additionally removes SynchronizedObserver usage from Subject implementations. - We don t need to add synchronization as the subjects can trust their source Observables to comply with the Rx contract. - This optimization follows Rx Design Guidelines 6.8. Avoid serializing operators  This was discussed at https://github.com/Netflix/RxJava/pull/256 - was missed in previous refactoring Refactoring related to arg validation and error handling.  https://github.com/Netflix/RxJava/issues/198 Throw if no onError handler specified https://github.com/Netflix/RxJava/issues/278 Subscribe argument validation - changed to take snapshot of observers.values() before iterating in onNext/onError/onCompleted so that nested subscriptions that add to observers can t change the values() iteration - single-threaded nested subscriptions are now deterministic - multi-threaded subscriptions will no longer be allowed to race to get into an interating onNext/onError/onCompleted loop  they will always wait until the next - also improved terminal state behavior when subscribing to a PublishSubject that has already received onError/onCompleted  https://github.com/Netflix/RxJava/issues/282 Spent some time reviewing it and it seems good. Any bugs can be dealt with as people start playing with it instead of me holding this up as a pull request any longer since this exposes  combineLatest  in  Observable  for I believe the first time and is thus a low risk to breaking any existing users. This changes  Observer#onError(Exception e)  to  Observer#onError(Throwable e)   See  Observer#onError should use Throwable  https://github.com/Netflix/RxJava/issues/296 for discussion that led to this change.  This is a breaking change and will result in a version bump from 0.9.x to 0.10.x. Merging and adding to work by @jmhofer in https://github.com/Netflix/RxJava/pull/331  In particular this adds the following change to the previous pull request:      java public static <T> Observable<T> create(Func1<? super Observer<? super T>  ? extends Subscription> func)      to      java public static <T> Observable<T> create(OnSubscribeFunc<T> func) - fixed unit tests that relied on it See https://github.com/Netflix/RxJava/issues/342 for original question.  Does anyone have an opinion on this? Manual merge of https://github.com/Netflix/RxJava/pull/337  Since this pull request was submitted there were significant changes to the  create  operator and generics  so I manually merged into master. I have not actually reviewed for behavior  but unit tests are passing and code structure looked good.  This is for issue https://github.com/Netflix/RxJava/issues/102?source=c - reported at https://github.com/Netflix/RxJava/pull/349#issuecomment-23946707 Merge pull request https://github.com/Netflix/RxJava/pull/357 with  first  and  firstOrDefault  operators. - refactoring so not everything for the entire Observable ends up in a single class nan This adds  throttleFirst    throttleLast  (alias of  sample ) and  debounce  (aliased with  throttleWithTimeout ).  This merges pull request https://github.com/Netflix/RxJava/pull/258.  Unfortunately the Rx  throttle  operator behavior is actually  debounce   not  throttle . This pull request tries to address that.  Here is a good place to get a description of  throttle  versus  debounce : http://drupalmotion.com/article/debounce-and-throttle-visual-explanation  > Debounce: Think of it as  grouping multiple events in one . Imagine that you go home  enter in the elevator  doors are closing... and suddenly your neighbor appears in the hall and tries to jump on the elevator. Be polite! and open the doors for him: you are debouncing the elevator departure. Consider that the same situation can happen again with a third person  and so on... probably delaying the departure several minutes. >  > Throttle: Think of it as a valve  it regulates the flow of the executions. We can determine the maximum number of times a function can be called in certain time. So in the elevator analogy.. you are polite enough to let people in for 10 secs  but once that delay passes  you must go!  Other links includes: - http://unscriptable.com/2009/03/20/debouncing-javascript-methods/ - http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/  I feel we need some kind of  throttle*  operator name as an alias to  debounce  to help people discover it  especially those coming from Rx.Net or RxJS. I m not fond of  throttleWithTimeout  which is what I have it as right now. Perhaps  throttleViaDebounce  even though that doesn t actually make sense?   I do not want to use  throttle  because it s not actually the definition of  throttle . To confirm this I have asked over a dozen server-side engineers what their definition of  throttle  is and their expectations of an operator is. It never matches the Rx definition and they are always surprised by the  debounce  behavior.  I have included  throttleLast  as an alias to  sample  so that as people start typing  throttle...  it prompts them for the different options and discoverability will be improved instead of knowing to go look for  sample .  The  throttleFirst  operator is included as an efficient approach to throttling tht does not involve ticking time  intervals or buffering in any way. It simply allows an  onNext  value through if the last  onNext  event was greater than X time units ago. All others are discarded. This matches server-side throttling expectations and is limited overhead.  Questions:  1) Is there a better name for  throttleWithTimeout  as an alias to  debounce ? 2) Does the documentation sufficiently explain the different strategies? 3) If ambitious in your review  does anyone see concurrency bugs? Remove covariance of scan/reduce since consumer/producer are the same <T  T  T>  See https://github.com/Netflix/RxJava/issues/360#issuecomment-24203016 Fix javadoc typos. https://github.com/Netflix/RxJava/issues/72 Merging https://github.com/Netflix/RxJava/pull/375 nan Merges pull https://github.com/Netflix/RxJava/pull/385  I changed  any  to  isEmpty  and  exists  as I agree with @samuelgruetter comment at https://github.com/Netflix/RxJava/pull/385#issuecomment-24568332. These names feel more idiomatic to Java languages. Removing these fairly recently added overloads as they turn out to not be the best approach.  Discussion ongoing as to how to implement them at https://github.com/Netflix/RxJava/issues/395 Added a unit test to #407 while testing it. Allow  publish  +  refCount  to support re-subscribing to the origin after decrementing the count to 0 then adding new Observers which increment count to 1+.  The PublishSubject implementation was performing onError/onCompleted unsubscribe logic that was put in place long ago and I am now pretty sure it was wrong.  This was revealed while playing with  refCount  which intends on allowing a re-subscription to the source once new Observers arrive. PublishSubject was preventing that.  The one use case that I m still wondering about though is if someone subscribes to a PublishSubject after it has emitted onCompleted and isn t  restarted . That Observer would wait forever if it is a  single-shot  PublishSubject use case. I m not sure if that s just a bad use and fits into the  don t do that  scenario  or if it s a legit issue that has a solution.  Right now this code is  thread-safe  in the visibility sense  but it s not atomic and could have race conditions between adding/removing Observers and event notifications. I don t think that s an issue as if someone is concurrently adding/removing it s always a race  but am not 100% sure if there s a use case I m missing. This also assumes (as it always did) that someone is not invoking onNext concurrently as that would break the Rx contract. Manual merge of and additions to pull request https://github.com/Netflix/RxJava/pull/465 to refactor unit tests from inner classes to separate /src/test/ folder to accomplish issue https://github.com/Netflix/RxJava/issues/439   minimize library size .  Great work by @pasviegas on this pull request! Fix bug => Unsubscribing does not work when using subscribeOn(Schedulers.newThread())  I believe this fixes https://github.com/Netflix/RxJava/issues/431  The NewThreadScheduler was not using DiscardableAction that supports being unsubscribed. This fixes issue https://github.com/Netflix/RxJava/issues/423  The fix is based on this comment by @headinthebox: https://github.com/Netflix/RxJava/issues/423#issuecomment-27642532  Thank you @zsxwing  for your involvement on this.  If I have mis-interpreted the results of the discussion and this is still wrong ... please correct me.  Here is the unit test asserting the behavior:      java     /**      * A reduce should fail with an IllegalArgumentException if done on an empty Observable.      */     @Test(expected = IllegalArgumentException.class)     public void testReduceWithEmptyObservable() {         Observable<Integer> observable = Observable.range(1  0)          observable.reduce(new Func2<Integer  Integer  Integer>() {              @Override             public Integer call(Integer t1  Integer t2) {                 return t1 + t2              }          }).toBlockingObservable().forEach(new Action1<Integer>() {              @Override             public void call(Integer t1) {                 // do nothing ... we expect an exception instead             }         })           fail( Expected an exception to be thrown )      } Reported via email by @axel22 and @headinthebox - remove now also unsubscribes the removed subscription - added clear method - do not have 2 method overloads with similar method signatures  dynamic languages can not negotiate method dispatch using function arity - add doOnCompleted and doOnError methods instead of different doOnEach overloads  This is a very slight breaking change by deleting a method added in the last release. I did not catch this when I did the code review. - it was not emitting values to observers that subscribed after onCompleted/onError Refactor and small fixes of ObserveOn with @headinthebox nan - ObserveOn was not correctly recursing when the source was async. It would create a new scheduler (i.e. a new thread) each time. - Also added unit tests to ParallelMerge nan - They were not correctly emitting onCompleted when new Observers subscribed after the Subject was terminated. - Added same logic that already existed on AsyncSubject Manual merge of https://github.com/Netflix/RxJava/pull/513 To match the naming convention of rx.observables  rx.subjects and rx.subscriptions we have decided to rename rx.concurrency to rx.schedulers prior to the 1.0 release. These commits makes this change.  Since this is a non-trivial breaking change to anyone using Schedulers  this leaves the  rx.concurrency.*  classes in place and deprecates them to give time to migrate. These deprecated classes will be deleted prior to the 1.0 release. nan - refactor to remove imperative assignment of innerScheduler for clearer concurrency and data access - fix subscription leak (Composite+MultipleAssignment instead of just Composite) - remove confusing conditional logic for inner/outer scheduler These changes evolved out of reviewing pull request https://github.com/Netflix/RxJava/pull/605 and code reviewing master branch with @headinthebox and validating functionality against .Net. I also spent some time to figure out a non-blocking design that I believe is working.  The results for  ReplaySubject  is that it performs faster than what is currently in master and does not block in almost all cases. I have not yet perf-tested the other 3 Subjects. - Common logic composed inside SubjectSubscriptionManager used by all 4 Subjects - ReplaySubject does not block while replaying to new subscribers - Added unit tests and fixed behavior while reviewing with @headinthebox compared to Rx.Net - Uses mostly non-blocking approach (I believe it’s all correct  unit and long running tests have been used to prove it. The tests found concurrency problems during development and became stable once I got the design correct. As with all concurrent code I may be missing something.)   - The only place it blocks is if a new Observer subscribes  completes replay and  onComplete / onError  are in process. It will wait for those to complete before applying the terminal state on itself.  As for performance  for relative comparison my machine gets these numbers for the master branch:           * ArrayList with raw values & synchronized access      *       * Run: 10 - 11 993 341 ops/sec      * Run: 11 - 11 719 523 ops/sec      * Run: 12 - 11 965 214 ops/sec      * Run: 13 - 11 814 730 ops/sec      * Run: 14 - 11 947 459 ops/sec      This commit gets these numbers:           * ArrayList with raw values & non-blocking (no synchronization)      *       * Run: 10 - 16 069 678 ops/sec      * Run: 11 - 15 954 688 ops/sec      * Run: 12 - 16 158 874 ops/sec      * Run: 13 - 16 209 504 ops/sec      * Run: 14 - 16 151 174 ops/sec      I m curious about adding bounded support and using a circular-array rather than ArrayList and seeing if it performs better.  The performance tests are inside  SubjectPerformanceTests  and inspired by tests done in the non-blocking code workshop with Martin Thompson.   Some of the code is not as elegant as I d like but was done for performance reasons. For example  I had a much more elegant version using a simple linked list but it had horrible performance. Another example is that using  Notification  to wrap every  onNext  so we have a single data structure is very inefficient so it maintains  T  without wrapping and then conditional logic to check for terminal state. These and other things have been determined while doing perf tests during development and I have consciously moved towards performance rather than the most elegant code.  I d appreciate feedback on concurrency problems if any exist or ways of getting more performance out while achieving the same functional requirements. Refactor rewrite of Subscriptions by @headinthebox and myself after reviewing the various different implementations. - We removed  SingleAssignmentSubscription  while trying to reduce surface area and simplify code. - Moved to a non-blocking state-machine model that does not lock or busy spin during  mutation states Some changes resulting from review with @headinthebox and @jhusain  General principles pursued are to simplify the mental model and surface area of the API. Fixes https://github.com/Netflix/RxJava/issues/630 Manual merge of https://github.com/Netflix/RxJava/pull/667 nan - merge and slight modification of https://github.com/Netflix/RxJava/pull/518 done with @headinthebox Added with @headinthebox while reviewing Java 8 Streams https://github.com/Netflix/RxJava/issues/678 Some small changes while reviewing code. The  NewThreadScheduler    CurrentThreadScheduler  and  ExecutorScheduler  all had memory leaks when doing recursion with the  Func2  method signature. This pull request fixes that along with improving the unit test coverage.  The fix involved treating  outer  and  inner  schedulers differently  with  inner  being the place where recursion happens.  The memory behavior can be tested using  TestRecursionMemoryUsage .  This fixes the problems reported in https://github.com/Netflix/RxJava/pull/643 and  https://github.com/Netflix/RxJava/pull/648 but does not change the  Scheduler  or  Subscription  interfaces or public implementation details. The conditional operators are going in this contrib module.  See https://github.com/Netflix/RxJava/issues/683 - added @Deprecated annotations where it was only part of the Javadoc - deprecated ‘where’ which is a duplicate of  filter  kept from early days matching Rx.Net  See https://github.com/Netflix/RxJava/issues/686 Use ImmediateScheduler as performance is 4x faster and CurrentThreadScheduler currently offers no benefit (it doesn’t solve the unsubscribe problem).  Performance numbers:       * Observable.from(Arrays.asList(1L  2L  3L  4L  5L  6L  7L  8L  9L  10L)  scheduler)   *  * --- Schedulers.immediate() ---  *  * Run: 0 - 1 849 947 ops/sec  * Run: 1 - 2 076 067 ops/sec  * Run: 2 - 2 114 688 ops/sec  * Run: 3 - 2 114 301 ops/sec  * Run: 4 - 2 102 543 ops/sec  *  * --- Schedulers.currentThread() ---  *  * Run: 0 - 548 862 ops/sec  * Run: 1 - 559 955 ops/sec  * Run: 2 - 581 412 ops/sec  * Run: 3 - 562 187 ops/sec  * Run: 4 - 565 723 ops/sec   * Observable.from(Arrays.asList(1L)  scheduler)   *  * --- Schedulers.immediate() ---  *  * Run: 10 - 4 113 672 ops/sec  * Run: 11 - 4 068 351 ops/sec  * Run: 12 - 4 070 318 ops/sec  * Run: 13 - 4 161 793 ops/sec  * Run: 14 - 4 156 725 ops/sec  *  * --- Schedulers.currentThread() ---  *  * Run: 10 - 1 692 286 ops/sec  * Run: 11 - 1 765 054 ops/sec  * Run: 12 - 1 763 100 ops/sec  * Run: 13 - 1 770 907 ops/sec  * Run: 14 - 1 732 291 ops/sec - simpler (no one remembers the current names when talking about them) - does not tie naming to a particular implementation involving thread pools versus a pool of event loops or something similar (as we likely will change the implementation  see https://github.com/Netflix/RxJava/issues/713) The stacktraces were a mess when onError failed or was not implemented and unsubscribe also failed. That is a far edge case and means code is broken and breaking the Rx contracts … but that’s just when we need clear stacktraces. The CompositeException and SafeObserver class now do a dance and wire together a causal chain to provide a stacktrace that can identity all the points of error. Also standardized and simplified the RxJavaPlugin.onErrorHandler while working in the vicinity.  This came about after I was asked to help debug a problem and couldn’t do it by looking at the thrown exception  I had to use a debugger and step through. Code cleanup after the many new operators that have come in over the past 2 months.  1) Organized imports 2) Formatted all code for standard whitespace  code formatting etc 3) Sorted methods in  Observable.java  alphabetically 4) Updated all license headers 5) Made  Observable  methods final as they are not intended to be overridden in the rare cases when inheritance makes sense for  Observable . This better communicates the inheritance intent of the class and prevents against accidental misuse (such as overriding  subscribe  which breaks it). As per discussion in https://github.com/Netflix/RxJava/issues/792 the  abstract class Observer  has been returned to  interface Observer  and there is now  abstract class Subscriber implements Observer<T>  Subscription  to fill that role.  Signatures are now:      java // Observable.create public final static <T> Observable<T> create(OnSubscribe<T> f)  // Observable.OnSubscribe typed function interface public static interface OnSubscribe<T> extends Action1<Subscriber<? super T>>  // Observable.subscribe public final Subscription subscribe(Subscriber<? super T> subscriber) public final Subscription subscribe(Observer<? super T> observer)  // lift function public <R> Observable<R> lift(final Func1<Subscriber<? super R>  Subscriber<? super T>> bind)  // Observer public interface Observer<T> {      public abstract void onNext(T t)       public abstract void onError(Throwable e)       public abstract void onCompleted()  }  // Subscriber public abstract class Subscriber<T> implements Observer<T>  Subscription {      public final void add(Subscription s)      public final void unsubscribe()      public final boolean isUnsubscribed() }  // Subject  public abstract class Subject<T  R> extends Observable<R> implements Observer<T> With the new model of injecting  Subscription  into functions for synchronous loops to check  isUnsubscribed()  it now makes sense for this to be on the interface of all  Subscription  implementations. Also make tests capable of failing with timeouts. Before the constructor would immediately go into an infinite loop and hang the tests. This fixes possible issues where infinite loops could be created if the right combination of Exceptions and causal chains were composed together. - make sure the SafeSubscriber is included in what is returned - then return as Subscription not Subscriber so it can t be cast back to a Subscriber Based on code and discussion in https://github.com/Netflix/RxJava/pull/807/files This is a re-implementation of ObserveOn done for 3 purposes:  1) Migrate to new  lift  style so the  Subscription  flows through correctly 2) Eliminate the wasted first schedule step (reported by @mttkay  https://github.com/Netflix/RxJava/pull/797#issuecomment-34044956) 3) Eliminate buffering so it naturally provides back pressure   Unit tests are passing on my machine for a full build  but I m interested in user experience  particularly from Android users where  observeOn  behavior is mission critical.  This WILL change behavior and possibly cause problems if  observeOn  was being used to make something async (which is not the purpose of  observeOn . The  subscribeOn  operator is the one to use for making something ~~async~~ concurrent. [Update: Per discussions below we may want another operator or  observeOn  overload to allow async behavior to use a queue and decouple producer/consumer. The  observeOn  operator however should by default only do what it says - switch threads.]  This is a complete re-write so I may very well have created nasty bugs that we don t yet have unit tests for so I d appreciate a thorough review and testing.  One possible concern is performance. In the case of a synchronous firehose (not the normal use case  but a use case nonetheless)  this is far slower because now each  onNext  is sent one-at-a-time across thread boundaries whereas before it would put everything into a queue on one side then read it all from the queue on the other side.   Thus  for this code that synchronously firehoses 100000 values it is about 7 times faster on the current code without back-pressure:      java long last = Observable.range(0  100000).observeOn(Schedulers.newThread()).toBlockingObservable().last()       However  this code is the same performance:      java long last = Observable.interval(1  TimeUnit.MILLISECONDS).take(1000).observeOn(Schedulers.newThread()).toBlockingObservable().last()       The difference being that we re not just filling up the queue in the second one as it has latency.  I believe this is okay as the intent of  observeOn  is moving across thread boundaries  such as for UI events  and eliminating the bad behavior of buffer-bloat is the right thing.   I m sure we can find some performance improvements in this code  but it s worth pointing out how the change in behavior can affect it. Special Handling of java.lang.Error and OnErrorNotImplemented - https://github.com/Netflix/RxJava/issues/748#issuecomment-32471495 - https://github.com/Netflix/RxJava/issues/771 - https://github.com/Netflix/RxJava/issues/789 Reimplemented as a simple loop instead of Iterable.   Simpler code gives a performance bump:           * -- 0.17      *       * Run: 10 - 271 147 198 ops/sec      * Run: 11 - 274 821 481 ops/sec      * Run: 12 - 271 632 295 ops/sec      * Run: 13 - 277 876 014 ops/sec      * Run: 14 - 274 821 763 ops/sec      *       * -- 0.16.1      *       * Run: 10 - 222 104 280 ops/sec      * Run: 11 - 224 311 761 ops/sec      * Run: 12 - 222 999 339 ops/sec      * Run: 13 - 222 344 174 ops/sec      * Run: 14 - 225 247 983 ops/sec - also cleaned up some stuff I remembered after merging last commits Manual merge of https://github.com/Netflix/RxJava/pull/836 The generics insanity has to stop.  This pull request is a result of @abersnaze and I continuing to fail to make generics work with this signature:      java Func1<Subscriber<? super R>  Subscriber<? super T>>      It all fell apart while trying to do things that needed the equivalent of:      java Func1<Subscriber<? super R>  Subscriber<? super ? super T>>      ... and other such variants.  With this change I can also finally get the  OperatorMerge  generics to work.   Thus  the  Operator  type exists inside  Observable  just like  OnSubscribe  like this:      java     /**      * Operator function for lifting into an Observable.      */     public interface Operator<R  T> extends Func1<Subscriber<? super R>  Subscriber<? super T>> {         // cover for generics insanity     }      This gives us imports like this:      java import rx.Observable  import rx.Observable.OnSubscribe  import rx.Observable.Operator       I know it s not as pure as having  lift(Func1)  but this is far more usable.      java public <R> Observable<R> lift(final Operator<R  T> bind)      If anyone has a different suggestion that still solves the generics issue please let me know. Migrate to use updated conventions of Operator\* classes that implement rx.Observable.Operator Make recursive scheduling a first-class citizen without needing to refer to  this  which doesn t work inside lambdas (Java8/Scala/etc).      java         Schedulers.newThread().scheduleRecursive(new Action1<Recurse>() {             @Override             public void call(Recurse r) {                 System.out.println( do stuff on thread:   + Thread.currentThread() +   Time:   + System.nanoTime())                  r.schedule(100  TimeUnit.MILLISECONDS)              }         }) Reverting to only having unbounded  observeOn  in public API as per comment at https://github.com/Netflix/RxJava/pull/835#issuecomment-35299824  Leaving the bounded implementation as an internal operator implementation for now to be discussed further in v0.18 dev cycle. Working with @headinthebox based on discussions at https://github.com/Netflix/RxJava/pull/869 and https://github.com/Netflix/RxJava/pull/880#issuecomment-35163539 we determined that there are times when  unsubscribeOn  behavior is needed.  The  subscribeOn  operator can not mix  subscribe  and  unsubscribe  scheduling behavior without breaking the  lift / Subscriber  behavior that allows unsubscribing synchronous sources. The newly added  unsubscribeOn  operator will not work with synchronous unsubscribes  but it will work for the targeted use cases such as UI event handlers. Move all classes into proper homes rather than having  rx.util  as the miscellaneous dumping grounds.  I have attempted to make rx.util.functions.\* have deprecated proxies to ease the migration. I m doing this in 0.17 instead of waiting since 0.17 already has breaking changes. nan nan Fixing bug report from https://github.com/Netflix/RxJava/issues/897 Allow setting different default schedulers for use by system. 1) Deprecate Direct Access to Scheduler Implementations  This enforces the convention of using  Schedulers.*  and then makes the RxJavaDefaultSchedulers plugin more reliable.  2) Scheduler instances should be or behave like singletons  Remove the Func0 factory signature for Scheduler creation. I think we can use  groupBy(keySelector).map(elementSelector)  instead. Is there any reason to keep this signature?  Related to https://github.com/Netflix/RxJava/commit/02ccc4d727a9297f14219549208757c6e0efce2a#commitcomment-5430646 Like finallyDo but before emitting the terminal state instead of after. Fixes https://github.com/Netflix/RxJava/pull/868 and https://github.com/Netflix/RxJava/pull/917 Do error handling in the  lift  function rather than try/catch in  subscribe  since this catches at the operator level rather than for an entire sequence. This then allows  onErrorResumeNext  and siblings to handle the error instead of it only being emitted to the final  Subscriber .  I derived this fix while working on Hystrix 1.4. nan nan Moving the average/sum/min/max functionality to the MathObservable similar to StringObservable.  Similar to the rxjava-string module this is seeking to achieve the goal of keeping rxjava-core focused on core functionality. Updated to use  lift  and Subscriber. Fixes https://github.com/Netflix/RxJava/issues/943 Observable.retry() does not unsubscribe from source Fixes https://github.com/Netflix/RxJava/pull/940 via manual merge. This pull request replaces use of  SynchronizedObserver  with  SerializedObserver .  ### Why? #### 1) Deadlocks  Holding a lock while emitting notifications ( onNext    onCompleted    onError ) allows for deadlocks if the event results in a cycle back to the parent.   While testing RxJava 0.17.0 in Netflix production we ran into one of these. The vulnerability has existed all along but we finally hit it.  This issue has also been reported before such as: http://twistedoakstudios.com/blog/Post8424_deadlocks-in-practice-dont-hold-locks-while-notifying #### 2) Blocking Threads  The use of  synchronized  can block threads. If it s used in areas such as modifying a data structure this can be okay. When emitting a notification however it is a problem as the result of an  onNext  can take a non-deterministically long time to complete. This means any other thread trying to emit will be blocked.  If the source threads are event loops (such as Vert.x or Netty) this will block the event loops.   For example  if two network calls off two Netty event loops are being merged (such as via  flatMap ) and one of them does further slow processing that causes  onNext  to be slow  it will block the other  onNext  which blocks the event loop and prevents any further IO on that thread. This is a significant problem for system scale and breaks the promise of Rx being a non-blocking  reactive library. ### Solution  The  synchronize    SynchronizedObserver  and  SynchronizedSubscriber  operator and classes have been deprecated. They are replaced by  serialize    SerializedObserver  and  SerializedSubscriber .  The  SerializedObserver  still ensures only a single thread can emit  onNext    onCompleted   or  onError  at a time but does not hold a lock while doing so. Instead of blocking threads it will accept the incoming events into a buffer. Thus  it becomes an asynchronous operator.  The  merge  operator (which impacts  flatMap ) now uses  SerializedObserver   along with any other place in RxJava that needed synchronization. ### Implementation  3 implementatations were written and tested: - [queue and counter](https://github.com/benjchristensen/RxJava/blob/serialize-implementations/rxjava-core/src/main/java/rx/observers/SerializedObserverViaQueueAndCounter.java) - [queue and lock](https://github.com/benjchristensen/RxJava/blob/serialize-implementations/rxjava-core/src/main/java/rx/observers/SerializedObserverViaQueueAndLock.java) - [atomic state machine](https://github.com/benjchristensen/RxJava/blob/serialize-implementations/rxjava-core/src/main/java/rx/observers/SerializedObserverViaStateMachine.java)  Performance testing [revealed](https://github.com/benjchristensen/RxJava/blob/serialize-implementations/rxjava-core/src/perf/java/rx/operators/OperatorSerializePerformance.java):      java     /**      * 1 streams emitting in a tight loop. Testing for single-threaded overhead.      *       * -> blocking synchronization (SynchronizedObserver)      *       * Run: 10 - 58 186 310 ops/sec      * Run: 11 - 60 592 037 ops/sec      * Run: 12 - 58 099 263 ops/sec      * Run: 13 - 59 034 765 ops/sec      * Run: 14 - 58 231 548 ops/sec      *       * -> state machine technique (SerializedObserverViaStateMachine)      *       * Run: 10 - 34 668 810 ops/sec      * Run: 11 - 32 874 312 ops/sec      * Run: 12 - 33 389 339 ops/sec      * Run: 13 - 35 269 946 ops/sec      * Run: 14 - 34 165 013 ops/sec      *       * -> using queue and counter technique (SerializedObserverViaQueueAndCounter)      *       * Run: 10 - 19 548 387 ops/sec      * Run: 11 - 19 471 069 ops/sec      * Run: 12 - 19 480 112 ops/sec      * Run: 13 - 18 720 550 ops/sec      * Run: 14 - 19 070 383 ops/sec      *       * -> using queue and lock technique (SerializedObserverViaQueueAndLock)      *       * Run: 10 - 51 295 152 ops/sec      * Run: 11 - 50 317 937 ops/sec      * Run: 12 - 51 126 331 ops/sec      * Run: 13 - 52 418 291 ops/sec      * Run: 14 - 51 694 710 ops/sec      */      /**      * 2 streams emitting in tight loops so very high contention.      *       * -> blocking synchronization (SynchronizedObserver)      *       * Run: 10 - 8 361 252 ops/sec      * Run: 11 - 7 184 728 ops/sec      * Run: 12 - 8 249 685 ops/sec      * Run: 13 - 6 831 595 ops/sec      * Run: 14 - 8 003 358 ops/sec      *       * (faster because it allows each thread to be  single threaded  while blocking the other)      *       * -> state machine technique (SerializedObserverViaStateMachine)      *       * Run: 10 - 4 060 062 ops/sec      * Run: 11 - 3 561 131 ops/sec      * Run: 12 - 3 721 387 ops/sec      * Run: 13 - 3 693 909 ops/sec      * Run: 14 - 3 516 324 ops/sec      *       * -> using queue and counter technique (SerializedObserverViaQueueAndCounter)      *       * Run: 10 - 4 300 229 ops/sec      * Run: 11 - 4 395 995 ops/sec      * Run: 12 - 4 551 550 ops/sec      * Run: 13 - 4 443 235 ops/sec      * Run: 14 - 4 158 475 ops/sec      *       * -> using queue and lock technique (SerializedObserverViaQueueAndLock)      *       * Run: 10 - 6 369 781 ops/sec      * Run: 11 - 6 933 872 ops/sec      * Run: 12 - 5 652 535 ops/sec      * Run: 13 - 5 503 716 ops/sec      * Run: 14 - 6 219 264 ops/sec      */      /**      * 2 streams emitting once a millisecond. Slow emission so little to no contention.      *       * -> blocking synchronization (SynchronizedObserver)      *       * Run: 10 - 1 996 ops/sec      * Run: 11 - 1 996 ops/sec      * Run: 12 - 1 995 ops/sec      * Run: 13 - 1 997 ops/sec      * Run: 14 - 1 996 ops/sec      *       * -> state machine technique (SerializedObserverViaStateMachine)      *       * Run: 10 - 1 996 ops/sec      * Run: 11 - 1 996 ops/sec      * Run: 12 - 1 996 ops/sec      * Run: 13 - 1 996 ops/sec      * Run: 14 - 1 996 ops/sec      *       * -> using queue and counter technique (SerializedObserverViaQueueAndCounter)      *       * Run: 10 - 1 996 ops/sec      * Run: 11 - 1 996 ops/sec      * Run: 12 - 1 996 ops/sec      * Run: 13 - 1 996 ops/sec      * Run: 14 - 1 995 ops/sec      *       * -> using queue and lock technique (SerializedObserverViaQueueAndLock)      *       * Run: 10 - 1 996 ops/sec      * Run: 11 - 1 996 ops/sec      * Run: 12 - 1 997 ops/sec      * Run: 13 - 1 996 ops/sec      * Run: 14 - 1 995 ops/sec      */      The state machine solution was tested in production but caused performance problems  most likely due to the immense object allocation it needs to do.   The elegant  queue and counter  solution does not perform well enough in the non-contended case.  The  queue and lock  model performs well in the non-contended case and under contention  despite not being a very elegant solution and requiring the use of mutex locks for the state changes (but it does not hold the locks during notification). ### Considerations  This does allow unbounded buffer growth  the same as  observeOn  and  zip  instead of blocking the producer threads.  ### Conclusion  The implementation in this pull request can and likely will be improved over time. The other implementations are purposefully being shown to allow others to provide further insight on how to do this better.   This change is important to ensure RxJava is non-blocking and our canary testing of this change in the Netflix production environment suggests this change is both performant and functional. nan nan nan Re-throw when onError throws an Exception. This fixes https://github.com/Netflix/RxJava/issues/969 Rewrite of  SerializedObserver  by @akarnokd discussed at  https://github.com/Netflix/RxJava/pull/962#discussion_r10601839 from this Gist: https://gist.github.com/akarnokd/9545150 #### JMH Benchmarks  0.17.3      Benchmark                                                          (size)   Mode   Samples         Mean   Mean error    Units r.operators.OperatorSerializePerf.noSerializationSingleThreaded      1024   avgt         5       45.504        1.710    ns/op r.operators.OperatorSerializePerf.noSerializationSingleThreaded   1048576   avgt         5       58.600        5.647    ns/op r.operators.OperatorSerializePerf.serializedSingleStream             1024   avgt         5       68.610        4.596    ns/op r.operators.OperatorSerializePerf.serializedSingleStream          1048576   avgt         5       71.313        2.318    ns/op r.operators.OperatorSerializePerf.synchronizedSingleStream           1024   avgt         5       73.322        3.666    ns/op r.operators.OperatorSerializePerf.synchronizedSingleStream        1048576   avgt         5       76.518        1.355    ns/op      0.17.2      Benchmark                                                          (size)   Mode   Samples         Mean   Mean error    Units r.operators.OperatorSerializePerf.noSerializationSingleThreaded      1024   avgt         5       45.790        1.184    ns/op r.operators.OperatorSerializePerf.noSerializationSingleThreaded   1048576   avgt         5       58.518        3.788    ns/op r.operators.OperatorSerializePerf.serializedSingleStream             1024   avgt         5       72.665        7.851    ns/op r.operators.OperatorSerializePerf.serializedSingleStream          1048576   avgt         5       74.788        2.946    ns/op r.operators.OperatorSerializePerf.synchronizedSingleStream           1024   avgt         5       73.661        3.499    ns/op r.operators.OperatorSerializePerf.synchronizedSingleStream        1048576   avgt         5       78.386        5.036    ns/op     #### Manual Benchmarks      java /**  * 0.17.3:  *  * Run: 10 - 9 746 505 ops/sec  * Run: 11 - 9 956 019 ops/sec  * Run: 12 - 10 053 770 ops/sec  * Run: 13 - 10 076 958 ops/sec  * Run: 14 - 9 983 319 ops/sec  *  * 0.17.2:  *  * Run: 10 - 9 851 999 ops/sec  * Run: 11 - 9 726 975 ops/sec  * Run: 12 - 9 719 762 ops/sec  * Run: 13 - 9 668 141 ops/sec  * Run: 14 - 9 799 700 ops/sec  *  * @param input  */ public void serializedSingleStream(Input input) {     for (int i = 0  i < reps  i++) {         input.observable.serialize().subscribe(input.subscriber)      } } Migrate from reflection to unsafeSubscribe as per discussion at https://github.com/Netflix/RxJava/issues/676  All operators are migrated to using  unsafeSubscribe  instead of relying on their package to avoid  SafeSubscriber  wrapping. nan @akarnokd I have manually merged your changes (https://github.com/Netflix/RxJava/pull/972) and migrated from  Action1  to  Action0  as we discussed.   Can you review what I did on top of your changes to make sure it s correct. It seems correct to me but there is some nuanced concurrency here (obviously  hence your fixes) and I would appreciate your validation. API redesign (simplification) as per discussion at https://github.com/Netflix/RxJava/issues/997  The  Scheduler  API in this pull request is:      java class Scheduler {     public abstract Inner Inner()       public int degreeOfParallelism()      public long now()       public abstract static class Inner implements Subscription {         public abstract Subscription schedule(Action0 action  long delayTime  TimeUnit unit)          public abstract Subscription schedule(Action0 action)          public final void schedulePeriodically(Action0 action  long initialDelay  long period  TimeUnit unit)          public long now()      } }      While migrating to this I found a 4th use case in addition to the previously discussed 3 that required the  schedule  methods inside  Inner  to also return  Subscription  for canceling the individual tasks as opposed to the entire  Inner .  Here are the use cases: #### 1) Single Action      java final Inner is = scheduler.inner()  is.schedule(new Action0() {      @Override     public void call() {         // do work here     } })  is.unsubscribe()      with lambda      java final Inner is = scheduler.inner)  is.schedule(() -> {         // do work here })  is.unsubscribe()     #### 2) Inner Recursion      java final Inner is = scheduler.inner()  is.schedule(new Action0() {      @Override     public void call() {         // do work here then recursively reschedule     is.schedule(this)  // this will NOT work with lambdas  only anonymous inner classes     } })  is.unsubscribe()     #### 3) Outer Recursion      java final Inner is = scheduler.inner()   public void onNext(T t) {     is.schedule(new Action0() {          @Override         public void call() {             // do work here         }     }) }  is.unsubscribe()     #### 4) Outer Recursion with Task Cancellation  This is used for things like  debounce  and  throttleLast  where tasks are being scheduled and cancelled as  onNext  notifications are received.      java final Inner is = scheduler.inner()  SerialSubscription serial = new SerialSubscription()   public void onNext(T t) {     // schedule a new task and cancel previous if not yet executed     serial.set(is.schedule(new Action0() {          @Override         public void call() {             // do work here         }     }))  }  is.unsubscribe() Removing  ExecutorScheduler  as it does not comply with the contract of sequential execution. A Scheduler needs to guarantee sequential execution  but putting work on a multi-threaded thread pool allows concurrent execution.   See https://github.com/Netflix/RxJava/issues/711 and https://github.com/Netflix/RxJava/issues/713 Migrating rx.joins into a separate contrib module as part of roadmap to 1.0: https://github.com/Netflix/RxJava/issues/1001#issuecomment-40390984 This is being done until the rx.joins API has further time to mature as it is likely to change and we can t make breaking changes any further once we hit 1.0. Manually merge #967 ComputationScheduler -> EventLoopsScheduler Restoring parallel() to using Schedulers.computation() The time has come to delete the deprecated methods/classes.  A few still remain to be done before 1.0 but can t be done until all operators are migrated: -  Observable.OnSubscribeFunc  -  Observable.create(OnSubscribeFunc)  -  SafeObservableSubscription  -  SafeObserver nan As per decision at https://github.com/Netflix/RxJava/issues/997#issuecomment-40998613 This was a manual merge since each of these was conflicting due to the changing import statements at the top. I really wish Github allowed easily handling these ... ... oxymoronic commit here ... adding some safety to unsafeSubscribe. ... fixes https://github.com/Netflix/RxJava/issues/1090 nan Merging many PRs that were conflicting.  Heroic work by @akarnokd and @zsxwing on #1060   All unit tests are passing on my machine. Going to let this bake a while before a release. Other PRs on still on their way ... attempt to reduce merge conflicts as it s always the import statements that are conflicting nan Fixes https://github.com/Netflix/RxJava/issues/1147#issuecomment-42232464 with change from @akarnokd Fixes https://github.com/Netflix/RxJava/issues/1157 nan nan - Fixes https://github.com/Netflix/RxJava/issues/1116 - These should never have been added  the subscribeOn operator already provides this functionality As per discussion in #682 As per discussion at https://github.com/Netflix/RxJava/issues/678  Code now can look like this:      java Observable.from(1  2  3).limit(2).forEach(System.out::println)       as an alias to this:      java Observable.from(1  2  3).take(2).subscribe(System.out::println) As per discussion at https://github.com/Netflix/RxJava/pull/1224#issuecomment-43658284  This will better match  toParallel  and is shorter to use while still being clear as to what is happening. Remove Subscription Wrapper from Observable.subscribe  Performance increase from 7.7m to 8.8m ops/second  Before:      Benchmark (size) Mode Samples Mean Mean error Units r.u.PerfTransforms.mapTransformation 1 thrpt 5 7714453.187 362218.633 ops/s r.u.PerfTransforms.mapTransformation 1 thrpt 5 7527144.767 497816.471 ops/s      After:      Benchmark (size) Mode Samples Mean Mean error Units r.u.PerfTransforms.mapTransformation 1 thrpt 5 8853534.333 183494.242 ops/s r.u.PerfTransforms.mapTransformation 1 thrpt 5 8806958.403 452595.219 ops/s      Test can be run  using:      ../gradlew benchmarks  -Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 5 -prof GC .*PerfTransforms.mapTransformation* For code like  Observable.from(1)  Improve performance from ~3.9m to 4.5+m ops/second  Before       r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  3923845.687    46657.660    ops/s r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     8924.953     1983.161    ops/s  r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  3623228.857   490894.492    ops/s r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5     9176.330      923.929    ops/s      After:      Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  4052364.587   100971.234    ops/s r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5    11682.783      496.656    ops/s  Benchmark                                       (size)   Mode   Samples         Mean   Mean error    Units r.u.PerfTransforms.flatMapTransformsUsingFrom        1  thrpt         5  4700583.987    77742.037    ops/s r.u.PerfTransforms.flatMapTransformsUsingFrom     1024  thrpt         5    12588.803       58.935    ops/s      Using this test:      ../gradlew benchmarks  -Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 5 -prof GC .*PerfTransforms.flatMapTransformsUsingFrom* The encoding on these files is not liked by Git and it is forcing them to be updated.  /cc @akarnokd As you may want to look at your setup ... this happens somewhat often on commits from you.  I believe it is related to these  .gitattribute  settings:      # Set default behaviour  in case users don t have core.autocrlf set. * text=auto  # Explicitly declare text files we want to always be normalized and converted  # to native line endings on checkout. *.java text *.groovy text *.scala text *.clj text *.txt text *.md text  # Denote all files that are truly binary and should not be modified. *.png binary *.jpg binary ### Changes - rewrite of  CompositeSubscription  and added  ChainedSubscription  - significant reduction in object allocations - details on research available at https://github.com/Netflix/RxJava/issues/1204 ##### Atomic State Machine -> Mutation & Locks  The  CompositeSubscription  implementation was changed from using an atomic state machine to using locks. The state machine requires immutable  State  that is swapped using CAS. This means an object allocation is needed each time.  It now uses locks to protect mutable state so very few objects are created. ##### ChainedSubscription  The  CompositeSubscription  requires support of randomly removing a  Subscription  via the  remove  method. The  Subscriber  type does not expose this so can be optimized. There is now a  ChainedSubscription  that is used by  Subscriber  instead. This allows using a  LinkedList  or  ArrayList  rather than  HashSet  as random access is never needed. This provides a slight performance boost and reduces memory usage (1 minute test shows 16.5GB allocation for  Composite  versus 14.4GC for  Chained ). ### Allocation Comparison  This shows Java Flight Recorder output from master without these changes:  ![master-without-changing-compositesubscription](https://cloud.githubusercontent.com/assets/813492/3122035/66ea4e22-e762-11e3-8915-5aead429e120.png)  This shows object allocation after changing  CompositeSubscription :  ![master-with-new-compositesubscription ong](https://cloud.githubusercontent.com/assets/813492/3122195/9f3641bc-e764-11e3-930f-845efc99b84a.png) ### Throughput Comparison  Testing this code:      java     public void mapTransformation(UseCaseInput input) throws InterruptedException {         input.observable.map(i -> {             return String.valueOf(i)           }).map(i -> {             return Integer.parseInt(i)          }).subscribe(input.observer)          input.awaitCompletion()      }     ##### Rx 0.16.1      Run: 10 - 2 879 355 ops/sec  Run: 11 - 3 236 245 ops/sec  Run: 12 - 4 468 275 ops/sec  Run: 13 - 3 237 293 ops/sec  Run: 14 - 4 683 840 ops/sec      ##### Rx 0.17.6 - using OnSubscribeFunc      Run: 10 - 3 621 876 ops/sec  Run: 11 - 6 702 412 ops/sec  Run: 12 - 7 401 924 ops/sec  Run: 13 - 6 653 359 ops/sec  Run: 14 - 5 834 305 ops/sec      ##### Rx 0.17.6 - using OnSubscribe      Run: 10 - 3 320 053 ops/sec  Run: 11 - 4 520 795 ops/sec  Run: 12 - 7 107 320 ops/sec  Run: 13 - 5 089 058 ops/sec  Run: 14 - 5 534 034 ops/sec   Run: 10 - 4 930 966 ops/sec  Run: 11 - 6 119 951 ops/sec  Run: 12 - 7 062 146 ops/sec  Run: 13 - 6 514 657 ops/sec  Run: 14 - 6 369 426 ops/sec      ##### Rx 0.18.3 - using OnSubscribe      Run: 10 - 4 178 854 ops/sec  Run: 11 - 4 446 420 ops/sec  Run: 12 - 5 458 515 ops/sec  Run: 13 - 8 006 405 ops/sec  Run: 14 - 7 849 293 ops/sec   Run: 10 - 4 145 936 ops/sec  Run: 11 - 6 553 079 ops/sec  Run: 12 - 7 645 259 ops/sec  Run: 13 - 7 385 524 ops/sec  Run: 14 - 7 830 853 ops/sec      ##### Rx 0.19 master - CompositeSubscription state machine      Run: 10 - 10 576 302 ops/sec  Run: 11 - 10 518 786 ops/sec  Run: 12 - 10 554 646 ops/sec  Run: 13 - 10 314 063 ops/sec  Run: 14 - 10 666 439 ops/sec      ##### Rx 0.19 master - CompositeSubscription with synchronized HashSet      Run: 10 - 9 949 060 ops/sec  Run: 11 - 10 122 379 ops/sec  Run: 12 - 10 018 032 ops/sec  Run: 13 - 10 072 522 ops/sec  Run: 14 - 10 132 636 ops/sec      ##### Rx 0.19 master - ChainedSubscription with synchronized ArrayList      Run: 10 - 11 086 351 ops/sec  Run: 11 - 10 932 426 ops/sec  Run: 12 - 11 002 431 ops/sec  Run: 13 - 10 888 620 ops/sec  Run: 14 - 11 157 227 ops/sec   Run: 10 - 9 371 192 ops/sec  Run: 11 - 9 829 169 ops/sec  Run: 12 - 10 139 005 ops/sec  Run: 13 - 10 099 785 ops/sec  Run: 14 - 10 017 631 ops/sec      ##### Rx 0.19 master - ChainedSubscription with synchronized LinkedList      Run: 10 - 10 619 431 ops/sec  Run: 11 - 11 063 293 ops/sec  Run: 12 - 11 001 463 ops/sec  Run: 13 - 11 054 243 ops/sec  Run: 14 - 10 898 826 ops/sec   Run: 10 - 10 075 465 ops/sec  Run: 11 - 9 780 716 ops/sec  Run: 12 - 9 885 134 ops/sec  Run: 13 - 9 584 143 ops/sec  Run: 14 - 10 000 700 ops/sec - significant reduction in object allocations - details on research available at https://github.com/Netflix/RxJava/issues/1204 Pulling in the MPSC queue from https://github.com/Netflix/RxJava/pull/1235. Leaving out the SerializedObserver change until further analysis. Getting this data structure in as we likely want to use it in other places.  Moved it into rx.internal.util and added a README so it is very clear this is an internal package and not part of the public API. As per decision at https://github.com/Netflix/RxJava/issues/1219#issuecomment-44454729 As per https://github.com/Netflix/RxJava/issues/1205 - The tests were wrong and re-using a single Subscriber instance which meant they weren t really testing much. - Same with the CountDownLatch which meant they weren t waiting if async. - Added several SerializePerf and PerfTransform tests Move  rx.operators  to  rx.internal.operators  for clarity that these can change at any time and are not part of the public API.  Discussed at https://github.com/Netflix/RxJava/issues/1270#issuecomment-44668606 As per a change @akarnokd did elsewhere with  accept2  method. Trying to make this deterministic ... I think it was possible for scheduling in the Executor to cause different threads to be used  even when queueing happened. This forces the same thread to be used as it is different Executors. Instead of adding this type to the public API  it hides it as an internal implementation detail and does not expose it via the  Subscriber  constructor.  If we want to expose it later we can figure out a proper name and do so.  This also changes operator implementations to not inject a  SubscriptionList  but instead just create the  Subscriber  and use it directly. Unsubscribing should prevent new additions to a Worker  but not prevent already scheduled work  and definitely not affect other Workers using the same thread (by modifying the ThreadLocal as it was doing).  See the unit test for details of how unsubscribing 1 Worker could prevent work from being done on a completely separate Worker. Single-arity instance versions of merge  concat and amb. Since we can t use the  merge / concat / amb  names on both static and instance methods  these have the  With  suffix  which actually reads quite well.      java o.mergeWith(o2).subscribe(ts)  o.concatWith(o2).subscribe(ts)  o.ambWith(o2).subscribe(ts)       If we feel the need for more arities fine  but I wanted to start simple.  This originated from discussions with @headinthebox and over a year of wanting instance methods for  merge . This updates all perf testing to use only JMH. I tried to get all of them to follow a common pattern  and to comply with examples at https://github.com/nitsanw/jmh-samples/blob/master/src/main/java/org/openjdk/jmh/samples/ by @nitsanw. (@nitsanw if you re willing to take a look at this and confirm or correct them  I d appreciate that).  I am doing this in 0.19 so that work on 0.20 has a common set of perf tests to use for comparison. ... found while working on backpressure. nan matching with work being done for 0.20 to allow comparisons Various data structures to allow performance improvements. I am committing these separately from the code that uses it to keep the pull requests simpler. Nothing in RxJava depends on these classes in this commit. This is a functioning implementation of backpressure. Of the major unbounded queue operators in 0.19  this implements  observeOn  and  merge  but not yet  zip .  ### New Signatures      java public interface Producer {     public void request(int n)  }          java public abstract class Subscriber<T> implements Observer<T>  Subscription {      /**      * Optionally called from  Observable.OnSubscribe .      */     public final void setProducer(Producer producer)       /**      * Allow implementing classes to capture  decorate or override the  Producer  without affecting the  Subscriber  logic.      */     protected Producer onSetProducer(Producer producer)       public final void request(int n)  } A handful of fixes  particularly one that could cause non-deterministic missing data. This is a proposal derived from conversations with @headinthebox to use  Subscriber.onStart  rather than constructor overloads as the mechanism for allowing  request(n)  to be called to operationally start backpressure (or do anything else at the start of a stream).  The idea is that it is at the start the same as  onError  or  onCompleted  are terminal events. It will always be called.  Usage for subscribing is like this:      java         Observable.from(1  2  3  4).take(2).subscribe(new Subscriber<Integer>() {              @Override             public void onStart() {                 request(1)              }              @Override             public void onCompleted() {              }              @Override             public void onError(Throwable e) {              }              @Override             public void onNext(Integer t) {                 System.out.println(t)                  request(1)              }          })       or when writing an  Operator  via  lift :      java         Observable.from(1  2  3  4).lift(new Operator<Integer  Integer>() {              @Override             public Subscriber<? super Integer> call(final Subscriber<? super Integer> child) {                 return new Subscriber<Integer>() {                      @Override                     public void onStart() {                         request(1)                      }                      @Override                     public void onCompleted() {                         child.onCompleted()                      }                      @Override                     public void onError(Throwable e) {                         child.onError(e)                      }                      @Override                     public void onNext(Integer t) {                         System.out.println(t)                          child.onNext(t)                          request(1)                      }                  }              }          }).subscribe()       Both of these examples are requesting 1 item at a time. Possible fix for #1420  I was unable to exactly reproduce the issue  but was able to create a possibly related one. This fixes it. It also simplifies the logic and code somewhat  at a possible small performance cost for these:      r.o.OperatorMergePerf.merge1SyncStreamOfN            1000  thrpt         5    59407.716     2073.945    ops/s r.o.OperatorMergePerf.merge1SyncStreamOfN         1000000  thrpt         5       66.557        2.693    ops/s r.o.OperatorMergePerf.mergeNSyncStreamsOfN           1000  thrpt         5       59.293        5.046    ops/s Migrating to this after discussions at https://github.com/reactive-streams/reactive-streams/issues/62 nan as per https://github.com/Netflix/RxJava/issues/1402 nan Docs for operators that don t support backpressure  particularly all the temporal operators.  Fixes for several that needed to request(1) or request(Long.MAX_VALUE). Manual merge and rebase of https://github.com/Netflix/RxJava/pull/1470 Match the naming convention of  mergeWith    concatWith    ambWith  etc. fix non-deterministic failures of BackpressureTests.testUserSubscriberUsingRequestAsync  I was able to replicate the occasional failure by putting it in a tight loop. With these changes it no longer fails. This is a proposed change to allow using a  Subject  factory with  multicast  and for methods such as  publish()  and  replay()  to use the factory so that each time  ConnectableObservable.connect()  is invoked  a new  Subject  is created and used. Otherwise  an  Observable  sequence can not be reused. #### Use Case      java         final AtomicInteger count = new AtomicInteger()          Observable<Integer> subject1 = Observable.just(10)          Observable<Integer> subject2 = Observable.just(20)          Observable<Integer> combined = Observable.combineLatest(subject1  subject2  (fst  snd) -> {             int i = count.incrementAndGet()              System.out.println((fst + i) +   +   + (snd + i))              return fst + snd          }).publish().refCount()           combined.subscribe(                 System.out::println                  t -> t.printStackTrace()                  () -> System.out.println( Completed ))           combined.subscribe(                 System.out::println                  t -> t.printStackTrace()                  () -> System.out.println( Completed ))       Output without these changes:      11 + 21 30 Completed Completed      Output with changes:      11 + 21 30 Completed 12 + 22 30 Completed     #### Test Case      java     @Test     public void testConnectDisconnectConnectAndSubjectState() {         Observable<Integer> o1 = Observable.just(10)          Observable<Integer> o2 = Observable.just(20)          Observable<Integer> combined = Observable.combineLatest(o1  o2  new Func2<Integer  Integer  Integer>() {              @Override             public Integer call(Integer t1  Integer t2) {                 return t1 + t2              }          }).publish().refCount()           TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>()          TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>()           combined.subscribe(ts1)          combined.subscribe(ts2)           ts1.assertTerminalEvent()          ts1.assertNoErrors()          ts1.assertReceivedOnNext(Arrays.asList(30))           ts2.assertTerminalEvent()          ts2.assertNoErrors()          ts2.assertReceivedOnNext(Arrays.asList(30))      } Fixes issue #1550 - migrate mapPair to use actual merge instead of reimplementing it - deprecate mergeMap  Done during API review with @headinthebox See https://github.com/Netflix/RxJava/issues/1157 for painful background. Fixes https://github.com/Netflix/RxJava/issues/1554 See https://github.com/Netflix/RxJava/issues/1416 for discussion that led to this.  This does not have co/contra-variance which needs to be figured out. Failing test while exploring generic variance for https://github.com/Netflix/RxJava/issues/1416  Code like this makes these generics work:      java     @Test     public void testCovarianceOfCompose() {         Observable<HorrorMovie> movie = Observable.<HorrorMovie> from(new HorrorMovie())          movie.compose(new Transformer<Movie  Movie>() {              @Override             public Observable<? extends Movie> call(Observable<? super Movie> t1) {                 return Observable.from(new Movie())              }          })      }      @Test     public void testCovarianceOfCompose2() {         Observable<Movie> movie = Observable.<Movie> from(new HorrorMovie())          movie.compose(new Transformer<Movie  Movie>() {              @Override             public Observable<? extends Movie> call(Observable<? super Movie> t1) {                 return Observable.from(new HorrorMovie())              }          })      }      however  I couldn t get the  compose / Transformer  types to correctly work.  Anyone else want to help figure out generics for this?  See https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/Observable.java#L195 Deprecate the from(T) methods in favor of items(T)  As per discussion in https://github.com/Netflix/RxJava/issues/1563. As per https://github.com/Netflix/RxJava/issues/1578 It was a bad solution. Use Observable.groupBy with element selector instead  See https://github.com/Netflix/RxJava/issues/1579 As per discussion at https://github.com/Netflix/RxJava/issues/1466 nan This method is nuanced and generally causes broken behavior if the Observable is subscribed to more than once. These should just use subscribeOn if scheduling is wanted.  As per https://github.com/Netflix/RxJava/issues/1580 The printStackTrace and getCause implementations have different approaches to handling circular references. If on a JVM where printStackTrace is called directly  the full causal chain will always be printed. If on one such as Dalvik where getCause is invoked directly then it will cut the causal chain if it sees a duplicate.  See https://github.com/ReactiveX/RxJava/issues/1405 Same change as https://github.com/ReactiveX/RxJava/pull/1632 against 0.20 for 1.x Removing confusing operator before locked in stone with 1.0.0 Final Removing in 1.0 as it is confusing and rarely useful. see https://github.com/ReactiveX/RxJava/issues/1673 see https://github.com/ReactiveX/RxJava/issues/1673 This is a proposed change to  groupBy  and  groupByUntil  that does the following:  1) Eliminate  groupByUntil  and rolls that functionality into  groupBy  2) Adds support for reactive pull backpressure to  groupBy  3) Child  GroupedObservable s can now be unsubscribed and they will be cleaned up and then new instances for the same key can be emitted  like  groupByUntil  worked  except that now instead of passing in a special durationSelector function  the child can be composed using  take / takeUntil /etc to cause an unsubscribe.  If the previous non-obvious groupBy behavior is wanted  then instead of unsubscribing  it can be filtered to ignore all further data  which is what the old groupBy used to do when a child was unsubscribed.  The reason for these changes are: - Adding backpressure to  groupByUntil  was very difficult with its existing signature as the duration selector function effectively required a  GroupedObservable  being a  PublishSubject  which meant multicasting. In this specific case it may have been possible to do backpressure with the multicasting  but it would be difficult and non-obvious as generally multicasting means the stream is  hot  and reactive pull backpressure can t be applied. - The existing  groupBy  almost always confused people as to what would happen when they unsubscribed a child using  take  or  takeUntil . It always surprised people that it meant all further data would be dropped but the key and group would not be garbage collected. Almost always on an infinite stream people determined they needed  groupByUntil   but only after stumbling around. After speaking with @headinthebox about this briefly we had enough agreement to submit this proposal and discuss further.  Now  groupBy  can behave by default as people expect with  unsubscribe  and support infinite streams  garbage collection  etc as well as backpressure.  I will provide usage examples below. Was accidentally committed in old rxjava-core src folder. I tried for about 30 minutes to replicate the NPE reported in https://github.com/ReactiveX/RxJava/issues/1702 but couldn t. It makes sense reading the code that an unsubscribe could trigger an NPE though so I m fixing it as per recommendation of @DylanSale even though I can t replicate. I confirmed that the items are being put in the queue BEFORE the wip variable is incremented  so that concurrency seems okay. Updated the implementations to support reactive pull backpressure. Fixes https://github.com/ReactiveX/RxJava/issues/1724 Fixes https://github.com/ReactiveX/RxJava/issues/1684 - Remove  EmptyObserver  as it was confusing compared to  Observers.empty()  (fixes #1741) - Make  TestObserver  not throw  OnErrorNotImplemented  if a delegate is not provided (fixes #1571) Fixes https://github.com/ReactiveX/RxJava/issues/1685 by delaying errors that are caught until after all subscribers have a chance to receive the event.  Note that this has a lot of code duplication to handle this across the Subject implementations. It may be worth abstracting this logic ... but right now I m just doing what makes sense to fix this as the Subject abstractions are non-trivial. Proposal for a  SerializedSubject  type to simplify solution for multi-threaded emissions to a  Subject .  See https://github.com/ReactiveX/RxJava/issues/1744 Manual merge of https://github.com/ReactiveX/RxJava/pull/1762 with an extra unit test added. Implementation of  publish  with backpressure: https://github.com/ReactiveX/RxJava/issues/1732  This moves away from using the  multicast  operator and  PublishSubject  as per discussion in #1732 and #1779 The implementation is still there as  replay  is still using it  but the public API is removed.  See https://github.com/ReactiveX/RxJava/issues/1779 for discussion. See https://github.com/ReactiveX/RxJava/issues/1782 -> Remove takeWhileWithIndex & skipWhileWithIndex See https://github.com/ReactiveX/RxJava/issues/1785 See https://github.com/ReactiveX/RxJava/issues/1668 Remove utility methods and classes as per https://github.com/ReactiveX/RxJava/issues/1799 and https://github.com/ReactiveX/RxJava/issues/1798 Fixes https://github.com/ReactiveX/RxJava/issues/1797 Fixes https://github.com/ReactiveX/RxJava/issues/1816 Adds toSerialized as discussed in https://github.com/ReactiveX/RxJava/issues/1748 Adds overload with seed factory as per https://github.com/ReactiveX/RxJava/issues/1831 Before hitting 1.0 removing this API as it is not used. This puts the seed factory on  collect  and removes it from  scan  and  reduce  due to ambiguity. See https://github.com/ReactiveX/RxJava/pull/1883 and https://github.com/ReactiveX/RxJava/issues/1881  The  collect  API was already very close so this fixes it to use a seed factory so the signature is now:      java public final <R> Observable<R> collect(Func0<R> stateFactory  final Action2<R  ? super T> collector) {      I remove the factory overloads for  scan  and  reduce  due to the issue in #1881 related to generics  type erasure and lambdas causing ambiguity and compilation failures.  We may want to add at least a  scan  impl in the future with a seed factory  but it will need a different name if we do such as  scanTo . I don t want to do that now for 1.0 so we ll need to revisit that for 1.1 with more time to think about it. Manual merge of https://github.com/ReactiveX/RxJava/pull/1790 by @ylecaillez An experimental implementation of  onBackpressureBlock .  An open question is whether this should be allowed to block if running on a known eventloop such as  Schedulers.computation()  or should instead emit an error in that situation. Reverts ReactiveX/RxJava#1916  This breaks unit tests all over for some reason. I completely missed it before merging as the unit tests related to  onBackpressureBuffer  themselves pass. It s elsewhere that things break.   From what I can tell it is because  onBackpressureBuffer  is used in unit tests and those fail (often with timeouts or what appears to be infinite loops ... since my CPU pegs itself). Similar to doOnSubscribe  doOnNext  etc Reverts change made at https://github.com/ReactiveX/RxJava/pull/2332/files#diff-fbed6a16f49022fd2b10f45fd6dd015bR230  See discussion at https://github.com/ReactiveX/RxJava/issues/2549#issuecomment-72783738  The Javadoc for this method clearly states that it will wait until completion or timeout. It does not say it will throw an exception on timeout  so we can not start throwing as that is a behavioral change. Adds  rx.Single  as an  Observable Future  for representing work with a single return value.  See https://github.com/ReactiveX/RxJava/issues/1594 rx.Future/Task/Async/Single  This provides a type similar to  Future  in that it represents a scalar unit of work  but it is lazy like an  Observable  and many  Single s can be combined into an  Observable  stream. Note how  Single.zip  returns  Single<R>  whereas  Single.merge  returns  Observable<R> .  Examples of using this class:      java import rx.Observable  import rx.Single   public class TaskExamples {      public static void main(String... args) {         // scalar synchronous value         Single<String> t1 = Single.create(t -> {             t.onSuccess( Hello World! )          })           // scalar synchronous value using helper method         Single<Integer> t2 = Single.just(1)           // synchronous error         Single<String> error = Single.create(t -> {             t.onError(new RuntimeException( failed! ))          })           // executing         t1.subscribe(System.out::println)          t2.subscribe(System.out::println)          error.subscribe(System.out::println  e -> System.out.println(e.getMessage()))           // scalar Singles for request/response like a Future         getData(1).subscribe(System.out::println)           // combining Tasks into another Task         Single<String> zipped = Single.zip(t1  t2  (a  b) -> a +   --   + b)           // combining Singles into an Observable stream         Observable<String> merged = Single.merge(t1  t2.map(String::valueOf)  getData(3))          Observable<String> mergeWith = t1.mergeWith(t2.map(String::valueOf))           zipped.subscribe(v -> System.out.println( zipped =>   + v))          merged.subscribe(v -> System.out.println( merged =>   + v))          mergeWith.subscribe(v -> System.out.println( mergeWith =>   + v))      }      /**      * Example of an async scalar execution using Single.create      * <p>      * This shows the lazy  idiomatic approach for Rx exactly like an Observable except scalar.      *      * @param arg      * @return      */     public static Single<String> getData(int arg) {         return Single.create(s -> {             new Thread(() -> {                 try {                     Thread.sleep(500)                  } catch (Exception e) {                     e.printStackTrace()                  }                 // deliver value                     s.onSuccess( Data=  + arg)                  }).start()          })      }  } This test was reported broken in https://github.com/ReactiveX/RxJava/pull/2928#issuecomment-113229698  Fixing by adding the use of LatchedObserver.  Previously broken test results:      r.o.OperatorFlatMapPerf.flatMapIntPassthruAsync         1  thrpt         5   363615.622   115041.519    ops/s r.o.OperatorFlatMapPerf.flatMapIntPassthruAsync      1000  thrpt         5      350.204      125.773    ops/s r.o.OperatorFlatMapPerf.flatMapIntPassthruAsync   1000000  thrpt         5        0.319        0.184    ops/s      Fixed results:      r.o.OperatorFlatMapPerf.flatMapIntPassthruAsync         1  thrpt         5   102109.681     8709.920    ops/s r.o.OperatorFlatMapPerf.flatMapIntPassthruAsync      1000  thrpt         5      403.071      130.651    ops/s r.o.OperatorFlatMapPerf.flatMapIntPassthruAsync   1000000  thrpt         5        0.355        0.070    ops/s Adding  Single.toObservable  as companion to  Observable.toSingle . This is to get rid of the  No newline at end of file  warning that exist on many but not all files in the project  so adds a newline to any file missing a newline. This came about while modifying a large number of files for https://github.com/ReactiveX/RxJava/issues/4978.  This is intended to clean this up once so it doesn t cause warnings and noise in each PR this can affect. Probably would be good if the project had a formatter than ensured this as part of CI. Updating all files containing a Copyright header to change from  Netflix  Inc  to  RxJava Contributors  as per https://github.com/ReactiveX/RxJava/issues/4978.,
0,0,0,0,1,0,Abhishek, 7006,0,0,0,0,1,0, Updating SuppressUndeliverableRule to have a named inner class instead of an anonymous inner class, Based on the discussion in https://github.com/ReactiveX/RxJava/issues/7005  Resolves #7005,
0,0,0,0,0,0,Yasuhiro SHIMIZU, 5146,0,0,0,0,1,1, 1.x: add unsubscribeOn to Single type (#5138), resolve #5138   add unsubscribeOn to Single type.,
0,0,0,0,0,0,Johannes Schneider, 5049 5051 5054 5055 5058,0,0,1,0,1,1, use bounded wildcards for errorHandler (fixes #5045) Feature/#4876 nonnull annotations 2.x: add nullable annotation to simple queue (fixes #5053) 2.x: Feature/#4876 more null checks Feature/#5045 more generics in RxJavaPlugins, Adding bound wildcards for error handler - fixes #5045 Issue: #4876  Starting to add @NonNull and @Nullable annotations.  I decided to add a compileOnly dependency to findbugs:jsr305 artifact.  We could also use  io.reactivex.annotations.NonNull  which already exists. But there is no  io.reactivex.annotations.Nullable  annotation which is at least as important in my experience.  Since these are only annotations  it is no problem when the class files are missing at compile time (JLS 9.6.1.2 Retention).   I have started to add annotations in the Scheduler and RxJavaPlugins. The test RxJavaPlugins contains some invalid checks using null (lines 1353 and following).   This pull request is work in progress and should be discussed.   Questions so far: - use jsr305 (compileOnly) or existing annotation in io.reactivex? - (if not using jsr305): Use own @Nullable annotation or try to get one added to  io.reactivex ? Or skip these completely (which misses the point of the static code analysis) - Why has there been tests calling the RxJavaPlugins.on*Scheduler with null arguments? Can these be removed securely? As explained in https://github.com/ReactiveX/RxJava/issues/5053 SimpleQueue might return null. To document this behavior a nullable annotation has been added. I have added some more null checks to help the static code analysis. I think I have also fixed one possible NPE in NewThreadWorker I widened the bounds for the functions. Looks good for me. Related to #5045,
0,0,0,0,0,0,Naoki Morioka, 5189,0,0,1,0,1,0, 2.x: fix concatMapEager should accept 0 for prefetch, Fixes a bug that  Flowable.concatMapEager(mapper   maxConcurrency   prefetch) and Observable.concatMapEager(mapper   maxConcurrency   prefetch) operators will not accept 0 and negative numbers.  Reported in #5185.,
0,0,0,0,0,0,Zachary Trant, 6943,0,0,0,0,1,1, docs: Quick Javadoc fixes., Added @code tag wherever < or > were used  also removed a few self-closing <p> tags. Both of these issues cause errors with the latest version of Javadoc.  Signed-off-by: Zachary Trant <zach@graalonline.com>,
0,0,0,0,0,0,Daniel Lew, 3886,0,0,0,0,1,0, throwIfFatal() now throws OnCompletedFailedException, Otherwise  if there s an error in onCompleted  the exception is swallowed and unreported.  Fixes #3885,
0,0,0,0,0,0,Ikko Ashimine, 7223 7277,0,0,0,0,1,1, 3.x: fix typo in FlowableRetryTest.java 3.x: fix typo in ObservableRetryTest.java, Thank you for contributing to RxJava. Before pressing the  Create Pull Request  button  please consider the following points:    - [x] Please give a description about what and why you are contributing  even if it s trivial.  Fixed typo below.     seperate -> separate        - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.    - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator  (if applicable) please make sure you have tests for working with an  empty    just    range  of values as well as an  error  source  with and/or without backpressure and see if unsubscription/cancellation propagates correctly. Thank you for contributing to RxJava. Before pressing the  Create Pull Request  button  please consider the following points:    - [x] Please give a description about what and why you are contributing  even if it s trivial.  Fixed typo below.     seperate -> separate        - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.    - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator  (if applicable) please make sure you have tests for working with an  empty    just    range  of values as well as an  error  source  with and/or without backpressure and see if unsubscription/cancellation propagates correctly.,
0,0,0,0,0,0,Tim van der Lippe, 4636,1,0,1,1,1,1, Update Mockito to 2.1.0-RC.2, Equivalent of #4634   but now for the 2.x branch.,
0,0,0,0,0,0,(´⌣`ʃƪ), 3799 3826 3904 4629,0,0,0,0,1,1, 1.x: Add Completable.andThen(Single) 1.x: Fix TestSubscriber.create doc 1.x: Fix Completable swallows OnErrorNotImplementedException 2.x: Add Completable.fromRunnable(), https://github.com/ReactiveX/RxJava/issues/3730 the docs of TestSubscriber.create(Subscriber) and TestSubscriber.create(Observer) got mixed up. I just swapped them. Fixed https://github.com/ReactiveX/RxJava/issues/3860 addresses #4628  > There s  Maybe.fromRunnable  but  Completable  is missing this method.,
0,0,0,0,1,0,Björn Quentin, 6262,0,0,0,0,1,1, Use JUnit s assert format for assert messages to enable better suppor…, This changes the message format of  assert  to match that of JUnit. This way IDEs like IntelliJ IDEA are able to parse it and offer functionality like  compare values .,
0,0,1,0,1,0,Paweł Hajduk, 3696,0,0,1,0,1,1, 1.x: Added Single execution hooks, Resolves #3595,
0,0,0,0,0,0,Stephan Schroevers, 5087,0,0,1,0,0,0, 2.x: Correct marble diagram dimensions, This fixes part of #4535  as requested in #5067.  These changes were generated using the following script:     sh #!/usr/bin/env bash  find . -name  *.java  -print0 \   | xargs -0 grep  ^\s*\*  \   | grep -oP  https.*?\.png  \   | sort -u \   | while read -r I  do       echo  Updating ${I}...        # Gather image details.       DATA= $(identify <(curl -f -L -s  ${I} ))         # Extract the image s true width and height.       WIDTH= $(echo  ${DATA}  | grep -oP  (?<=PNG )\d+ )        HEIGHT= $(echo  ${DATA}  | grep -oP  PNG \d+x\d+  | grep -oP  (?<=x)\d+ )         # Determine the image s scaled height  assuming a width of 640 pixels.       NEW_HEIGHT= $(echo  scale=100  s=  ${WIDTH}   / 640  scale=0    ${HEIGHT}   / s  | bc)         # Update all  <img/>  tags referencing the image.       find . -name  *.java  -print0 \         | xargs -0 perl -i -p -e  s <img( (width|height)= [^ ]* )* src= \Q  ${I}  \E  <img width= 640  height=   ${NEW_HEIGHT}    src=   ${I}    g      done,
0,0,1,0,1,0,Zac Sweers, 4651 4654 3712 3986 4972 5002 5590 5729 6301,0,1,1,0,1,1, Switch Maybe and Single to use their Transformers in compose() Upcast ConcurrentHashMap to Map to avoid compatibility issue Add takeUntil support in Single Add Schedulers.reset() for better testing Improve compose() generics 2.x: Add scheduler creation factories Implement LambdaConsumerIntrospection 2.x: Implement as() Add missing onSubscribe null-checks to NPE docs on Flowable/Observable subscribe, Resolves #4650 Resovles #4653  See http://stackoverflow.com/a/32955708/61158 As discussed in #3708  This adds  takeUntil(Observable)  and  takeUntil(Single)  support in  Single . It was mostly just adapting the logic from the existing  OperatorTakeUntil  and adjusting it for accepting a  Single  and sending a  CancelattionException  in the event of a submission from  other  prior to a terminal event in the source  Single .  Any feedback is appreciated it  this is my first time contributing an implementation to this project. Particularly wondering if it s worth keeping both overloads or if the user should just coerce their  other  to one type or ther other. Also particularly looking for feedback on what information to include in the  CancellationException . Resolves #3985  This adds a  reset()  method to  Schedulers   with the main benefit being improved testing support. This does slightly tweak the internal API of  Schedulers  to use a  getInstance()  approach to allow lazy init. This way we don t have to replace the singleton instance during  reset()  and allow it to lazily re-evaluate upon next usage. Otherwise  if you change your scheduler hook  you d always have to make sure you set it before you call  Schedulers.reset() .  Will run perf tests overnight in case  I m not sure how much of a tradeoff moving to an internal  getInstance()  approach costs  if anything.  CC @zsxwing Resolves #4950  I tested and built with the added tests on Java 6  7  and 8. Not sure if you want to keep them in before merging since they re not really functional in nature  just there to make sure they compile. Resolves #4993  This is a pretty vanilla copy from RxJava 1 s implementation. Note that I had to tune NewThread scheduler to not be a singleton to support this.  We had talked about borrowing from project reactor s APIs for different overloads  let me know if you think we should add more fine-grained controls through these. Followup from #5569  and allows you to introspect if the resulting observer has missing error consumption and subsequently supplies a default (throwing) one. This implement  as()  support as discussed in #5654  I took the opportunity to try to standardize the docs and tests for it (which vary a little bit across implementations of  to() )  Related: #5654 Happened to notice these today,
0,0,0,0,0,0,Piotr Wittchen, 5462 5467,0,0,1,0,1,1, Refactoring SingleSchedulerTest 2.x: Removing commented code from tests, Hi   I refactored  SingleSchedulerTest . Now it extends  AbstractSchedulerTests   so redundant tests (with duplicated code) could be removed in favor of abstract tests. Now  thanks to the abstract test class   SingleScheduler  has 21 unit tests instead of just 7. This approach is consistent with the test classes for other Schedulers.  Regards  Piotr Hi   In this PR I m removing commented code from tests as it s generally considered as bad practice. Part of this code is even not available in the current RxJava API. It does not resolve all of the issues like that  but only part of them. I didn t want to create PR with more changes because it will be harder to review. Rest of the similar issues could be resolved in the future PRs.  Regards  Piotr,
0,0,0,0,1,0,Jalandip Lepcha, 2574,0,0,1,0,0,0, SizeEviction test needs to return false, When a replay subject with size and time eviction policy is used then any observer that subscribes after some events are already pushed will not get those older events.  This is because if an observable is not yet terminated then on subscription by any new observer the check for event validity fails on the Size Eviction policy hence that event is dropped and not pushed to the new subscriber.  Relevant call stack:    {{{       TimeOnAdd.call      BoundedState.replayObserverFromIndexTest         BoundedState.replayObserverFromIndexTest              PairEvictionPolicy.test }}}      Test Case:  - add test case for this use case  Fails if without changes.,
0,0,0,0,0,0,Sebas LG, 3563 3791 3803,0,1,1,0,1,1, Fix typo in documentation 1.x: Fix Observable delay methods typos in documenation 1.x: Fix typos in documentation and some code, nan nan nan,
0,0,1,0,1,0,kerr, 6773,0,1,0,0,0,0, Add FunctionalInterface annotations., Resolves #6768,
0,0,0,0,0,0,Steven Zhen Wu, 2776,0,0,0,0,1,0, issue-2764: add new operator onBackpressureDrop(Action1 onDrop), nan,
0,0,0,0,0,0,Klemen Kresnik, 3686 3720,0,0,0,0,1,1, Added retry and retryWhen support for Single 1.x: Add vararg of Subscriptions to CompositeSubscription., nan nan,
0,0,0,0,1,1,Artem Zinnatullin :slowpoke:, 2807 3121 3144 3147 3154 3417 3418 3419 3433 3434 3458 3539 3562 3566 3579 3651 3655 3766 3789 3790 3818 3866 3880 4882 4140 4298 5706 5747 5748 5876 5936 6234 6263 6365,0,1,1,1,1,1, Corrected all Java interfaces declarations Improve performance of NewThreadWorker  disable search for setRemoveOnCancelPolicy() on Android API < 21 Remove redundant cast in Exceptions Remove unnecessary static modifier Add Observable.fromCallable() as a companion for Observable.defer() Add Single.doOnSuccess() Add Single.fromCallable() Add Single.doOnError() Add Single.defer() Add Single.finallyDo() Clarify contracts of CompositeSubscription in its javadoc Add Single.zip() for Iterable of Singles Add Single.doOnUnsubscribe() Deprecate Observable.finallyDo() and add Observable.doAfterTerminate() instead 1.x: No more need to convert Singles to Observables for Single.zip() 1.x: Remove redundant  final  modifiers 1.x: Add Single.onErrorResumeNext(Single) 1.x: Add Single.onErrorResumeNext(Func) 1.x: Prevent Single.zip() of zero Singles 1.x: Expose Single.lift() 1.x fromCallable() @Experimental -> @Beta 1.x: Add Single.toCompletable() 1.x: TestSubscriber/TestObserver print values if number of items doesn t match 2.x: Common test classes for Processors. 1.x: Change Completable.subscribe(onError  onComplete) to (onComplete  onError) 2.x: Clarify behavior of RxJavaPlugins.reset() in javadoc Remove mentions of Main thread from Schedulers.single() javadoc. 2.x: Fix TrampolineScheduler not calling RxJavaPlugins.onSchedule()  add tests for all schedulers. 2.x: Check runnable == null in *Scheduler.schedule*(). 2.x: Add note about NoSuchElementException to Single.zip(). 2.x: Fix Completable.toMaybe() @return javadoc. Add timeout and unit to TimeoutException message Inline SubscriptionHelper.isCancelled() Indicate source disposal in timeout(fallback), Just little Java syntax fix for interfaces  I checked all interfaces in RxJava.  @benjchristensen I can add and configure  Checkstyle  gradle plugin for RxJava if you don t mind  mm? Resolves #3119.  This PR adds methods for detecting Android API Version and disables  NewThreadWorker.tryEnableCancelPolicy()  on Android API < 21 which has significant performance cost on Android.  PR also improves performance of  NewThreadWorker.tryEnableCancelPolicy()  via caching Reflection. nan P.S.  @benjchristensen @akarnokd sorry for large amount of simple pull requests  I m doing full code review of RxJava sources http://artemzin.com/blog/rxjava-code-review-part-1/ and I ll create PRs and issues during this review.  I ll try to group changes by themes so it will be easy to review them. Looks like this adventure is going to be part of #3145! Yep  this is a new operator.  Motivation?  Observable.defer()  requires function that returns  Observable<T>  when usually we don t want to create  Observable<T>  manually  we just want to defer execution of some function.  Like this:      java Observable   .fromCallable(() -> someFunc())   .subscribeOn(...)   ...      Instead of this:      java Observable   .defer(() -> Observable.just(someFunc()))   .subscribeOn(...)   ...      And more important case with deferring code that throws checked exceptions:      java Observable   .fromCallable(() -> {     Value value = ...      // some code     return value    })  .subscribeOn(...)  ...      Instead of this:      java Observable   .defer(() -> {     try {       Value value = ...         // some code that throws checked exceptions       return Observable.just(value)      } catch (Exception e) {       return Observable.error(e)      }   })  .subscribeOn(...)  ...      I d use name  defer  but both methods will have same type erasure ( Func0<Observable>  and  Func0<T> )  so I had to use a different name.  Questions: 1. Useful or not? For me — deferring some function call is a common task. 2. Naming.  If the decision about this operator will be positive — I ll add javadoc to this PR and then create separate PR for  Single.fromCallable() . Closes #3385. Second part of #3154.  @akarnokd I d like to reuse  Observable.fromCallable()  but didn t find apropriate way to do it:  Observable.fromCallable().toSingle()  is not best option  if you have some thoughts on this — please share them. nan nan @akarnokd I ve found a problem with  null  action  I ll create separate issue about this soon. Current state of  CompositeSubscription  s javadoc — totally misleading :smile:   Every time we need to store some subscriptions in it then clear them and leave  CompositeSubscription  in an operable state we have to read its sources because its actual behavior is not consistent with the javadoc.   CompositeSubscription.clear()  leaves  CompositeSubscription  in operable state  when on the other hand  CompositeSubscription.unsubscribe()  sets  isUnsubscribed = true  and  CompositeSubscription  is not able to manage new subscriptions. nan As promised  adding more operators to  Single . This one is very useful for releasing resources if task can be cancelled externally via  subscription.unsubscribe()  and subscriber may not receive the result. #3434 but for  Observable . PTAL As promised in #3579. Part of #3652  will submit a PR for  onErrorResumeNext(Func1<Throwable  Single>)  later. Closes #3440  closes #3731  closes #3472 (whoa  3 issues at a time!) Closes #3784. Closes #3161. Part of #3816 Closes #3865. Otherwise you have to manually print/debug values if test failed. Caused by https://github.com/JakeWharton/RxRelay/pull/20#discussion_r89308736 Closes #3851  closes #4137. Noticed in RxAndroid https://github.com/ReactiveX/RxAndroid/pull/316#discussion_r73783555 To avoid confusion.   One could think that  single()  can be used to execute code on  Main  thread. Noticed during figuring out how #5734 works. To enforce  @NotNull  guarantee for the PR #5734  see  https://github.com/ReactiveX/RxJava/pull/5734/files#r153951238 nan Current javadoc:     java @return a {@link Maybe} that emits a single item T or an error.      But in reality  converting  Maybe  to  Completable  should never emit  item T . This is a small enhancement to help with crash/log debugging.  Right now often times you get a stacktrace that points only to RxJava:     java java.util.concurrent.TimeoutException         at io.reactivex.internal.operators.flowable.FlowableTimeoutTimed$TimeoutSubscriber.onTimeout(FlowableTimeoutTimed.java:137)         at io.reactivex.internal.operators.flowable.FlowableTimeoutTimed$TimeoutTask.run(FlowableTimeoutTimed.java:169)         at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66)         at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57)         at java.util.concurrent.FutureTask.run(FutureTask.java:266)         at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)         at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)         at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)         at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)         at java.lang.Thread.run(Thread.java:748)       Adding  timeout  and  unit  values can help find related user code faster.  I m not advocating for particular message  it can be something even shorter  like  $timeout $unit .   It can also be extracted in a method if you see value in that. Addresses https://github.com/ReactiveX/RxJava/pull/6258#discussion_r228725602 Some of the overloads of  timeout(…  fallback)  operator didn t indicate that source gets disposed on timeout in the javadoc.,
0,0,0,0,0,0,Dmitry Strekha, 5995,0,0,0,0,1,0, Implement  toString  method for some Emitters, When use  .create  method it s unclear why  emitter  is null (if call  toString  or observe object via debugger).,
0,0,1,0,1,0,Konstantin Mikheev, 3455,0,0,0,0,1,0, OnErrorFailedException fix, https://github.com/ReactiveX/RxJava/issues/2998,
0,0,0,0,0,0,Pedro Antonio Souza Viegas, 465,0,0,1,0,1,1, Moving unit tests to test source folders #439, nan,
0,0,0,0,1,0,Lugduni Desrosiers, 6746 7028,0,0,0,0,1,1, Javadoc cleanup 1203 3.x: Allow MBE in FlowableGroupByTest.issue6974RunPart2NoEvict, This PR is simply a backport of #6729 to the RxJava 2.x branch. Issue #7001 https://github.com/ReactiveX/RxJava/blob/98acac218cdb04d279b5ac49bb1afc65bc6ec4fe/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java#L2668-L2669  The above test can probabilistically throw an exception  thus:  https://github.com/ReactiveX/RxJava/blob/98acac218cdb04d279b5ac49bb1afc65bc6ec4fe/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java#L2681  The above assertion would be invalid. I have removed the invalid assertion.  Fixes #7001,
0,0,0,0,0,0,jimin, 6545 6546 6549 6550,0,0,1,1,1,1, 2.x: Remove unnecessary static imports from unit tests 2.x: Simplify JUnit tests with more appropriate assert methods 3.x: Simplify JUnit tests with more appropriate assert methods 3.x: remove unnecessary static imports from unit tests, 2.x: Remove unnecessary static imports from unit tests. Simplify unit tests by using the more appropriate JUnit assert methods. Simplify JUnit tests with more appropriate assert methods. Remove unnecessary static imports from unit tests.,
0,0,0,0,1,0,Sergio Garcia, 7160 7162,0,0,0,0,1,0, Io Scheduler  Scheduled worker release. Io Scheduler  Scheduled worker release (v2.x), IoScheduler  releases the workers back to the pool to be reused optimistically to reduce the number of threads being created. This could lead to deadlocks in some situations like this one:      Flowable.just( item )         .observeOn(Schedulers.io())         .firstOrError()         .subscribe(__ -> {             for (int i = 0  i < 200  i++) {                 Completable.complete()                         .observeOn(Schedulers.io())                         .blockingAwait()              }             System.out.println( Will never reach this )          })      As discussed on https://github.com/ReactiveX/RxJava/issues/7153  this PR allow to configure this behaviour. Enabling  rx3.io-scheduled-release  will guarantee that workers are not reused until all the processing has finished.   Once we merge this we  I can create a similar PR for the  2.x  branch This is the same change as https://github.com/ReactiveX/RxJava/pull/7160 but targeting the 2.x branch Related to issue https://github.com/ReactiveX/RxJava/issues/7153,
0,0,0,0,1,0,Viacheslav Makarov, 5952,0,0,0,0,1,0, AppendOnlyLinkedArrayList#forEachWhile is not breaking iteration properly, AppendOnlyLinkedArrayList#forEachWhile(NonThrowingPredicate)  was  break -ing from inner loop instead of  return -ing when predicate returned  true .  This caused iteration to continue with items from the next array bucket.,
0,0,0,0,0,0,Mingtao Zhang, 1311,0,0,0,0,1,0, Tiny integration test change, It s a tiny change.  I ve been following this project for a while as a hobby  also want to contribute to it.   Currently I am going through test cases to learn. Found some tiny problems as we are testing  concat   we should care not only the total number of elements  but also the sequences.  Creating this request mainly want to make sure I am writing/commiting code to the correct place.  Let me know if there is any problem.  Best Regards  Mingtao,
0,0,0,0,0,0,Brais Gabín, 5000 5048 6990,0,0,1,0,1,1, Add which are the other stardard methods of create 1.x: Improve the BehaviorSubject Java doc Add missing  @Test  annotation, I was using  Observable.create(OnSubscribe) . I knew about the warning:  > This method requires advanced knowledge about building operators and data sources  please consider other standard methods first  But I didn t know which were the *other stadard methods*. There were no clue in the JavaDoc. With this change the problem is gone. - The second example didn t explain what happened with  default . - The first line is copied from the 2.x documentation. It s more clear. There was a missing  @Test  annotation in  ReplaySubjectTest . This PR fix that.,
0,0,0,0,0,0,Samuel Tardieu, 1347,0,0,0,0,1,1, Allow use of the returned subscription to cancel periodic scheduling, The documentation for schedulePeriodically indicates that the returned subscription can be used to unsubscribe from the periodic action  or to unschedule it if it has not been scheduled yet. That was the case only before the first action took place  and it was then impossible to unsubscribe using the given subscription  although unsubscribing the worker did work.  This fixes #1344.,
0,0,0,0,0,0,Mathieu Gabriel, 4441 5494,0,0,0,0,1,1, Fix FlowableOnBackpressureBufferStrategy FlowableWithLatestFrom forgets request, Fix buffered objects not propagated downstream in FlowableOnBackpressureBufferStrategy Fix drop strategy logic in FlowableOnBackpressureBufferStrategy Add unit test for FlowableOnBackpressureBufferStrategy  copied from FlowableOnBackpressureBufferTest  there is still some work needed to have a better coverage The following scenario did not work with FlowableWithLatestFrom: Flowable<?> result = source.combineWithLatest(other  someCombiner) - client subscribe to the result stream - source stream emits - other stream emits - source stream emits  expected result: result stream emits the combined event actual result: result stream does not emit anything,
0,0,0,0,1,0,Jan Knotek, 6499,0,0,0,0,1,1, Null check for BufferExactBoundedObserver, - [*] Please give a description about what and why you are contributing  even if it s trivial:  **Improve stability of the library.** Other variants of the onComplete method include this Null check already  e.g. BufferExactUnboundedObserver  this check should fix the case when there is a race condition and buffer is already set to  null  by the time onComplete is called.  It is causing 0.1% crashes in our production app  this should improve stability of other apps too.,
0,0,1,0,1,1,Niklas Baudy, 4637 4669 4681 4685 4687 4690 4695 4699 4707 4718 4731 3549 3565 4754 4760 3762 3948 4881 4900 4924 4971 4973 4125 4226 4234 4238 6635 4282 6640 4296 4297 4299 4300 4301 4302 4304 4309 4344 4349 4394 4395 4418 5196 4460 4461 4466 5306 4479 4486 4496 5568 4500 4504 4508 4509 4518 5753 4525 4526 4527 4529 4531 4540 5906 4560 4561 5940 6010 4581 4582 4589 4590 4592 4593 4595 4597 4601 4603 4606 4607 4614 4616 4617 4632,1,1,1,1,1,1, 2.x: Remove unused methods in BasicFuseableObserver 2.x: Fix javadoc for Single.flatMapObservable 2.x: Fix Flowable + Single elementAt and elementAtOrError operators on empty sources 2.x: Test static from methods and add Maybe.fromSingle & fromCompletable 2.x: Add Observable.rangeLong & Flowable.rangeLong 2.x: BaseTestConsumer add assertValueAt(index  Predicate<T>) 2.x: CompositeException fix order of Exceptions 2.x: Clean up null usages by using ObjectHelper.requireNonNull 2.x: Fix Flowable.elementAt on empty sources. Plus sync tests 2.x: Distinct Operator - delegate null Collection down to onError 2.x: Delegate null Collections down to onError in toList Remove double whitespace in if conditions Replace never() calls in BehaviorSubjectTest with verifyNoMoreInteractions 2.x: Remove some unused fields 2.x: Add Single.fromObservable(ObservableSource) 1.x: Deprecate CompositeException constructor with message prefix Add Completable.andThen(Completable)  deprecate endWith() Add CheckReturnValue annotation 2.x: Fix typo in DisposableHelper 2.x: Change Completable to CompletableSource 2.x: Add @CheckReturnValue to create methods of Subjects + Processors 2.x: Add Completable.hide() 1.x: Test all private Constructors 1.x: Single.flatMapCompletable 1.x: Fix some typos 1.x: Fix typo eigth to eighth 3.x: Remove vararg overloads for combineLatest in Observable + Flowable 1.x: Make Observable takeUntil documentation more explicit 3.x: Rename combineLatest methods that take an array to combineLatestArray 2.x: Observable.range fix Exception message 2.x: Rename Single Base Interface Types for consistency 2.x: Rename Flowable Base Interface Types for consistency 2.x: Rename Observable Base Interface Types for consistency 2.x: Rename ObservableSource to ObservableWithUpstream 2.x: Rename Completable Base Interface Types for consistency 2.x: Add missing license headers 2.x: Remove unused exceptions in public API 2.x: Fix some typos in Flowable + Observer documentation 2.x: Observable + Flowable fix some typos 2.x: Single.test cancel TestSubscriber when wanted 2.x: Completable.test cancel TestSubscriber when wanted 1.x: Sync doOnEach java doc 2.x: Add a few more @Nullable & @NonNull annotations to public interfaces 1.x: Completable add doOnEach 1.x: Single add doOnEach 1.x: Deprecate Notification.createOnCompleted 2.x: Change ObservableSource.defer to Observable.defer in Observable.scan() documentation. 2.x: Add doOnEvent to Single & Completable 2.x: Completable enhance doOnEvent to reduce allocations 2.x: Remove trailing whitespace 2.x: Add assertValuesOnly to BaseTestConsumer. 1.x: Remove trailing whitespace 2.x: Add Disposable Observer for Maybe  Completable & Single 2.x: Add exception message in SingleFromCallable 2.x: Adjust some JavaDoc in Emitters 2.x: Add missing Resource Observer for Maybe  Completable & Single and adjust some Javadoc 2.x: Add retry(times  predicate) to Single & Completable and verify behavior across them and Maybe. 2.x: Fix Generics T[] in Zip & CombineLatest 2.x: More usage of ObjectHelper 2.x: Remove unused declarations 2.x: Fix MaybeTimber by using scheduler and unit 2.x: PublishSubject enhance NPE when onNext(null) is called 2.x: Add Create test with CancelAble for all types and add more MaybeCreateTest cases 2.x: Add public constructor for TestScheduler that takes the time. 2.x: Fix typo in Single + Maybe defer() 2.x: Enhance NPE message in Create functions of all Base Reactive Types 2.x: Allow @SchedulerSupport on constructors. 2.x: Add assertValueSetOnly and assertValueSequenceOnly to TestObserver + TestSubscriber 2.x: Remove some dead code 2.x: Add missing Maybe tests for concatWith & onErrorResumeNext 2.x: Add singleOrError  firstOrError  lastOrError & elementAtOrError to Observable and Flowable 2.x: Report errors from onError to Plugin when done 2.x: UnicastSubject fix onTerminate 2.x: Enhance NPE messages 2.x: Remove takeFirst(predicate) in Observable & Flowable 2.x: Add missing @Test annotation on tests 2.x: Sync behaviour between UnicastProcessor & UnicastSubject + add a few test cases 2.x: RxJavaPlugins - Don t pass null throwable down to Error Handler 2.x: Verify same onNext / onError null behavior across all Subjects and Processors 2.x: TestSubscriber & TestObserver add assertValue(Predicate) 2.x: Add Maybe.flatMapSingle 2.x: Add Completable.andThen(MaybeSource) 2.x: Add Single.flatMapMaybe 2.x: Clean up SingleFlatMap, nan - wrong return type was described - some git merging information was added This will fix #4680 - elementAtOrError(1) on an empty source just leaves the new Single hanging without signalling onError() - elementAt(1) on an empty source just leaves the Maybe hanging without signalling onComplete() - I also noticed that elementAt() with a default value on an empty source did not work either. - add Maybe.fromSingle by reusing MaybeFromSingle - add Maybe.fromCompletable by resuing MaybeFromCompletable - remove anonymous classes in various operators - add tests for   - Completable.fromAction()   - Completable.fromCallable()   - Completable.fromObservable()   - Completable.fromPublisher()   - Completable.fromRunnable()   - Completable.fromSingle()   - Maybe.fromAction()   - Maybe.fromCallable()   - Maybe.fromCompletable()   - Maybe.fromRunnable()   - Maybe.fromSingle()   - Single.fromCallable() Will fix #4683 - adds Observable.rangeLong() - adds Flowable.rangeLong()  both implementations are copied same for the unit tests.  What should we do about the range overflow check? We could use BigDecimal to check that. Fixes #4688 - adds assertValueAt(index  Predicate) to BaseTestConsumer After looking at #4692 I found a few more exceptions which were passed in the wrong order to CompositeException. Instead of using an if statement to check for  null    ObjectHelper.requireNonNull  will be used now. This reduces a lot of duplicated code. Also I found a few places (mostly zip operators) where the wrong Throwable was being onError d.  In addition for one of the Completable operators the CompositeException call has been fixed. In addition I found another one that was wrong. - fixes Flowable.elementAt on an empty source  - sync tests between Observable & Flowable elementAt - returning null as a Collection in the callable didn t go to onError - adopted flowable & observable - if null from a collection supplier is returned delegate to onError - adapted Flowable & Observable - unified exception message Just found them while walking through the source code trying to get a better overview of the Rx internals. Advantage is that we verify that there s no interaction at all so also something that we might not expect is not going to happen. Remove some unused fields that are either - present in their parent class - not set - adds an overload to create a Single from an ObservableSource Before this PR messagePrefix was never used :dancer:   If you guys want I can revert the change on CompositeExceptionTest.java:177. I just thought that way it  be nicer.  About the message is there any reason for having a space after the dot? See #3947 First draft on this.  So far I have only annotated  subscribeWith()  and  test()  methods.  I checked this against Error Prone and their [check](http://errorprone.info/bugpattern/CheckReturnValue) is able of picking up the RxJava annotation.  How do you feel if I extend  BaseTypeAnnotations  to test for  @CheckReturnValue  too?  Related #4878 Fixed a typo in DisposableHelper.  curren  ->  current Changing  Completable  to  CompletableSource . Also found one other wrong spot that I fixed within this PR.  Fixes #4923 - adds the @CheckReturnValue annotation to subjects + processors since Single/Completable and MaybeSubject got them recently too - adds Completable.hide() operator so that CompletableSubject as well as other custom Completable implementations can be hidden nan Addresses #4216   Happy to receive feedback on the implementation. Also should I take the documentation from  flatMapObservable  and adjust it? nan Found another one Started removing the vararg function from #6634 nan Renames the methods as suggested nan Addresses #4044 Addresses #4044 Addresses #4044. To unblock #4300 Addresses #4044 Now every file has a license header. As wanted in #4306 nan nan nan nan The other  doOnEach  function has the right java doc. Terminal events such as  onCompleted  /  onError  are also included in  doOnEach . - adds the @Nullable & @NonNull annotations to   - Emitters   - Observer   - OnSubscribe   - Operator   - Source   - Transformer  for Observable  Maybe  Single  Completable & Flowable. First part of #4457   Is it okay that I reused Notification like that?  Also are there any Java 6 Generics missing? It would be nice if this project was set up to target Java SDK 6  as my default seems to be Java 8 and I don t get any errors shown in the IDE. Really not that happy with  onNotification.call(Notification.<T>createOnNext(t))   do you guys have any other way of doing this? There s no way of creating a Notification that has the  onCompleted  plus a value. A new one could be introduced there though. Also the  doOnEachSuccess  test feels clunky.  Also why does Single when using the  do  methods does the job by using an Observable? And later converting it back to a Single again. Is it due to the way Single was implemented in 1.x? With Completable there is no converting of back and forth needed.  Javadoc will follow once we sorted out the few nits here.  Fixes #4457 Fix #4462   It might just as well shine some light into which method should be used and explain why there are 2 - changes  ObservableSource.defer  to  Observable.defer() nan nan Removed them like this:   find . -type f -name  *.java  | xargs sed -i    -e s/[ \t]*$//   $1    I think it s best to review this locally or by appending  ?w=1  to this URL to let GitHub ignore white space changes. Adds  assertValuesOnly  that asserts that the TestObserver/TestSubscriber received only the specified values in the specified order without terminating.  Fixes #5555 Dunno whether this is wanted or not in 1.x. If not just close this PR. Also any reason the Dispoable is called  s ? Is it still from the Subscription time?  Fixes #4501 nan nan Fixes #4517 - Add retry(times  predicate) to Single & Completable (Maybe had it already) which just forwards to Flowable for now - verify behavior across the three reactive types  Happy to get better testing names Fixes #4524  Test for combineLatest fill follow nan nan Also one question why does  CompletableTimer  check  if (!sd.isDisposed()) {  before replacing but SingleTimer does not? I adjusted MaybeTimber to SingleTimer so I didn t add the check there either.  However I feel like this should be consistent  can you elaborate which one is wanted? nan setCancellable  was not tested before. - adds a time constructor to TestScheduler - should I make it experimental or will it just be stable?  Fixes #5901 nan nan Motivation behind this is having a class which takes multiple constructor parameters where one can be a Scheduler with a default and a custom overload. In both cases I d want to slam  @SchedulerSupport  on it so it can be handled properly by static analysis as well. This basically copies the behavior of  assertValuesOnly  to the  assertValueSet  and  assertValueSequence  equivalent methods.  Coped the tests exactly from  assertValuesOnly  and adjusted them with the new added methods. Also what about IntFunction it s right now in the public API however not used. So the question is does Rx want to expose that interface? They had no tests previously Closes #4588 For the first one that I found I even wrote a test. Then I started noticing more missing spots. If wanted I could port that one test to every operator that I touched. Though I didn t really find tests testing that errors are propagated through the Plugin API. nan Now all NPE thrown internally are having this standard message nan nan nan nan nan nan Gave that implementation a try. Feedback is welcome I think there are improvements that can be done. nan nan nan,
0,0,0,0,0,0,Marko Tiidla, 5258,0,0,0,0,1,1, 1.x Use IntelliJ IDE friendly assertion failure message, The  assertItem  failure message pattern in  TestSubscriber  does not match any of the regex patterns defined by IntelliJ to show  <Click to see difference>  link.  ![before](https://cloud.githubusercontent.com/assets/2339109/24586365/9239290c-179f-11e7-8178-38425448d3a1.jpg)  By changing the  _expected to be_  to  _expected:_   the pattern is recognised by IntelliJ and the helpful link is presented. ![after](https://cloud.githubusercontent.com/assets/2339109/24586364/9238f414-179f-11e7-9b12-e6b648318550.jpg)  The original idea from #5249 was to use the  _expected:<> but was:<>_  pattern used in JUnit  but it is not picked up on its own by IntelliJ. The AssertionError must extend from JUnit s ComparisonFailure  to get it recognised. This however requires dependency on JUnit. ![junit](https://cloud.githubusercontent.com/assets/2339109/24586389/fefd6c38-179f-11e7-8841-884bc07db404.jpg)  So in the end  the fix is just a very simple change in the message.,
0,0,0,0,0,0,Tomasz Rozbicki, 1431,0,0,0,0,1,0, CompositeException fix for Android, Fixes #1405 - revert changes from f4ae92aa - remove duplicated causes in stack trace chain,
0,0,0,0,0,0,Matt Laux, 5437,0,0,0,0,1,1, 1.x: TestSubscriber::assertValuesAndClear should reset valueCount, During the time between calling  assertValuesAndClear  and providing the next  onNext  event  the  valueCount  is inconsistent with the size of the internal  values  list.,
0,0,0,0,1,0,Jason Neufeld, 2447 2471 6099,1,0,1,1,1,1, Fail early if a null subscription is added to a CompositeSubscription. Fixes NPEs reported in ReactiveX#1702 by synchronizing queue. Update TestHelper.java: trivial typo fix, Otherwise  it ll just fail late when unsubscribing  which is much harder to trace.  I discovered this while writing  a unit test  when I didn t properly mock out a method to return a valid Observable. Seems like it would be more likely to happen in test code than production  but still could be a stumbling block that s hard to track down if there s a bug in app logic adding a null subscription. Also adds a unit test for regression.  It appears there is a potential race condition if something adds to/removes from the PQ while it s _inside_ the  poll  operation  which is where the exceptions in #1702 seem to have actually come from. Therefore  the initial null check didn t really address the original problem. The test here seems to reliably recreate those conditions.  I considered using a PriorityBlockingQueue instead of synchronized  but since the isEmpty and poll calls should not allow something to interleave between them and access the queue  a synchronized block seemed wiser here. Thank you for contributing to RxJava. Before pressing the  Create Pull Request  button  please consider the following points:    - [x] Please give a description about what and why you are contributing  even if it s trivial. Just a small typo fix. I grepped for the same misspelling and it only appeared in this file.    - [x] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those. N/A    - [x] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator  (if applicable) please make sure you have tests for working with an  empty    just    range  of values as well as an  error  source  with and/or without backpressure and see if unsubscription/cancellation propagates correctly. N/A,
0,0,0,0,0,0,Hans, 6036,0,0,0,0,1,0, 2.X: Fix disposed LambdaObserver onError to route to global error handler, Fix the behaviour of LambdaObserver when disposed to route to the global error handler  Fixes #6025,
0,0,0,0,0,0,Harshit Bangar, 5890,0,0,1,0,0,0, Added nullable annotations to subjects, Adding nullable annotations to subjects. The  throwable  and  getValue  methods are annotated with Nullable.  Quick question about styling - In some places  javadocs has trailing whitespaces but it is absent in other places. Is there a styling policy around that? Intellij is removing the trailed whitespace automatically.,
0,0,0,0,0,0,Zach Klippenstein, 3701,0,0,0,0,1,1, 1.x: Add Completable.doOnCompleted and deprecate Completable.doOnComplete, Closes #3700.,
0,0,0,0,0,0,Simon Baslé, 1802,0,0,1,0,1,1, add hasObservers method to Subjects (#1772), as per https://github.com/ReactiveX/RxJava/issues/1772  SerializedSubject now keeps track of the actual Subject. BufferUntilSubscriber synchronizes on the state guard.,
0,0,0,0,0,0,IKEDA Sho, 4989 4502,0,0,1,0,1,0, 2.x: Fix Observable.singleElement doc 2.x: Replace  finallyDo  references with  doAfterTerminate, Fixes a subtle documentation bug.  Observable.singleElement  returns  Maybe<T>   not  Observable<T> . This should be less confusing.,
0,0,0,0,0,0,Igor Levaja, 5600 5637,0,0,1,0,0,0, Updating JavaDoc with correct return types 2.x: Fixing JavaDoc warnings, A small PR with updated JavaDoc  mentioned in the issue #5595 (thanks to @RobLewis for reporting it).  Updated documentation about return types  where  Observable  was incorrectly mentioned instead of  Single . Minor fixes for warnings reported by  javadoc  tool  mentioned in #5634,
0,0,0,0,1,0,Roman Wuattier, 6377 6458 6589 6594 6595 6600 6604 6607 5948 6026,0,1,1,1,1,1, Expand  Observable#debounce  and  Flowable#debounce  javadoc Update the Javadoc of the  retry  operator Create a base test class and have all unit tests extend it Have unit tests extends  RxJavaTest  - 2 Have unit tests extends  RxJavaTest  - 3 3.x: Have  internal.operator.flowable  unit tests extends  RxJavaTest  - 4 3.x: Have unit tests extends  RxJavaTest  - 5 3.x: Have  internal.operator.observable  unit tests extends  RxJavaTest  - 6 Fix Observable javadoc (#5944) Fix Flowable.blockingSubscribe is unbounded and can lead to OOME, Mention that if the processing of a task takes too long and a newer item arrives then the previous task will get disposed interrupting a long running work.  Fixes: #6288 Specify that the  times  function parameter describes  the number of times to resubscribe if the current Observable fails .  Solves: #6402 This commit creates the  RxJavaTest  class defining a default timeout to 5 minutes. An ignored test announce itself for each running class extending it preventing Travis CI from killing the build.  Have  Completable  tests extend from  RxJavaTest . Have  Disposable  tests extend from  RxJavaTest . Have  Exception  tests extend from  RxJavaTest   Related: #6583 This commit updates the unit tests of the following operators: * flowable * maybe * observable * disposable * observer * parallel * processors * schedulers and RxJava plugin.  Related: #6583 This commit updates the unit tests of the following operators: * single * subjects * subscribers And for internal operators: * internal.disposable * internal.fuctions * internal.observers * internal.queue * interanl.schedulers * internal.subscribers * internal.subscriptions * internal.operator.completable  Related: #6583 This commit updates the unit tests for  internal.operator.flowable   Related: #6583 This commit updates the unit tests of the following operators: * internal.operators.maybe * internal.operator.mixed * internal.operator.single  Related: #6583 This commit updates the unit tests for  internal.operator.observable   Related: #6583 * Replace  doOnCancel  by  doOnDispose  in Observable javadoc  Thank you for contributing to RxJava. Before pressing the  Create Pull Request  button  please consider the following points:    - [x] Please give a description about what and why you are contributing  even if it s trivial.  Replace  doOnCancel  by  doOnDispose  in Observable javadoc    - [x] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.  #5944    - [x] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator  (if applicable) please make sure you have tests for working with an  empty    just    range  of values as well as an  error  source  with and/or without backpressure and see if unsubscription/cancellation propagates correctly.  Javadoc only Create and bound new  blockingSubscribe  overloads to  bufferSize . * Create new overloads with  bufferSize  * Create a  boundedConsumer  * Create a  BoundedSubsciber   Close: #5988,
0,0,0,0,0,0,David Gross, 279 280 285 527 531 555 569 597 607 617 639 669 691 700 705 755 762 765 786 791 829 2966 3019 3069 3077 4749 4752,0,0,1,0,0,0, Adding marble diagrams Diagrams and some new javadoc content for Observable subclasses Several new or more-precise marble diagrams Docs visually distinguish operators that use schedulers  etc. skipUntil() marble diagram and wiki link in javadoc javadoc improvements (groupJoin  groupByUntil  timestamp w/scheduler) Javadoc updates (longCount  sample(sampler)) Javadoc improvements: replay() and timer() javadocs: diagrams & wiki links Moved the descriptions of some operators to a new wiki page. Javadoc improvements: javadoc improvements: various javadoc improvements adjust javadocs for new sumFoo()/averageFoo() method names Add marble diagrams to new operators & variants. adding javadoc marble diagram for the mergeMap(next completed error) variety A variety of improvements to the javadoc text. Careful With That Global Search And Replace  Eugene. improve switchOnNext description in javadocs adding marble diagrams  see-also links to javadocs of new repeat() variants The usual anally-retentive javadoc edits. Javadoc improvements for new Single class Improve toSingle() javadoc (diagram  see also  since-annotation) Add  since  annotations to javadocs for new Experimental/Beta methods New 2.x marble diagrams Add more new marble diagrams & update old ones, several new marble diagrams for previously undiagrammed methods Some marble or marblish diagrams and a bit of new documentation for the BlockingObservable and ConnectableObservable subclasses. Add several new or more-specific marble diagrams  correct two bad image links  correct some typos Javadoc improvements  including diagrams & wiki links for new operators. visually distinguish operators that use schedulers  add distinct doOnEach diagrams nan adding marble diagrams and links to the RxJava wiki  standardizing javadoc comment formatting nan - consistent nomenclature - consistent/standard javadoc formatting - more-precise descriptions - timer() marble digram & wiki link - delay() marble diagram & wiki link nan Conditional and Boolean Operators  adjusting the javadoc links accordingly - diagrams for switchCase  doWhile  whileDo  ifThen  delaySubscription  single  singleOrDefault  takeFirst  takeLast (and variant forms of these) - standardizing javadoc comment formatting - standardizing nomenclature - diagrams for switchLatest  mergeMap  concatMap  switchMap  mapWithIndex  doOnNext - change text to note deprecation of aggregate - standardized formatting - force image size in ReplaySubject javadoc - diagrams for skip(t)  single()  take(t)  skipLast(t) - adding diagrams  improving javadocs for sumFoo/averageFoo operators - adding diagram to repeat() nan Add javadoc  @deprecated use...  where appropriate. Some javadoc comment reformatting (e.g. overlong lines). nan nan restoring the working URLs of RxJava wiki pages and marble diagrams in the javadocs http://www.youtube.com/watch?v=AYMyxTFwuz8 also: repair anchors in links to RxJava wiki in javadocs nan nan nan nan nan Adds some new marble diagrams and adjusts some for operators that now return Single/Maybe/Completable where they used to return Observable in 1.x. nan,
0,0,0,0,1,0,George Campbell, 108 109 290 790 836 854 860 970 1397 1456 1602 1777 2975 3081 3415 4826 4827 4828 4154 4436,0,1,1,1,1,1, Adding a draft of Subject class Creating toObservable for Future Issue 103 Convert to scan to use lift Setting up the new subproject for debugging observable chains. The onCreate hook disappeared Fixing the generics for merge and lift Notifications for the allocation averse. Adding the hooks unsafeSubscribe Removing onSetProducer from the API Make retryWhen the same with the Scheduler as the retryWhen without the Scheduler Excluding things from the javadoc Deprecate and rename two timer overloads to interval Revert of cache/replay Deprecate the Experimental/Beta method that will be deleted until 1.1.x Schedule when bug fix Porting the Scheduler.when operator from 1.x to 2.x changing inner classes to package-private. Ability to create custom schedulers with behavior based on composing operators. 2.x: Maybe for lazy Optional, https://github.com/Netflix/RxJava/issues/19 simple wrapper that turns a future into a observable. Adding the zip operator that works on collection of Observables and a FuncN.  https://github.com/Netflix/RxJava/issues/103 I switched the scan to an operator and cleaned up what looked like a lot of unnecessary code from the summing operations. By creating and registering this plugin you get a complete log of all the events (subscribe  onNext  onError  onCompleted and unsubscribe) that happen in all observables  observers and subscribers. The debug hook also takes a Func1 for transforming data before they are sent to actual onNext functions.  This pull request is for the raw data.  There isn t any persistence or visualization of the data generated yet.  Here is an example of a simple observable chain      from(1  3).flatMap({ it -> from(it  it + 1) }).take(3).subscribe()      And the stream of notifications sent.      {  nano : 1391761208271225000   thread : 1   observer :  rx.Observable$27@3290a11e    type :  Subscribe    source :  rx.Observable$2@3541d281 } {  nano : 1391761208272832000   thread : 1   observer :  rx.operators.OperatorTake$1@f81c4a1    type :  Subscribe    source :  rx.Observable$2@10942dfb    to :  rx.operators.OperatorTake@7056c23d } {  nano : 1391761208275469000   thread : 1   observer :  rx.operators.OperatorMerge$1@49c5146e    type :  Subscribe    source :  rx.Observable$2@29c06798    to :  rx.operators.OperatorMerge@16d14192 } {  nano : 1391761208275644000   thread : 1   observer :  rx.operators.OperatorMap$1@427e3f2    type :  Subscribe    source :  rx.operators.OperatorFromIterable@56e626ff    to :  rx.operators.OperatorMap@200a5beb } {  nano : 1391761208276707000   thread : 1   observer :  rx.operators.OperatorMap$1@427e3f2    type :  OnNext    value :  1    to :  rx.operators.OperatorMap@200a5beb } {  nano : 1391761208276839000   thread : 1   observer :  rx.operators.OperatorMerge$1@49c5146e    type :  OnNext    value :  rx.Observable@299b78d4    from :  rx.operators.OperatorMap@200a5beb    to :  rx.operators.OperatorMerge@16d14192 } {  nano : 1391761208277012000   thread : 1   observer :  rx.operators.OperatorMerge$1$InnerObserver@2b6dd9c5    type :  Subscribe    source :  rx.operators.OperatorFromIterable@38f42ac9 } {  nano : 1391761208277075000   thread : 1   observer :  rx.operators.OperatorMerge$1$InnerObserver@2b6dd9c5    type :  OnNext    value :  1 } {  nano : 1391761208277166000   thread : 1   observer :  rx.operators.OperatorTake$1@f81c4a1    type :  OnNext    value :  1    from :  rx.operators.OperatorMerge@16d14192    to :  rx.operators.OperatorTake@7056c23d } {  nano : 1391761208277243000   thread : 1   observer :  rx.Observable$27@3290a11e    type :  OnNext    value :  1    from :  rx.operators.OperatorTake@7056c23d } {  nano : 1391761208277338000   thread : 1   observer :  rx.operators.OperatorMerge$1$InnerObserver@2b6dd9c5    type :  OnNext    value :  2 } {  nano : 1391761208277397000   thread : 1   observer :  rx.operators.OperatorTake$1@f81c4a1    type :  OnNext    value :  2    from :  rx.operators.OperatorMerge@16d14192    to :  rx.operators.OperatorTake@7056c23d } {  nano : 1391761208277471000   thread : 1   observer :  rx.Observable$27@3290a11e    type :  OnNext    value :  2    from :  rx.operators.OperatorTake@7056c23d } {  nano : 1391761208277557000   thread : 1   observer :  rx.operators.OperatorMerge$1$InnerObserver@2b6dd9c5    type :  OnCompleted } {  nano : 1391761208279076000   thread : 1   observer :  rx.operators.OperatorMap$1@427e3f2    type :  OnNext    value :  3    to :  rx.operators.OperatorMap@200a5beb } {  nano : 1391761208279154000   thread : 1   observer :  rx.operators.OperatorMerge$1@49c5146e    type :  OnNext    value :  rx.Observable@24d8116d    from :  rx.operators.OperatorMap@200a5beb    to :  rx.operators.OperatorMerge@16d14192 } {  nano : 1391761208279252000   thread : 1   observer :  rx.operators.OperatorMerge$1$InnerObserver@65601e00    type :  Subscribe    source :  rx.operators.OperatorFromIterable@951c5ff } {  nano : 1391761208279322000   thread : 1   observer :  rx.operators.OperatorMerge$1$InnerObserver@65601e00    type :  OnNext    value :  3 } {  nano : 1391761208279409000   thread : 1   observer :  rx.operators.OperatorTake$1@f81c4a1    type :  OnNext    value :  3    from :  rx.operators.OperatorMerge@16d14192    to :  rx.operators.OperatorTake@7056c23d } {  nano : 1391761208279483000   thread : 1   observer :  rx.Observable$27@3290a11e    type :  OnNext    value :  3    from :  rx.operators.OperatorTake@7056c23d } {  nano : 1391761208279562000   thread : 1   observer :  rx.Observable$27@3290a11e    type :  OnCompleted    from :  rx.operators.OperatorTake@7056c23d } {  nano : 1391761208279692000   thread : 1   observer :  rx.Observable$27@3290a11e    type :  Unsubscribe    from :  rx.operators.OperatorTake@7056c23d } {  nano : 1391761208279756000   thread : 1   observer :  rx.operators.OperatorTake$1@f81c4a1    type :  Unsubscribe    from :  rx.operators.OperatorMerge@16d14192    to :  rx.operators.OperatorTake@7056c23d } {  nano : 1391761208279830000   thread : 1   observer :  rx.operators.OperatorMerge$1@49c5146e    type :  Unsubscribe    from :  rx.operators.OperatorMap@200a5beb    to :  rx.operators.OperatorMerge@16d14192 } {  nano : 1391761208279880000   thread : 1   observer :  rx.operators.OperatorMap$1@427e3f2    type :  Unsubscribe    to :  rx.operators.OperatorMap@200a5beb } {  nano : 1391761208279946000   thread : 1   observer :  rx.operators.OperatorMerge$1$InnerObserver@2b6dd9c5    type :  Unsubscribe } {  nano : 1391761208280018000   thread : 1   observer :  rx.operators.OperatorMerge$1$InnerObserver@65601e00    type :  Unsubscribe } {  nano : 1391761208280085000   thread : 1   observer :  rx.operators.OperatorMap$1@427e3f2    type :  OnCompleted    to :  rx.operators.OperatorMap@200a5beb } {  nano : 1391761208280150000   thread : 1   observer :  rx.operators.OperatorMerge$1@49c5146e    type :  OnCompleted    from :  rx.operators.OperatorMap@200a5beb    to :  rx.operators.OperatorMerge@16d14192 } I think in the merging this hook disappeared from the original pull request for the debug hooks. I ve tracked down to two problems #858   The first is that lift wasn t quite right. I changed the lift argument from  Operator<R  T>  to  Operator<? extends R  ? super T> .  Unfortunately Java won t let us hide that away in the  Operator  class so we have to redeclare that everywhere in the debug hooks but it s still better than the alternative of having to use the full  Func1<? extends Subscriber<? super R>  ? super Subscriber<? super T>>  everywhere.  The second problem was in the return type of merge  Observable<T> .  Because of operators like  merge(Observable<? extends T> t1  Observable<? extends T> t2)  the only thing that can be said for the return type is that it is also  Observable<? extends T>  but at the moment it is returning  Observable<T> .  This pull request changes all of them and leads to some silly return values like      Observable<String> a  b  Observable<? extends String> x = merge(a  b) I ve seen and used the sentinel pattern in a couple of places in the implementation of operators.  I figured I d formalize the hacks into one place where bugs can coalesce.  As a bonus the code that uses it looks a bit cleaner now. by making the execution and error handling exactly same as safe version without the safety checks. nan came up in #1580 For one of the sub issues in #1502.  exclude rx.internal. exclude RxJavaErrorHandlerDefault by deleting it. The existing six methods below didn t make sense and caused some confusion.      timer(delay  timeUnit[  scheduler])   --> emits 0 after delay and completes timer(delay  period  timeUnit[  scheduler])  --> emits 0 after delay and then i++ after every period forever interval(period  timeUnit[  schduler)  --> emits i++ after every period forever      I felt that the middle method acted more like the third method  interval  than first method  timer .  This PR is to make this change.       timer(delay  timeUnit[  scheduler])   --> emits 0 after delay and completes +@Deprecated  timer(delay  period  timeUnit[  scheduler])  --> emits 0 after delay and then i++ after every period forever +interval(delay  period  timeUnit[  scheduler])  --> emits 0 after delay and then i++ after every period forever  interval(period  timeUnit[  schduler)  --> emits i++ after every period forever      PS: yes  I understand that we can t delete the deprecated timer method. @davgross and if this PR is merged will have to change the images. #3076. I did revert commit of the PR that added back pressure support to the cache operator and ran a canary.  Our production systems seem stable now even with the new merge. Squashed commits: [c6e43fc] 1.0.15. Beta/Deprecation of Subject state peeking methods.  This should give users one release to prepare for the class structure changes. In using this in production we found a bug where some actions were dropped.  I ve tracked it down to the premature onCompleted and unsubscription of the completable that represents the scheduled action causes the future to get canceled before it is started.  The fix was to delay the onCompleted until the action was truly done.  I did the PR as two commits because the first one is changing all the tabs to spaces! Look at the second commit for the actual functional difference. In fixing the Scheduler.when in 1.x I noticed that it hadn t been ported to 2.x. This PR tries to fix that translating Observable to Flowable and Subscription to Disposable. This also includes the fix from 1.x to fix issue in #4826 based on #4115  Allows the use of operators for controlling the timing around when actions scheduled on workers are actually done. This makes it possible to layer additional behavior on an existing  Scheduler . The main parameter is a function that flattens an  Observable<Completable>  into just one  Completable . There must be a chain of operators connecting the returned value to the source Observable otherwise any work scheduled on the Scheduler will not be executed.  When  scheduler.createWorker()  is invoked a  Completable  is onNext d to the combinator to be flattened. If the  Completable  is not immediately subscribed to an calls to  worker.schedule(...)  are buffered. Once the  Completable  is subscribed to actions are then scheduled on the actual Scheduler. When the  Worker  is unsubscribed the  Completable  emits an onComplete and triggers any behavior in the flattening operator. The  Observable<Completable>  and all  Completable s give to the flattening function never onError.  Slowing down the rate to no more than than 1 a second.      java  Scheduler slowSched = new ScheduleWhen(workers -> {     // use concatenate to make each worker happen one at a time.     return Completable.concat(workers.map(worker -> {         // delay the starting of the next worker by 1 second.         return worker.delay(1  TimeUnit.SECONDS)      }))   }  Schedulers.computation())       Limit the amount concurrency two at a time without creating a new fix size thread pool:      java  Scheduler limitSched = new ScheduleWhen(workers -> {     // use merge max concurrent to two at a time     return Completable.merge(workers  2)   }  Schedulers.computation()) In #4321 I hit on the problem of needing a lazy object that could either be zero or one value. In that issue the idea of switching the return value of  reduce(R  Func2<R T R>)  from  Observable<R>  to  Single<R>  because that operator can only ever produce an Observable that emits exactly one value. The problem was that  reduce(Func2<T T T>)  could not be changed to  Single<T>  because the source Observable could be empty and therefore not produce one and only one value.  To solve this problem I mentioned we could create a lazy type that represents either 1 or no value could fill the gap between  Completable  and  Single<T> .  This PR is for the introduction of the  Maybe<T>  type.,
0,0,0,0,0,0,Eric Denman, 1705 1761,0,0,0,0,1,0, Issue #1642 Fix null-emitting combineLatest Issue #1642 Fix null-emitting combineLatest, @benjchristensen Same as https://github.com/ReactiveX/RxJava/pull/1705 but for the 0.20.\* folks,
0,0,0,0,0,0,Guillermo Calvo, 6380,0,0,0,0,1,0, Fix bug in CompositeException.getRootCause, I found what I believe is a bug in  CompositeException.getRootCause .  The [original code](https://github.com/ReactiveX/RxJava/commit/487a0ba52137e13d996ad12fc73bfeabb03c4fb7#diff-63dcdf1ecfc9f44d938e86154f465e41R306) use to be  if (root == null || root == e)   but apparently after some refactoring it ended up as  if (root == null || cause == root) .  As a side note  I think this method should be made  static  (that would have prevented the bug).  <!-- Thank you for contributing to RxJava. Before pressing the  Create Pull Request  button  please consider the following points:    - [ ] Please give a description about what and why you are contributing  even if it s trivial.    - [ ] Please include the issue list number(s) or other PR numbers in the description if you are contributing in response to those.    - [ ] Please include a reasonable set of unit tests if you contribute new code or change an existing one. If you contribute an operator  (if applicable) please make sure you have tests for working with an  empty    just    range  of values as well as an  error  source  with and/or without backpressure and see if unsubscription/cancellation propagates correctly. -->,
0,0,0,0,0,0,Nicklas Ansman Giertz, 5447 5449,0,1,0,0,0,0, Remove @NonNull annotation in Consumer method parameter Remove the @NonNull annotation from Function, This fixes #5442 As per per the discussion in #5447,
0,0,0,0,0,0,John Carlson, 4907 4908,0,1,0,0,0,0, Use t instead of value to allow for IDE naming Use t instead of value to allow for IDE naming 1.x, Naming the value  t  instead of  value  allows the IntelliJ to intelligently name the variable based on the type when autocompleting.    Before:     Single.just(new Dog()).subscribe(new SingleObserver<String>() {             @Override             public void onSubscribe(Disposable d) {                              }              @Override             public void onSuccess(Dog value) {              }              @Override             public void onError(Throwable e) {              }         })      After:     Single.just(new Dog()).subscribe(new SingleObserver<String>() {             @Override             public void onSubscribe(Disposable d) {              }              @Override             public void onSuccess(Dog dog) {              }              @Override             public void onError(Throwable e) {              }         }) Same as https://github.com/ReactiveX/RxJava/pull/4907 but for 1.x. Most places already named the variable  t   there were just a few missing.,
0,0,0,0,0,0,Aubrey Tull, 1423 3082 3118 3386 3423 3550 3567 3568 3570 3738 3780,0,1,1,0,1,1, Changed producer interface to work with long instead of int Observable.x(ConversionFunc) to allow extensions to Observables Implementing the SyncOnSubscribe 1.1.0 - Changed javadoc for Observable.doOnRequest(Action1) Renaming Observable#x to Observable#extend Public API changes for 1.1.0 release Implemented Observable#toCompletable Renamed Completable#finallyDo to #doAfterTerminate Implemented Completable#andThen(Observable) Creating Observable#create overloads for SyncOnSubscribe and AsyncOnSubscribe Upgrading SyncOnSubscribe from experimental to beta, Changing  int  to  long  in  Producer  implementations. nan This is useful for creating an observable that reads from a data source in a synchronous manner. This is a rewrite of the  AbstractOnSubscribe  experimental class based on the ideas in #3003. This is one of the many 1.1.0 promotion related pull requests. There is a split decision on the operator  Observable.doOnRequest(Action1) . A majority of core committers have voted to promote this operator from  @Beta  to public. There is currently a minority is support for removing the convenience method on  Observable  or demoting it to  @Experimental . Instead users would lift the underlying operator  obs.lift(new OperatorDoOnRequest<T>(onRequest)) . In this pull request I have taken the more conservative approach and expect that comments will guide our decisions.  ### Rationale: - the  doOnRequest  use case is to debug back-pressure use cases and as such should not pollute the public operator namespace.  - the existence of this operator may mislead and confuse users. it could be misinterpreted and abused to alter or reset over arching state when the back-pressure mechanics should be more or less self contained (with the exception of  AsyncOnSubscribe ).  If my understanding is incorrect and there is a valid use case aside from debugging then please comment. nan nan nan Renames as part of #3434 for the recently added Completable. I expect some discussion around the method name. This is to facilitate the discovery of methods for creating observables that respect back pressure semantics. Currently the  Observable#create(OnSubscribe)  static method is the easiest method to discover for creating an observable which does not provide clear facilities for managing back pressure. nan,
0,0,0,0,0,0,Víctor Julián García Granado, 6903 6960,0,0,0,0,1,1, 3.x: Add  Error handling  section to Observable.blockingFirst JavaDocs 2.x: Fix Observable.flatMap with maxConcurrency hangs (#6947), Add missing JavaDocs section.  Resolves #6900 Just a backport to 2.x of the fix for the scalar-queue max-concurrency issue already fixed for 3.x in #6946  The code for the fix has been added and also the test for it.  In addition  as was also done for #6946  the corresponding test for  FlowableFlatMap  has been added.  Resolves #6947,
0,0,1,0,0,0,Tony Cosentini, 5023,0,1,1,0,0,0, Add nullability annotations to io.reactivex.annotations interfaces., (Addresses https://github.com/ReactiveX/RxJava/issues/4876)  This pull request annotates everything in the  io.reactivex.annotations  package with a new  @NonNull  annotation defined in RxJava. This doesn’t annotate everything  but I think it’s a good start.  In particular  when migrating a large codebase of RxJava 1.x code to 2.x  catching null returns in these interfaces was very difficult. At best  it’s noticed while migrating  otherwise it’s up to unit tests or a production crash to catch these.  With these new annotations  you get much better IDE support (once you tell IntelliJ about the new annotation): <img width= 563  alt= screen shot 2017-01-27 at 2 30 18 pm  src= https://cloud.githubusercontent.com/assets/23467/22362686/7f172032-e49f-11e6-9fc6-94049c263ceb.png > ^ in this example   getPhoneNumber()  is marked as  @Nullable   In addition  support for this annotation can easily be added to static analysis tools like Infer  checker  or any other popular tool.  Open Questions * Does this even make sense to add? There seem to be some concerns in the issue. * The  @NonNull  annotation needs JavaDoc - I’m planning on following up with whatever is in existing NonNull annotations floating around unless anyone thinks otherwise. * There are no tests since this is essentially just metadata. Should there be something that enforces this? I m not sure if there is any kind of lint tool that runs on this project  but one approach would be to write a check that enforces everything in specific packages in annotated. This would also help keep future changes annotated. * Is it worth adding this elsewhere? I find these function interfaces to be the easiest place to run into nullability problems  but I m curious what others think. A simple  but kind of crazy brute force approach would be to require annotations on every public API.,
0,0,0,0,0,0,Maksim Moiseikin, 6525 6528,0,0,0,0,1,0, 3.x: remove  test  from  testXXX  method names  create a validator Rename test methods and enable the check, Fix #6518.  - [X] Create validator - [X] Automatically rename methods  testXXX  to  xxx  (analog to [FixLicenseHeaders](https://github.com/ReactiveX/RxJava/blob/3.x/src/test/java/io/reactivex/validators/FixLicenseHeaders.java) check) - [x] Rename methods Fix #6518.,
0,0,0,0,0,0,Tobias Bieniek, 3340,0,0,0,0,1,1, test/subjects: Use statically imported never() methods, ... and remove the unused Mockito imports,
0,0,0,0,0,0,Artur Dryomov, 4767,0,0,0,0,1,0, 2.x: Rename BackpressureStrategy.NONE to MISSING, As discussed in #4643.,
0,0,0,0,1,0,Artem Hluhovskyi, 6559 6560,0,0,0,0,1,1, 3.x Fix NPE when debouncing empty source 2.x Fix NPE when debouncing empty source, **Background** Related issue #6558   Debounce with selector on the empty  Observable  leads to NPE.  It happens because of  DebounceObserver#debouncer  field is set up only when  onNext  is called. When  onNext  isn t called at all  like when debouncing  Observable.empty()   we get a null reference from  debouncer  and call  emit  on  null  which actually leads to NPE.  **Change** Wrap  emit  call with null check both in  ObservableDebounce  and  FlowableDebounce   **Test plan** To check  Observable :     ./gradlew test --tests  io.reactivex.internal.operators.observable.ObservableDebounceTest.debounceOnEmpty       To check  Flowable :     ./gradlew test --tests  io.reactivex.internal.operators.flowable.FlowableDebounceTest.debounceOnEmpty **Background** Related issue #6558  Cherry pick of #6559 for 2.x version  Debounce with selector on the empty  Observable  leads to NPE.  It happens because of  DebounceObserver#debouncer  field is set up only when  onNext  is called. When  onNext  isn t called at all  like when debouncing  Observable.empty()   we get a null reference from  debouncer  and call  emit  on  null  which actually leads to NPE.  **Change** Wrap  emit  call with null check both in  ObservableDebounce  and  FlowableDebounce   **Test plan** To check  Observable :     ./gradlew test --tests  io.reactivex.internal.operators.observable.ObservableDebounceTest.debounceOnEmpty       To check  Flowable :     ./gradlew test --tests  io.reactivex.internal.operators.flowable.FlowableDebounceTest.debounceOnEmpty,
0,0,1,0,1,1,Jake Wharton, 4677 4710 4711 3587 3609 4745 3849 3856 3871 3879 4053 4055 4058 4069 4070 4074 4080 4081 4083 4084 4087 4094 4095 4101 4102 4105 4106 4108 4110 4111 4112 4114 4127 4128 4285 4287 4289 4291 4292 4293 4294 4305 4307 4308 4314 4315 4316 4317 6769 6770 6771 5047 6781 4318 4319 4323 4324 4326 4333 4338 4353 4372 4379 4380 4381 4382 4383 4385 4386 4387 4390 4391 4398 4423 4425 4625,1,1,1,1,1,1, 1.x: Cleanups from making NotificationLite stateless. 2.x: Remove checked exceptions from transformer interfaces. 2.x: Decouple stream operators from Function interface. Remove the need for javac to generate synthetic methods. delaySubscription(Func0) does not use a scheduler 1.x: Remove unused helper class previously used by extend(). Remove unused local. Provide factories for creating the default scheduler instances. Deprecate remaining public scheduler types. Expose scheduler factories which accept thread factories. 2.x: Convert SchedulerSupport annotation to accept a string value. 2.x: Update conversion method name to reflect new base type names. Use DisposableHelper and SubscriptionHelper to reduce duplication. Remove second type parameter from Subject and FlowProcessor. 2.x: Merge SerialDisposable and MultipleAssignmentDisposable. 2.x: Use more DisposableHelper and SubscriptionHelper in operators. 2.x: Replace custom empty Disposables with global instance. 2.x: Do not leak the DISPOSED marker instance into public API. 2.x: Merge CancelledSubscriber into EmptySubscriber. 2.x: More uses of SubscriptionHelper. 2.x: Normalize request validation using SubscriptionHelper. 2.x: Remove EmptySubscriber  start to remove NbpEmptySubscriber. 2.x: Invert request validation return type for better semantics. 2.x: Switch a SerialResource use to SerialDisposable. 2.x: Expose isDisposed method on Disposable. 2.x: Remove some superfluous reads before writes. 2.x: Remove explicit cancel flags where it can be inferred. 2.x: Invert subscription validation return type for better semantics. 2.x: Remove explicit cancel flags where it can be inferred. 2.x: Simplify boolean disposables which run code on dispose. 2.x: Switch the last SerialResource to manual resource management. 2.x: Case IO acronym like a word. 2.x: Correct method name for Flowable-->Observable. 2.x: Reduce the visibility of internal methods. 2.x: Remove defunct  Nbp  prefix from Observable interfaces. 2.x: Elide ObservableWrapper for empty and never. 2.x: Elide more create/callback wrappers in favor of direct Observables. 2.x: Promote anonymous Observables to top-level types. 2.x: Actually apply custom scheduler when applying future. 2.x: Correct default subscriber name. 2.x: Inline generic-free runnable and long consumer method. 2.x: Rename source/publisher wrapper class to more semantic  from  name. 2.x: Promote lift implementations to top-level types. 2.x: Promote Observable to Single/Flowable adapters to top-level types. 2.x: Rename FlowableSource to FlowableWithUpstream to match ObservableWithUpstream. 2.x: Use ArrayListSupplier in more places  add HashMapSupplier. 2.x: Normalize empty and never sources. 2.x: Rename create to unsafeCreate  add  safe  create methods. [3.x] Remove deprecated method from 2.x [3.x] Replace some ObjecsHelpers methods with Java 8 APIs [3.x] Replace ObjectHelper.requireNonNull with Objects.requireNonNull 2.x: Document and test amb subscription ordering. 3.x: Migrate Disposables static factories to Disposable interface 2.x: Switch (almost) all chain operators to FlowableWithUpstream. 2.x: Switch (almost) all remaining chain operators to ObservableWithUpstream. 2.x: No scheduler change happens for timeInterval() and timestamp(). 2.x: Skip static factories when converting between stream types. 2.x: Extract  WithUpstream  interfaces. 2.x: Add  WithUpstream  interfaces to connectable implementations. 2.x: Remove conditional resource management from async listeners. 2.x: Accept subclasses of Throwable for asserting failure. 2.x: Implement ObservableHide for also masking the Disposable. 2.x: Move single-use top-level type to nested class of its only use. 2.x: Remove test scheduler factory. 2.x: Correct factory method name for converting an RS Publisher. 2.x: Correctly dereference subscription before comparing against null. 2.x: Remove double dash on RxThreadFactory thread names. 2.x: Free upstream resources when default observer/subscriber is canceled. 2.x: Move error consumer helper to internal API. 2.x: Remove unused test methods from safe observer/subscriber. 1.x: Remove explicit StackOverflow check as its a VirtualMachineError. 2.x: Remove explicit StackOverflow check as its a VirtualMachineError. 2.x: Avoid potential NPE when onError throws. 1.x: Add to() conversion function to all stream types. 1.x: Remove  Completable  prefix from nested interfaces  move its subscription to top-level. 2.x: Replace  resource  observers with plain  disposable  observers in tests., nan These functions are for transforming the stream shape  not doing work. Any operation that would throw a checked exception should happen inside the stream  not when shaping it.  Closes #4709. This allows a single class to implement itself as an operator for all stream types. A similar change was recently made to the transformer types.  From https://github.com/ReactiveX/RxJava/pull/4672#issuecomment-252417909. Outer classes accessing inner class private fields and methods (and vise versa) causes javac to generate package-scoped trampolines. These bloat the class files  adds overhead to the inliner analysis  and for Android create needless method that eat away at our fixed limit of methods in an application. By simply promoting the private interactions to package scope directly  the synthetic methods do not need generated.  2.5% of RxJava s methods were these needless generated trampolines accounting for 1.2% of jar size and 1.4% of dex size.      $ dex-method-count before.dex 5005  $ dex-method-count after.dex 4875          -rw-r--r--   1 jw  jw   699K Dec 25 03:08 after.dex -rw-r--r--   1 jw  jw   952K Dec 25 03:08 after.jar -rw-r--r--   1 jw  jw   709K Dec 25 03:06 before.dex -rw-r--r--   1 jw  jw   964K Dec 25 03:06 before.jar It subscribes to the upstream  Observable  on the emitting thread of the other  Observable  obtained from the  Func0 . nan nan Unlike other hooks  the  RxJavaSchedulersHook  has no access to the real  Scheduler  instances in order to do wrapping/delegation. With these factory methods  a hook can access what would otherwise be the instance used since there is often no other means of creating these specialized schedulers.  For Android this wrapping/delegation use-case is important for UI testing. We have a means to tell the testing framework when the app is idle and to do that we need to hook into the schedulers to know when they re empty. This is easy to do currently  but you cannot wrap the real instance and instead have to supply alternate implementations which might subtly alter the behavior under test.  These three methods are referenced in #3724  and I think providing the defaults is useful as well as eventually adding overloads which take  ThreadFactory  instances for each. A continuation of some work done in #3856 of removing uninstantiable types from the public API (via deprecation). This allows hooks to create schedulers whose threads have different priorities.  Closes #3724. Closes #4052. nan A lot of operators contained their own marker instance and class definition of Disposable or Subscription. This changes almost all of them to use the shared instance provided by their respective helper class. Some duplication still exists but can be cleaned up in a subsequent change. Closes #4056. Closes #4057 although doesn t address the name of the class. nan I keep thinking I found all of these and then more crop up... If this were to be used by public code it could have have Very Bad™ effects by causing operators to think that they already disposed resources when they actually had not. Since  Disposable  is stateless it s safe for  disposed()  and  empty()  to be synonymous  although that might change in the future so both methods are retained. nan nan nan Follow up from comments in #4083 and #4085. nan nan This is a fairly  dumb  addition. There s lots of room for follow-up improvement in the utilization of base helper classes and even removing some now-duplicated state management.  Closes #4075. nan I suspect there s quite a few of these all over. These are just the ones I noted while doing other changes. nan nan nan nan This is already being done in the library  and is fairly [standard practice](https://google.github.io/styleguide/javaguide.html#s5.3-camel-case). nan nan nan nan nan nan Correct annotatoin declaration as well. nan nan nan nan nan nan nan nan This is a proposal to solve #4255 but for 2.x and closes #4286 built around one goal: make the  create  methods actually usable by developers!  Currently the advice given to most developers using 1.x is avoid  create  unless you are absolutely 100% sure you understand backpressure and cancellation  and even then avoid it if possible. This method is a trap that most new developers fall into. _The method is named  create   after all  so it must be how I create these things!_ I want to make that statement not only correct  but advisable (at least when the still-convenient  from  methods are not suitable  such as when wrapping callback-based APIs).  Because  Observable    Single   and  Completable  are backpressure-free  this amounts to just suppressing downstream notifications when disposed. This doesn t seem too controversial.  The most controversial part is that I have renamed  Flowable.fromAsync  to  Flowable.create  thus making it the canonical way for users to create  Flowable s directly. I m much less opinionated on this change  but it felt wrong to have an  Flowable.unsafeCreate  with no associated  create  and  fromAsync  is the  safest  version we have. nan nan It big. Refs #5044. nan nan nan nan Also rename Publisher->Completable factory method and operator implementation to match other stream types. This allows use with types that do not extend directly from their base stream types. nan Rename them to have a  Resource  prefix. nan nan nan This method is misleading in that it s a factory next to a bunch of accessor methods to shared resources. The TestScheduler constructor is public and can be used directly. nan nan Also optimize name creation to avoid  StringBuilder  having to expand its underlying  char[] . nan nan nan Looks like [the linked comment](https://github.com/ReactiveX/RxJava/issues/748#issuecomment-32471495) was misinterpreted (but not in a way that affected the implementation) as Scala considered StackOverflowError as non-fatal but RxJava always considered it fatal. As such  its explicit check was redundant. Looks like [the linked comment](https://github.com/ReactiveX/RxJava/issues/748#issuecomment-32471495) was misinterpreted (but not in a way that affected the implementation) as Scala considered StackOverflowError as non-fatal but RxJava always considered it fatal. As such  its explicit check was redundant. t2 was only initialized if canceling threw an exception. In the happy path it would have never been initialized so when onError threw the call to suppress() would NPE. This deprecates extend() on Observable  which is a less powerful version of these functions. This is only the  Completable  part of #4420. It does not make  CompletableSubscriber  an abstract class nor create  Single.Operator . This makes the resource observers unused internally and I m curious as to whether they deserve to stick around in the public API. Any thoughts?,
0,0,0,0,0,0,Mark Rietveld, 3488,0,0,1,0,0,0, 1.x Remove all instances of Atomic*FieldUpdater, Replace them all with their respective Atomic\* counterparts For example AtomicLongFieldUpdater -> AtomicLong Addresses https://github.com/ReactiveX/RxJava/issues/3459,
0,0,0,0,0,0,Phil Glass, 5615 5616 5617,0,0,1,0,1,0, 2.x: Add missing license headers 2.x: Add Single.delay overload that delays errors 2.x: Fix Observable.delay & Flowable.delay javadoc, FixLicenseHeaders  is currently failing when run locally (it s skipped on CI). Much like #5382  I discovered when trying to fake a slow/flaky backend that  Single.delay  doesn t delay errors.  This PR adds an overload that does  bringing  Single.delay  in line with  Observable.delay . It also corrects the javadoc for existing overloads (#5409 only updated 1/2). Error notifications can be delayed when using the overloads with a  delayError  parameter.,
0,0,0,0,1,0,Mairbek Khadikov, 129 137 138 156 157 159 165 167 168 171 176 232 236,0,0,1,0,0,0, Code cleanup Implemented range operator. Fixes issue #68 Implemented SequenceEqual Operator Implemented ToIterable Operation Implemented single and singleOrDefault Implemented LastOrDefault Operator Fixed bug in ranges Reimplemented Last operation Implemented Most Recent Implemented Defer Operation Implemented GroupBy Corrected naming Fixed Sleeping Action, Cleaned up some warnings highlighted by Intellij Idea nan Fixes issue #76  Since there is no direct analogue of  IEqualityComparer  in Java   Func2<T  T  Boolean>  has been used. For issue #18.  This would allow to implement other blocking methods like  single    lastOrDefault  next. For issue #77. For issue #58 Fixed issue #164. For issue #57. For issue #64. For issue #35. For issue #51. Renamed  Operator  to  Operation  to be consistent. Sleeping action wasn t working correctly.,
0,0,0,0,0,1,Matt Jacobs, 447 801 825 1388 1559,0,0,1,0,1,0, Caching the result of  isInternalImplementation Added more possible failure cases to CompositeExceptionTest Issue #799 - Commenting out the call to attachCallingThreadStack when co... CompositeException stops mutating nested Exceptions More consistent hooks for scheduler plugins.  This is a rework of #1514., Currently  reflective getPackage() call happens on every subscribe() invocation.  This PR sets up a Concurrent HashMap to cache the result of this call per-class. nan ...nstructing a CompositeException Instead  it aggregates them at print-time. Since nothing is being mutated  there s no chance of accidentally creating a cycle in the Exception chain.  We ran into this in production very intermittently and had to add handling any time we were touching the Exception chain. - Deprecated RxJavaDefaultSchedulers and RxJavaDefaultSchedulersDefault (I think these names are confusing) - Added RxJavaSchedulersHook - Ability to override entire schedulers from scratch - Ability to decorate Action0 before submission to Scheduler  The main change from #1514 is the decoration of Action0 instead of Runnable.  Action0 is an improvement as all Schedulers must handle these  whereas not all Schedulers handle Runnables.,
